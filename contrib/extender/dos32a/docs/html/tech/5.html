<html>
<head>
  <title>DOS/32 Advanced DOS Extender - Documentation: Technical Reference [Exceptions and IRQs]</title>
  <link rel="stylesheet" href="../sheet.css">
</head>
<body bgcolor="#ffffff" link="#0000f0" alink="#f00000" vlink="#700070">

<table cellpadding="0" cellspacing="0" border="0" width="660"><tr><td>



<p>&nbsp;</p>

<p><center><b><i><font color="#990000" size=+2>DOS/32 Advanced DOS Extender
- Technical Reference</font></i></b></center></p>

<p><center><hr width="90%" size="1"></center></p>

<p><font size=-1 face="Verdana, Arial, Helvetica"><br>
</font><b><font face="Verdana, Arial, Helvetica">5.0 - DOS/32 Advanced -
Exceptions and Hardware Interrupts (IRQs)<br>
</font></b></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">DOS/32 Advanced DOS Extender
has quite a complex scheme of passing the hardware interrupts (IRQs) down
to the real mode. The problem with these interrupts, is that by default
the master PIC (Programmable Interrupt Controller) is mapped at software
interrupts INT 08-0Fh, which are reserved on Intel's processors for the
CPU exceptions.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">Whenever an interrupt
handlers installed for INTs 08-0Fh are executed, they must first check if
the interrupt was a processor exception, or a hardware interrupt. This is
done automatically by the DOS/32 Advanced, which will use interrupt buffering
technique to separate the hardware interrupts from the exceptions, and you
do not have to worry about it when writing your interrupt handlers.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">What you should know about
IRQ handlers, is that when you read/install an IRQ handler using ADPMI functions
0204h/0205h it will be read/written into a special buffer inside ADPMI kernel
instead of IDT. The ADPMI will always receive interrupts INT 08-0Fh first,
examine them and send them to the proper interrupt handlers, either IRQ
or Exception handlers. This is accomplished as fast as possible, but there
will always be a short delay before your IRQ handler is executed. The overall
system performance are not degraded since the delay time is so short, that
few (if any) devices are capable of sending the second IRQ before the first
one is processed.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">The ADPMI supports the
first 16 exceptions, except 0Ch - Stack fault. The exceptions 10h - Coprocessor
Error, 11h - Alignment Check Error and 12h - Machine Check Error are not
supported either and no exception handler will be installed for them.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">Please note, that even
DOS/4GW DOS Extender does not handle the exception 0Ch properly, since it
must be handled through a Task Gate because the state of the stack is unknown
when the exception handler is executed.</font></p>

<p>&nbsp;</p>

<p><font size=-1 face="Verdana, Arial, Helvetica">Whenever an exception
occurs, DOS/32 Advanced will take the following actions:</font></p>

<blockquote>
  <p><font size=-1 face="Verdana, Arial, Helvetica">1) switch to an internal
  stack<br>
  2) reset PIT (timer) to the default 18.2Hz<br>
  3) restore real mode interrupts (must be configured to do so)<br>
  4) set BIOS videomode 03h (if configured to do so)<br>
  5) report the exception and the CPU state<br>
  6) exit to DOS</font></p>
</blockquote>

<p>&nbsp;</p>

<p><font size=-1 face="Verdana, Arial, Helvetica">Below is shown an example
of a report generated by the DOS Extender on an exception:</font></p>

<p><center><table border="0" cellspacing="0" cellpadding="4">
<tr>
<td width="100%" bgcolor="#eeeeee"><tt>
DOS/32A run-time (6001): exception (INT 0Dh)<br>
Identity: general protection fault at &lt;0830:0091108D&gt;<br>
Unrelocated crash address &lt;1:0000007D&gt;, error code pushed on stack &lt;0000C800&gt;<br>
========================================================================APP/32=<br>
EFLAGS = 00013246 [00110010|01000110] &nbsp;CS:[EIP] = 2E 88 80 F8 36 15 00 31 C0 F7<br>
EAX = 00000000 &nbsp;&nbsp; ESI = 016D2933 &nbsp; &nbsp; &nbsp; Last INT = 21h &nbsp;&nbsp; SS:[ESP+00] = 12345678<br>
EBX = A00020CD &nbsp;&nbsp; EDI = 26E7016D &nbsp; &nbsp; &nbsp; CR0 = 00000011 &nbsp;&nbsp; SS:[ESP+04] = 016EDB30<br>
ECX = FEF09A00 &nbsp;&nbsp; EBP = 00000000 &nbsp; &nbsp; &nbsp; CR2 = 00000000 &nbsp;&nbsp; SS:[ESP+08] = 00000000<br>
EDX = 01C0F01D &nbsp;&nbsp; ESP = 009124C0 &nbsp; &nbsp; &nbsp; CR3 = 00000000 &nbsp;&nbsp; SS:[ESP+0C] = 12345678<br>
CS: = 0830&nbsp; Base=00000000 Limit=000FFFFF Gr=PAGE Seg=CODE/32bit Type=5 Acc=DF9B<br>
DS: = 0820&nbsp; Base=00000000 Limit=000FFFFF Gr=PAGE Seg=DATA/32bit Type=1 Acc=DF93<br>
ES: = 0068&nbsp; Base=00029B40 Limit=000000FF Gr=BYTE Seg=DATA/32bit Type=1 Acc=5093<br>
SS: = 0820&nbsp; Base=00000000 Limit=000FFFFF Gr=PAGE Seg=DATA/32bit Type=1 Acc=DF93<br>
FS: = 0840&nbsp; Base=00000000 Limit=000FFFFF Gr=PAGE Seg=DATA/32bit Type=1 Acc=DF93<br>
GS: = 0000&nbsp; NULL selector<br>
</tt>
</td>
</tr>
</table>
</center></p>

<p>&nbsp;</p>

<p><font size=-1 face="Verdana, Arial, Helvetica">The unrelocated crash
address will show where in your program the error had occurred. If you are
using WATCOM C/C++ to create your applications, you may want to create a
map file when linking the program. In the map file the linker will show
all the subroutines that are declared as public, and their respective unrelocated
addresses. The first number (before the colon) is the number of the Object
in which the error had occurred, followed by an unrelocated address of the
function/variable.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">HINT: use <a href="../util/4.html">SUNSYS Debugger</a>
with the program which contains error, press the '4' key on the main keyboard
to show the unrelocated addresses. Use the ENTER key to enter the address
of the faulting instruction that was reported by DOS/32 Advanced (do not
forget the '.' before the address to indicate that it is an unrelocated
address) and debug the code.</font></p>

<p>&nbsp;</p>

<p><font size=-1 face="Verdana, Arial, Helvetica">When you install a protected
mode IRQ handler, the DOS Extender will automatically install a special
real mode IRQ callback, which will send the IRQ occurred in the real mode
to a protected mode interrupt handler. Unlike DOS/4GW which supports this
technique only for the first eight IRQs (IRQs 0-7 = INTs 08-0Fh), DOS/32
Advanced will install real mode IRQ callbacks for all 16 hardware interrupts
(IRQ 0-7, IRQ 8-15 = INT 08-0Fh, INT 70-77h). Further more DOS/32 Advanced
is capable of trapping the software interrupts that have been issued to
emulate IRQs in protected mode.</font></p>

<p><font size=-1 face="Verdana, Arial, Helvetica">DOS/32 Advanced supports
PICs remapped to other interrupt vectors than the default INTs 00-0Fh and
70-77h. In fact, when the PICs are remapped by the system (only VCPI servers
can remap PICs), the IRQs will be processed slightly faster, since there
will be no need in testing them against the exceptions and no interrupt
buffering will be used. Though, DOS/32 Advanced will never remap the PICs
itself. </font></p>

<p>&nbsp;</p>

<p><center><hr width="90%" size="1"></center></p>
<p><center><font size=-2 face="Verdana, Arial, Helvetica">Copyright &copy; DOS/32 Advanced Team 1996-2002<br>All Rights Reserved</font></center>
</td></tr></table>
</body>
</html>
