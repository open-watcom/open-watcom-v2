/****************************************************************************
*
*                            Open Watcom Project
*
*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
*
*  ========================================================================
*
*    This file contains Original Code and/or Modifications of Original
*    Code as defined in and that are subject to the Sybase Open Watcom
*    Public License version 1.0 (the 'License'). You may not use this file
*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
*    provided with the Original Code and Modifications, and is also
*    available at www.sybase.com/developer/opensource.
*
*    The Original Code and all software distributed under the License are
*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
*    NON-INFRINGEMENT. Please see the License for the specific language
*    governing rights and limitations under the License.
*
*  ========================================================================
*
* Description:  Generate scaffolding for autogenerated option parsing.
*
****************************************************************************/


#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stddef.h>
#include "bool.h"
#include "lsspec.h"
#include "encodlng.h"

// functions that are supplied by the host environment
#define FN_UNGET            "OPT_UNGET"                 // void ( void )
#define FN_GET_LOWER        "OPT_GET_LOWER"             // int ( void )
#define FN_RECOG            "OPT_RECOG"                 // bool ( int )
#define FN_RECOG_LOWER      "OPT_RECOG_LOWER"           // bool ( int )
#define FN_END              "OPT_END"                   // bool ( void )

#define FN_NUMBER           "OPT_GET_NUMBER"            // bool ( unsigned * )
#define FN_NUMBER_DEFAULT   "OPT_GET_NUMBER_DEFAULT"    // bool ( unsigned *, unsigned )
#define FN_NUMBER_MULTIPLE  "OPT_GET_NUMBER_MULTIPLE"   // bool ( OPT_NUMBER ** )
#define FN_CHAR             "OPT_GET_CHAR"              // bool ( int * )
#define FN_CHAR_OPT         "OPT_GET_CHAR_OPT"          // bool ( int * )
#define FN_ID               "OPT_GET_ID"                // bool ( OPT_STRING ** )
#define FN_ID_OPT           "OPT_GET_ID_OPT"            // bool ( OPT_STRING ** )
#define FN_FILE             "OPT_GET_FILE"              // bool ( OPT_STRING ** )
#define FN_FILE_OPT         "OPT_GET_FILE_OPT"          // bool ( OPT_STRING ** )
#define FN_PATH             "OPT_GET_PATH"              // bool ( OPT_STRING ** )
#define FN_PATH_OPT         "OPT_GET_PATH_OPT"          // bool ( OPT_STRING ** )

#define FN_CLEAN_STRING     "OPT_CLEAN_STRING"          // void ( OPT_STRING ** )
#define FN_CLEAN_NUMBER     "OPT_CLEAN_NUMBER"          // void ( OPT_NUMBER ** )

#define FN_PROCESS          "OPT_PROCESS"               // bool ( OPT_STORAGE * )
#define FN_INIT             "OPT_INIT"                  // void ( OPT_STORAGE * )
#define FN_FINI             "OPT_FINI"                  // void ( OPT_STORAGE * )

#define USE_SWITCH_THRESHOLD    (4)
#define CONSOLE_WIDTH           (79)

#define BUFF_SIZE               1024

#define HAS_OPT_STRING( o )     ( (o)->is_id || (o)->is_file || (o)->is_path || (o)->is_special )
#define HAS_OPT_NUMBER( o )     ( (o)->is_number && (o)->is_multiple )

#define NOCHAIN                 ((CHAIN *)(pointer_int)-1)

#define SKIP_BEG_MARK(s)        if(*s==':')++s

#define mytolower(c)            (char)tolower( (unsigned char)c )

typedef enum tag_id {
#define TAG( s )        TAG_##s ,
#include "opttags.h"
#undef TAG
    TAG_UNKNOWN,
    TAG_NULL
} tag_id;

typedef enum flow_control {
    EC_NULL             = 0,
    EC_CONTINUE         = 0x01,
    EC_CHAIN            = 0x02
} flow_control;

typedef enum cvt_name {
    CVT_STRING,
    CVT_NORMALIZE,
    CVT_USAGE
} cvt_name;

typedef struct target TARGET;
struct target {
    TARGET      *next;
    unsigned    mask;
    char        name[1];
};

typedef struct name NAME;
struct name {
    NAME        *next;
    unsigned    is_timestamp : 1;
    char        name[1];
};

typedef struct title TITLE;
struct title {
    TITLE       *next;
    unsigned    target;
    unsigned    ntarget;
    char        *lang_title[LANG_MAX];
};

typedef struct chain CHAIN;
struct chain {
    CHAIN       *next;
    char        *Usage[LANG_MAX];
    size_t      clen;
    size_t      len;
    unsigned    usage_used : 1;
    unsigned    code_used : 1;
    char        name[1];
};

typedef struct option OPTION;
struct option {
    OPTION      *next;
    OPTION      *synonym;
    char        *lang_usage[LANG_MAX];
    char        *check;
    char        *special;
    char        *special_arg_usage;
    char        *field_name;
    char        *value_field_name;
    NAME        *enumerate;
    char        *immediate;
    char        *code;
    unsigned    number_default;
    unsigned    target;
    unsigned    ntarget;
    unsigned    default_specified : 1;
    unsigned    is_simple : 1;
    unsigned    is_immediate : 1;
    unsigned    is_code : 1;
    unsigned    is_internal : 1;
    unsigned    is_multiple : 1;
    unsigned    is_number : 1;
    unsigned    is_id : 1;
    unsigned    is_char : 1;
    unsigned    is_file : 1;
    unsigned    is_optional : 1;
    unsigned    is_path : 1;
    unsigned    is_special : 1;
    unsigned    is_prefix : 1;
    unsigned    is_timestamp : 1;
    unsigned    is_negate : 1;
    CHAIN       *chain;
    size_t      slen;
    char        *sname;
    char        name[1];
};

typedef struct codeseq CODESEQ;
struct codeseq {
    CODESEQ     *sibling;
    CODESEQ     *children;
    OPTION      *option;
    char        c;
    unsigned    sensitive : 1;
    unsigned    accept : 1;
    unsigned    chain : 1;
    unsigned    chain_root : 1;
};

static unsigned     line;
static FILE         *gfp;
static FILE         *ofp;
static FILE         *pfp;
static FILE         *ufp;
static FILE         *mfp;
static FILE         *bfp;

static char         ibuff[BUFF_SIZE];
static char         tagbuff[BUFF_SIZE];
static char         tokbuff[BUFF_SIZE];
static char         enumbuff[BUFF_SIZE];
static char         hdrbuff[BUFF_SIZE];
static char         maxusgbuff[BUFF_SIZE];

static char         alternateEqual;
static CHAIN        *lastChain;
static size_t       maxUsageLen;
static char         *pageUsage[LANG_MAX];
static unsigned     targetMask;
static unsigned     targetAnyMask;
static unsigned     targetDbgMask;
static unsigned     nextTargetMask = 1;

static tag_id getsUsage = TAG_NULL;

static char *tagNames[] = {
#define TAG( s )        #s ,
#include "opttags.h"
#undef TAG
    NULL
};

#define TAG( s )        static void do##s( char * );
#include "opttags.h"
#undef TAG

static void (*processTag[])( char * ) = {
#define TAG( s )        do##s ,
#include "opttags.h"
#undef TAG
    NULL };

static char *validTargets[] = {
    "any",
    "dbg",
    "i86",
    "386",
    "axp",
    "ppc",
    "mps",
    "sparc",
    "bsd",
    "dos",
    "linux",
    "nt",
    "os2",
    "osx",
    "qnx",
    NULL
};

static const char * const langName[] = {
    #define LANG_DEF( id, dbcs )        #id ,
    LANG_DEFS
    #undef LANG_DEF
};

static uint_8 const langMaxChar[] = {
    #define LANG_DEF( id, dbcs )        dbcs ,
    LANG_DEFS
    #undef LANG_DEF
};

static char *usageMsg[] = {
    "optencod [-i] [-l <lang-n>] [-n] [-q] [-u <usage-u>] <gml-file> <option-h> <parse-c> <usage-h> <target>*",
    "where:",
    "    <gml-file> is the tagged input GML file",
    "    <parse-c> is the output file for the command line parser code",
    "    <parse-h> is the output file for the command line parser data declaration",
    "    <usage-h> is the output file for the usage string file",
    "    <usage-u> is the output file for the QNX usage file",
    "    <lang-n> is the language(number) used for output data",
    "    <target> can be chosen from:",
    NULL
};

static struct {
    unsigned    international : 1;
    unsigned    quiet : 1;
    unsigned    no_equal : 1;
    unsigned    alternate_equal : 1;
    unsigned    zero_term : 1;
    unsigned    lang;
} optFlag;

static TARGET   *targetList;
static NAME     *enumList;
static NAME     *enumeratorList;
static OPTION   *optionList;
static OPTION   *uselessOptionList;
static TITLE    *titleList;
static CHAIN    *chainList;

static TITLE    *targetTitle;

static void emitCode( CODESEQ *h, unsigned depth, flow_control control );

#if defined( __WATCOMC__ )
#pragma abort   fail
#endif
static void fail( char *msg, ... )
{
    va_list args;

    if( line ) {
        fprintf( stderr, "error on line %u\n", line );
    }
    va_start( args, msg );
    vfprintf( stderr, msg, args );
    va_end( args );
    exit( EXIT_FAILURE );
}

static void dumpUsage( void )
{
    char **p;

    for( p = usageMsg; *p != NULL; ++p ) {
        fprintf( stderr, "%s\n", *p );
    }
    fprintf( stderr, "        " );
    for( p = validTargets; *p != NULL; ++p ) {
        fprintf( stderr, "%s ", *p );
    }
    fprintf( stderr, "\n" );
}

static void emitPrintf( unsigned depth, char *msg, ... )
{
    va_list args;
    unsigned i;

    if( pfp != NULL ) {
        for( i = ( depth >> 1 ); i != 0; --i ) {
            fprintf( pfp, "\t" );
        }
        if( depth & 1 ) {
            fprintf( pfp, "    " );
        }
        va_start( args, msg );
        vfprintf( pfp, msg, args );
        va_end( args );
    }
}

static void cvtName( char *dst, char *src, cvt_name cvt )
{
    char c;

    while( (c = *src++) != '\0' ) {
        if( c == '\\' ) {
            if( cvt == CVT_NORMALIZE ) {
                *dst++ = c;
            }
            c = *src++;
        } else if( cvt != CVT_USAGE ) {
            c = mytolower( c );
        }
        *dst++ = c;
    }
    *dst = c;
}

static bool cmpOptName( char *n1, char *n2 )
{
    char    c1;
    char    c2;

    for( ;; ) {
        c1 = *n1++;
        c2 = *n2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( FALSE );
            }
            c1 = *n1++;
            c2 = *n2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( FALSE );
        }
        if( c1 == '\0' ) {
            break;
        }
    }
    return( TRUE );
}

static bool cmpChainName( char *n1, char *n2, size_t len )
{
    size_t  i;
    char    c1;
    char    c2;

    for( i = 0; i < len; ++i ) {
        c1 = *n1++;
        c2 = *n2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( FALSE );
            }
            c1 = *n1++;
            c2 = *n2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( FALSE );
        }
    }
    return( TRUE );
}

static void addTarget( char *t )
{
    size_t len;
    TARGET *p;

    len = strlen( t );
    p = malloc( sizeof( *p ) + len );
    p->mask = nextTargetMask;
    p->next = targetList;
    targetList = p;
    strcpy( p->name, t );
    nextTargetMask <<= 1;
    if( nextTargetMask == 0 ) {
        fail( "too many targets defined\n" );
    }
}

static unsigned findTarget( char const *t )
{
    TARGET *p;

    for( p = targetList; p != NULL; p = p->next ) {
        if( strcmp( t, p->name ) == 0 ) {
            return( p->mask );
        }
    }
    return( 0 );
}

static NAME *findName( NAME **h, char *n )
{
    NAME *p;

    for( p = *h; p != NULL; p = p->next ) {
        if( strcmp( n, p->name ) == 0 ) {
            return( p );
        }
    }
    return( NULL );
}

static NAME *addName( NAME **h, char *n )
{
    size_t len;
    NAME *p;

    len = strlen( n );
    p = malloc( sizeof(*p) + len );
    strcpy( p->name, n );
    p->next = *h;
    *h = p;
    return( p );
}

static NAME *addEnumerator( char *enumerate, char *field_name )
{
    NAME *n;

    strcpy( enumbuff, "OPT_" );
    strcat( enumbuff, enumerate );
    strcat( enumbuff, "_" );
    strcat( enumbuff, field_name );
    n = findName( &enumeratorList, enumbuff );
    if( n == NULL ) {
        n = addName( &enumeratorList, enumbuff );
    }
    return( n );
}

static CHAIN *findChain( char *n )
{
    CHAIN *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( cmpChainName( cn->name, n, cn->len ) ) {
            return( cn );
        }
    }
    return( NULL );
}

static CHAIN *addChain( char *n, bool chain )
{
    size_t len;
    CHAIN *cn;

    cvtName( n, n, CVT_NORMALIZE );
    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( strcmp( n, cn->name ) == 0 ) {
            if( cn->code_used ) {
                fail( "CHAIN: option '%s' already defined\n", n );
            } else {
                fail( "USAGEGRP: option '%s' already defined\n", n );
            }
        }
    }
    len = strlen( n );
    cn = malloc( sizeof( *cn ) + len );
    cn->len = len;
    memcpy( cn->name, n, len + 1 );
    cvtName( n, n, CVT_STRING );
    cn->clen = strlen( n );
    cn->code_used = chain;
    for( i = 0; i < LANG_MAX; ++i ) {
        cn->Usage[i] = NULL;
    }
    cn->next = chainList;
    chainList = cn;
    return( cn );
}

static void procCmdLine( int argc, char **argv )
{
    char **t;
    unsigned mask;
    char const *p;

    if( argc < 5 ) {
        dumpUsage();
        exit( EXIT_FAILURE );
    }
    if( strcmp( argv[1], "-i" ) == 0 ) {
        optFlag.international = 1;
        --argc;
        ++argv;
    }
    if( strcmp( argv[1], "-l" ) == 0 ) {
        optFlag.lang = atoi( argv[2] );
        argc -= 2;
        argv += 2;
    }
    if( strcmp( argv[1], "-n" ) == 0 ) {
        optFlag.zero_term = 1;
        --argc;
        ++argv;
    }
    if( strcmp( argv[1], "-q" ) == 0 ) {
        optFlag.quiet = 1;
        --argc;
        ++argv;
    }
    if( strcmp( argv[1], "-u" ) == 0 ) {
        mfp = fopen( argv[2], "wb" );
        if( !mfp ) fail( "cannot open '%s' for output", argv[2] );
        argc -= 2;
        argv += 2;
    }
    if( argc < 5 ) {
        dumpUsage();
        exit( EXIT_FAILURE );
    }
    ++argv;
    gfp = fopen( argv[0], "r" );
    if( !gfp ) fail( "cannot open '%s' for input", argv[0] );
    ++argv;
    if( strcmp( argv[0], "." ) == 0 ) {
        ofp = NULL;
    } else {
        ofp = fopen( argv[0], "w+" );
        if( ofp == NULL ) fail( "cannot open '%s' for output", argv[0] );
    }
    ++argv;
    if( strcmp( argv[0], "." ) == 0 ) {
        pfp = NULL;
    } else {
        pfp = fopen( argv[0], "w+" );
        if( pfp == NULL ) fail( "cannot open '%s' for output", argv[0] );
    }
    ++argv;
    if( strcmp( argv[0], "." ) == 0 ) {
        ufp = NULL;
    } else {
        ufp = fopen( argv[0], "w+" );
        if( ufp == NULL ) fail( "cannot open '%s' for output", argv[0] );
    }
    ++argv;
    for( t = validTargets; *t != NULL; ++t ) {
        addTarget( *t );
    }
    p = "any";
    if( (targetAnyMask = findTarget( p )) == 0 ) {
        fail( "invalid target name '%s'\n", p );
    }
    p = "dbg";
    if( (targetDbgMask = findTarget( p )) == 0 ) {
        fail( "invalid target name '%s'\n", p );
    }
    targetMask |= targetAnyMask;
    for( ; *argv != NULL; ++argv ) {
        p = *argv;
        if( (mask = findTarget( p )) == 0 ) {
            fail( "invalid target name '%s'\n", p );
        }
        targetMask |= mask;
    }
}

static char *skipSpace( char *p )
{
    while( *p != '\0' && isspace( *p ) ) {
        ++p;
    }
    return( p );
}

static char *copyNonSpaceUntil( char *i, char *o, char t )
{
    for( ; *i != '\0'; ++i ) {
        if( isspace( *i ) )
            break;
        if( *i == t ) {
            ++i;
            break;
        }
        *o = *i;
        ++o;
    }
    *o = '\0';
    return( i );
}

static tag_id findTag( char const *t )
{
    char **c;

    for( c = tagNames; *c != NULL; ++c ) {
        if( stricmp( t, *c ) == 0 ) {
            return( c - tagNames );
        }
    }
    return( TAG_UNKNOWN );
}

static tag_id isTag( char **eot )
{
    tag_id tag;
    char *p;

    p = ibuff;
    p = skipSpace( p );
    if( *p == ':' ) {
        ++p;
        p = copyNonSpaceUntil( p, tagbuff, '.' );
        if( (tag = findTag( tagbuff )) == TAG_UNKNOWN )
            fail( "unknown tag: %s\n", tagbuff );
        *eot = p;
        return( tag );
    }
    return( TAG_NULL );
}

static OPTION *pushNewOption( char *name, OPTION *o )
{
    size_t  len;
    OPTION  *newo;

    len = strlen( name );
    newo = calloc( 1, sizeof( *newo ) + len );
    memcpy( newo->name, name, len + 1 );
    cvtName( name, name, CVT_STRING );
    len = strlen( name );
    newo->slen = len;
    newo->sname = calloc( 1, len + 1 );
    memcpy( newo->sname, name, len + 1 );
    newo->synonym = o;
    newo->is_simple = 1;
    newo->next = optionList;
    optionList = newo;
    return( newo );
}

static char *pickUpRest( char *p )
{
    size_t len;

    len = strlen( p );
    if( len != 0 ) {
        if( p[len - 1] == '\n' ) {
            p[len - 1] = '\0';
        }
    }
    return( strdup( p ) );
}

// :argequal. <char>
static void doARGEQUAL( char *p )
{
    p = skipSpace( p );
    if( *p == '\0' ) {
        fail( ":argequal. must have <char> specified\n" );
    } else {
        alternateEqual = *p;
        optFlag.alternate_equal = 1;
    }
}

// :cmt comment text
static void doCMT( char *p )
{
    p = p;
}

// :internal.
static void doINTERNAL( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_internal = 1;
    }
}

// :option. <option> <synonym> ...
static void doOPTION( char *p )
{
    OPTION *synonym;

    targetTitle = NULL;
    synonym = NULL;
    while( *p != '\0' ) {
        p = skipSpace( p );
        if( *p == '\0' )
            break;
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        synonym = pushNewOption( tokbuff, synonym );
    }
    getsUsage = TAG_OPTION;
}

// :target. <targ> <targ> ...
static void doTARGET( char *p )
{
    unsigned mask;
    OPTION *o;

    while( *p != '\0' ) {
        p = skipSpace( p );
        if( *p == '\0' )
            break;
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->target |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->target |= mask;
            }
        }
    }
}

// :ntarget. <targ> <targ> ...
static void doNTARGET( char *p )
{
    unsigned mask;
    OPTION *o;

    while( *p != '\0' ) {
        p = skipSpace( p );
        if( *p == '\0' )
            break;
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->ntarget |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->ntarget |= mask;
            }
        }
    }
}

// :number. [<fn>] [<default>]
static void doNUMBER( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_number = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
        p = skipSpace( p );
        if( *p != '\0' ) {
            p = copyNonSpaceUntil( p, tokbuff, '\0' );
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->number_default = atoi( tokbuff );
                o->default_specified = 1;
            }
        }
    }
}

// :multiple.
static void doMULTIPLE( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_multiple = 1;
    }
}

// :nochain.
static void doNOCHAIN( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->chain = NOCHAIN;
    }
}

// :id. [<fn>]
static void doID( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_id = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
    }
}

// :char. [<fn>]
static void doCHAR( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_char = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
    }
}

// :immediate. <fn>
static void doIMMEDIATE( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_immediate = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->immediate = strdup( tokbuff );
        }
    } else {
        fail( ":immediate. must have <fn> specified\n" );
    }
}

// :code. <source-code>
static void doCODE( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_code = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->code = strdup( p );
        }
    } else {
        fail( ":immediate. must have <fn> specified\n" );
    }
}

// :file.
static void doFILE( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_file = 1;
        o->is_simple = 0;
    }
}

// :optional.
static void doOPTIONAL( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_optional = 1;
    }
}
// :negate.
static void doNEGATE( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_negate = 1;
        if( o->enumerate != NULL ){
            fail( "must be non-enumeration switch for negate tag\n" );
        }
    }
}


// :noequal.
static void doNOEQUAL( char *p )
{
    p = p;
    optFlag.no_equal = 1;
}

// :page. <text>
static void doPAGE( char *p )
{
    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    pageUsage[LANG_English] = pickUpRest( p );
    getsUsage = TAG_PAGE;
}

// :path.
static void doPATH( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_path = 1;
        o->is_simple = 0;
    }
}

// :chain. <option> <usage>
//
// mark options that start with <option> as chainable
// i.e., -oa -ox == -oax
static void doCHAIN( char *p )
{
    CHAIN *cn;

    p = skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <option> in :chain. tag\n" );
    }
    p = copyNonSpaceUntil( p, tokbuff, '\0' );
    cn = addChain( tokbuff, TRUE );
    p = skipSpace( p );
    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

// :enumerate. <name> <option>
static void doENUMERATE( char *p )
{
    NAME *n;
    OPTION *o;

    p = skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <name> in :enumerate. tag\n" );
    }
    p = copyNonSpaceUntil( p, tokbuff, '\0' );
    n = findName( &enumList, tokbuff );
    if( n == NULL ) {
        n = addName( &enumList, tokbuff );
    }
    tokbuff[0] = '\0';
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        addEnumerator( n->name, tokbuff );
    }
    addEnumerator( n->name, "default" );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->enumerate = n;
        if( o->is_timestamp ) {
            o->enumerate->is_timestamp = 1;
        }
        if( tokbuff[0] != '\0' ) {
            o->field_name = strdup( tokbuff );
        }
    }
}

// :special. <fn>
static void doSPECIAL( char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_special = 1;
        o->is_simple = 0;
    }
    p = skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <fn> in :special. tag\n" );
    }
    p = copyNonSpaceUntil( p, tokbuff, '\0' );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->special = strdup( tokbuff );
    }
    p = skipSpace( p );
    if( *p != '\0' ) {
        p = copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->special_arg_usage = strdup( tokbuff );
        }
    }
}

// :prefix.
static void doPREFIX( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_prefix = 1;
        o->is_simple = 0;
    }
}

// :usage. <usage-text>
static void doUSAGE( char *p )
{
    OPTION *o;

    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->lang_usage[LANG_English] = pickUpRest( p );
    }
}

// :jusage. <kanji-usage-text>
static void doJUSAGE( char *p )
{
    char *usage;
    OPTION *o;

    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    switch( getsUsage ) {
    case TAG_PAGE:
        pageUsage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_CHAIN:
        lastChain->Usage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_OPTION:
        for( o = optionList; o != NULL; o = o->synonym ) {
            usage = pickUpRest( p );
            if( *usage == '\0' ) {
                usage = strdup( o->lang_usage[LANG_English] );
            }
            o->lang_usage[LANG_Japanese] = usage;
        }
        break;
    default:
        fail( ":jusage. must follow :chain., :option., or :page.\n" );
    }
}

// :title. <text>
static void doTITLE( char *p )
{
    TITLE **i;
    TITLE *t;

    i = &titleList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( sizeof( *t ), 1 );
    t->next = *i;
    *i = t;
    t->target = 0;
    t->ntarget = 0;
    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    t->lang_title[LANG_English] = pickUpRest( p );
    targetTitle = t;
}

// :jtitle. <text>
static void doJTITLE( char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":jtitle. must follow a :title.\n" );
    }
    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    t->lang_title[LANG_Japanese] = pickUpRest( p );
}

// :timestamp.
static void doTIMESTAMP( char *p )
{
    OPTION *o;

    p = p;
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_timestamp = 1;
        o->is_simple = 0;
        if( o->enumerate != NULL ) {
            o->enumerate->is_timestamp = 1;
        }
    }
}

// :usagegrp. <option> <usage>
//
// mark options that start with <option> as group in usage text
// i.e., -fp0 -fp1 ==> -fp{0,1}
static void doUSAGEGRP( char *p )
{
    CHAIN *cn;

    p = skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <option> in :usagegrp. tag\n" );
    }
    p = copyNonSpaceUntil( p, tokbuff, '\0' );
    cn = addChain( tokbuff, FALSE );
    p = skipSpace( p );
    // skip leading ':' character used to specify spaces on the beginning
    SKIP_BEG_MARK( p );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

static void checkForGMLEscape( char *p )
{
    bool is_escape;
    char c1, c2;

    c1 = *p++;
    if( c1 == '\0' || ! isalpha( c1 ) ) {
        return;
    }
    c2 = *p++;
    if( c2 == '\0' || ! isalpha( c2 ) ) {
        return;
    }
    is_escape = FALSE;
    if( *p == '\0' || ! isalpha( *p ) ) {
        is_escape = TRUE;
    }
    if( is_escape ) {
        fail( "possible GML escape sequence: &%c%c\n", c1, c2 );
    }
}

static void checkForGMLEscapeSequences( void )
{
    char c;
    char *p;

    for( p = ibuff; (c = *p++) != '\0'; ) {
        if( c == '&' ) {
            checkForGMLEscape( p );
        }
    }
}

static void readInputFile( void )
{
    char *eot;
    tag_id tag;

    for( ; fgets( ibuff, sizeof(ibuff), gfp ) != NULL; ) {
        ++line;
        checkForGMLEscapeSequences();
        tag = isTag( &eot );
        if( tag != TAG_NULL ) {
            eot = skipSpace( eot );
            (*processTag[tag])( eot );
        }
    }
}

static void checkForMissingUsages( void )
{
    OPTION *o;
    int start_lang;
    int end_lang;
    int i;

    if( optFlag.international ) {
        start_lang = LANG_MIN;
        end_lang = LANG_MAX;
    } else {
        start_lang = LANG_English;
        end_lang = start_lang + 1;
    }
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NULL || cmpOptName( o->name, o->chain->name ) ) {
            for( i = start_lang; i < end_lang; ++i ) {
                if( o->lang_usage[i] == NULL ) {
                    fail( "option '%s' has no %s usage\n", o->name, langName[i] );
                }
            }
        }
    }
}

static void assignChainToOptions( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NOCHAIN ) {
            o->chain = NULL;
        } else {
            o->chain = findChain( o->name );
        }
    }
}

static void stripUselessOptions( void )
{
    OPTION **h;
    OPTION *o;
    OPTION *o_next;

    h = &optionList;
    for( o = *h; o != NULL; o = o_next ) {
        o_next = o->next;
        if( (o->ntarget & targetMask) || (o->target & targetMask) == 0 ) {
            o->next = uselessOptionList;
            uselessOptionList = o;
            *h = o_next;
        } else {
            h = &(o->next);
        }
    }
}

static char *strpcpy( char *d, char *s )
{
    size_t len;

    len = strlen( s );
    strcpy( d, s );
    return( d + len );
}

static char *special_char( char *f, char c )
{
    if( c == '~' ) {
        f = strpcpy( f, "_tilde" );
    } else if( c == '+' ) {
        f = strpcpy( f, "_plus" );
    } else if( c == '!' ) {
        f = strpcpy( f, "_exclamation" );
    } else if( c == '#' ) {
        f = strpcpy( f, "_sharp" );
    } else {
        *f++ = '_';
    }
    return( f );
}

static void makeFieldName( char *n, char *f )
{
    char c;
    bool sensitive;
    bool special;

    c = *n++;
    if( c == '\\' ) {
        c = *n++;
    } else {
        c = mytolower( c );
    }
    if( c != '\0' ) {
        special = FALSE;
        if( isalnum( c ) ) {
            if( isdigit( c ) )
                *f++ = '_';
            *f++ = c;
        } else {
            f = special_char( f, c );
            special = TRUE;
        }
        sensitive = FALSE;
        for( ; (c = *n++) != '\0'; ) {
            if( c == '\\' ) {
                sensitive = TRUE;
                continue;
            } else if( isalnum( c ) ) {
                if( special && *(f - 1) != '_' )
                    *f++ = '_';
                if( !sensitive )
                    c = mytolower( c );
                *f++ = c;
                special = FALSE;
            } else {
                f = special_char( f, c );
                special = TRUE;
            }
            sensitive = FALSE;
        }
    }
    *f = '\0';
}

static void startParserH( void )
{
    OPTION *o;
    NAME *e;

    if( ofp == NULL ) {
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                makeFieldName( o->name, tokbuff );
                if( o->field_name == NULL ) {
                    o->field_name = strdup( tokbuff );
                }
                strcat( tokbuff, "_value" );
                o->value_field_name = strdup( tokbuff );
            }
        }
    } else {
        fprintf( ofp, "typedef struct opt_string OPT_STRING;\n" );
        fprintf( ofp, "struct opt_string {\n" );
        fprintf( ofp, "    OPT_STRING *next;\n" );
        fprintf( ofp, "    char data[1];\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_number OPT_NUMBER;\n" );
        fprintf( ofp, "struct opt_number {\n" );
        fprintf( ofp, "    OPT_NUMBER *next;\n" );
        fprintf( ofp, "    unsigned number;\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_storage OPT_STORAGE;\n" );
        fprintf( ofp, "struct opt_storage {\n" );
        fprintf( ofp, "    unsigned     timestamp;\n" );
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                makeFieldName( o->name, tokbuff );
                if( o->field_name == NULL ) {
                    o->field_name = strdup( tokbuff );
                }
                strcat( tokbuff, "_value" );
                o->value_field_name = strdup( tokbuff );
                if( o->is_number ) {
                    if( HAS_OPT_NUMBER( o ) ) {
                        fprintf( ofp, "    OPT_NUMBER   *%s;\n", tokbuff );
                    } else {
                        fprintf( ofp, "    unsigned     %s;\n", tokbuff );
                    }
                } else if( o->is_char ) {
                    fprintf( ofp, "    int          %s;\n", tokbuff );
                } else if( HAS_OPT_STRING( o ) ) {
                    fprintf( ofp, "    OPT_STRING   *%s;\n", tokbuff );
                }
                if( o->is_timestamp ) {
                    if( o->enumerate == NULL ) {
                        makeFieldName( o->name, tokbuff );
                        fprintf( ofp, "    unsigned     %s_timestamp;\n", tokbuff );
                    }
                }
            }
        }
        for( e = enumList; e != NULL; e = e->next ) {
            fprintf( ofp, "    unsigned     %s;\n", e->name );
            if( e->is_timestamp ) {
                fprintf( ofp, "    unsigned     %s_timestamp;\n", e->name );
            }
        }
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                makeFieldName( o->name, tokbuff );
                if( o->enumerate == NULL ) {
                    fprintf( ofp, "    unsigned     %s : 1;\n", tokbuff );
                }
            }
        }
        fprintf( ofp, "};\n" );
    }
}

static void finishParserH( void )
{
    NAME *e;
    unsigned value;

    if( ofp != NULL ) {
        value = 0;
        for( e = enumeratorList; e != NULL; e= e->next ) {
            ++value;
            fprintf( ofp, "#define %s %u\n", e->name, value );
        }
    }
}

static CODESEQ *newCode( OPTION *o, char c, unsigned sensitive )
{
    CODESEQ *p;

    p = calloc( 1, sizeof( *p ) );
    p->option = o;
    p->c = c;
    if( sensitive ) {
        p->sensitive = 1;
    }
    return( p );
}

static CODESEQ *addOptionCodeSeq( CODESEQ *code, OPTION *o )
{
    unsigned sensitive;
    char *n;
    char c;
    CODESEQ *head;
    CODESEQ **splice;

    head = code;
    splice = &head;
    for( n = o->name; (c = *n++) != '\0'; ) {
        sensitive = 0;
        if( c == '\\' ) {
            c = *n++;
            sensitive = 1;
        } else {
            c = mytolower( c );
        }
        for( code = *splice; code != NULL; code = *splice ) {
            if( code->sensitive == sensitive ) {
                if( code->c == c ) {
                    break;
                }
            }
            splice = &(code->sibling);
        }
        if( code == NULL ) {
            code = newCode( o, c, sensitive );
            *splice = code;
        }
        splice = &(code->children);
    }
    if( code == NULL ) {
        code = newCode( o, '\0', 0 );
        *splice = code;
    }
    code->accept = 1;
    code->option = o;
    return( head );
}

static CODESEQ *reorderCode( CODESEQ *c )
{
    CODESEQ *a;
    CODESEQ *h;
    CODESEQ *n;
    CODESEQ **s;

    h = c;
    if( c->sibling != NULL ) {
        a = NULL;
        s = &h;
        // accepting states move to the end
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->accept ) {
                *s = n;
                c->sibling = a;
                a = c;
            } else {
                s = &(c->sibling);
            }
        }
        *s = a;
        s = &(h->sibling);
        // sensitive states move to the front
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->sensitive ) {
                *s = n;
                c->sibling = h;
                h = c;
            } else {
                s = &(c->sibling);
            }
        }
    }
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->children != NULL ) {
            c->children = reorderCode( c->children );
        }
    }
    return( h );
}

static bool markChainCode( CODESEQ *h, size_t level )
{
    CODESEQ *c;
    bool    rc;

    rc = FALSE;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            if( c->children != NULL ) {
                if( level == c->option->chain->clen ) {
                    if( markChainCode( c->children, level + 1 ) ) {
                        c->chain_root = 1;
                    }
                }
            } else if( c->option->slen == c->option->chain->clen + 1 ) {
                c->chain = 1;
                rc = TRUE;
            }
        }
    }
    return( rc );
}

static CODESEQ *genCode( OPTION *o )
{
    CODESEQ *head;

    head = NULL;
    for( ; o != NULL; o = o->next ) {
        head = addOptionCodeSeq( head, o );
    }
    head = reorderCode( head );
    markChainCode( head, 1 );
    return( head );
}

static bool useSwitchStmt( CODESEQ *h )
{
    unsigned count;
    CODESEQ *c;

    count = 0;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->is_prefix ) {
            return( TRUE );
        }
        ++count;
    }
    return( count >= USE_SWITCH_THRESHOLD );
}

static void emitSuccessCode( unsigned depth, flow_control control )
{
    if( control & EC_CONTINUE ) {
        emitPrintf( depth, "continue;\n" );
    } else {
        emitPrintf( depth, "return( FALSE );\n" );
    }
}

static void emitAcceptCode( CODESEQ *c, unsigned depth, flow_control control )
{
    NAME *e;
    OPTION *o;
    struct {
        unsigned close_value_if : 1;
    } flag;

    o = c->option;
    while( o->synonym != NULL ) {
        o = o->synonym;
    }
    if( o->is_prefix ) {
        emitPrintf( depth, "if( " FN_END "() ) {\n" );
        ++depth;
    }
    flag.close_value_if = 0;
    if( o->is_number ) {
        if( o->default_specified ) {
            emitPrintf( depth, "if( " FN_NUMBER_DEFAULT "( &(data->%s ), %u ) ) {\n", o->value_field_name, o->number_default );
        } else if( o->is_multiple ) {
            emitPrintf( depth, "if( " FN_NUMBER_MULTIPLE "( &(data->%s ) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_NUMBER "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = 1;
    } else if( o->is_char ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_CHAR_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_CHAR "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = 1;
    } else if( o->is_id ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_ID_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_ID "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = 1;
    } else if( o->is_file ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_FILE_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_FILE "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = 1;
    } else if( o->is_path ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_PATH_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_PATH "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = 1;
    } else if( o->is_special ) {
        emitPrintf( depth, "if( %s( &(data->%s) ) ) {\n", o->special, o->value_field_name );
        ++depth;
        flag.close_value_if = 1;
    }
    if( o->check != NULL ) {
        emitPrintf( depth, "%s( &(data->%s) );\n", o->check, o->value_field_name );
    }
    if( o->enumerate != NULL ) {
        e = addEnumerator( o->enumerate->name, o->field_name );
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->enumerate->name );
        }
        emitPrintf( depth, "data->%s = %s;\n", o->enumerate->name, e->name );
        if( o->is_immediate ) {
            emitPrintf( depth, "%s( data, TRUE );\n", o->immediate );
        }
    } else {
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->field_name );
        }
        if( o->is_negate ) {
            emitPrintf( depth, "if( %s( '-' ) ) {\n", FN_RECOG );
            emitPrintf( depth+1, "data->%s = FALSE;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, FALSE );\n", o->immediate );
            }
            emitPrintf( depth, "}else{\n" );
            emitPrintf( depth+1, "data->%s = TRUE;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, TRUE );\n", o->immediate );
            }
            emitPrintf( depth, "}\n" );
        } else {
            emitPrintf( depth, "data->%s = TRUE;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth, "%s( data, TRUE );\n", o->immediate );
            }
        }
    }
    if( o->is_code ) {
        emitPrintf( depth, "%s;\n", o->code );
    }
    if( flag.close_value_if ) {
        --depth;
        emitPrintf( depth, "}\n" );
    }
    emitSuccessCode( depth, control );
    if( o->is_prefix ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, "break;\n" );
    }
}

static void emitCodeTree( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->children ) {
        if( c->chain ) {
            emitCode( c->children, depth, ( control & ~EC_CHAIN ) | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitPrintf( depth, "return( TRUE );\n" );
            }
        } else if( c->chain_root ) {
            emitCode( c->children, depth, control | EC_CHAIN | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitSuccessCode( depth, control );
            }
        } else {
            emitCode( c->children, depth, control & ~EC_CHAIN );
            if( c->accept ) {
                emitAcceptCode( c, depth, control );
            } else {
                emitPrintf( depth, "return( TRUE );\n" );
            }
        }
    } else {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            emitAcceptCode( c, depth, control );
        } else {
            emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
        }
    }
}

static void emitIfCode( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->sensitive ) {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG, c->c );
    } else {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG_LOWER, c->c );
    }
    emitCodeTree( c, depth + 1, control );
    emitPrintf( depth, "}\n" );
}

static void emitCode( CODESEQ *h, unsigned depth, flow_control control )
{
    bool use_switch;
    CODESEQ *c;

    for( c = h; c != NULL; c = c->sibling ) {
        if( c->sensitive || (control & EC_CHAIN) && !c->chain ) {
            emitIfCode( c, depth, control );
        } else {
            break;
        }
    }
    if( c == NULL ) {
        return;
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "do {\n" );
        ++depth;
    }
    use_switch = useSwitchStmt( c );
    if( use_switch ) {
        emitPrintf( depth, "switch( " FN_GET_LOWER "() ) {\n" );
        ++depth;
    }
    for( ; c != NULL; c = c->sibling ) {
        if( use_switch ) {
            emitPrintf( depth - 1, "case '%c':\n", c->c );
            emitCodeTree( c, depth, control );
        } else {
            emitIfCode( c, depth, control );
        }
    }
    if( use_switch ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, FN_UNGET "();\n" );
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "break;\n" );
        --depth;
        emitPrintf( depth, "} while( ! " FN_END "() );\n" );
    }
}

static void outputFN_PROCESS( void )
{
    unsigned depth = 0;
    CODESEQ *codeseq;

    emitPrintf( depth, "bool " FN_PROCESS "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    codeseq = genCode( optionList );
    emitCode( codeseq, depth, EC_NULL );
    emitPrintf( depth, "return( TRUE );\n" );
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_INIT( void )
{
    OPTION *o;
    NAME *e;
    NAME *en;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_INIT "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    emitPrintf( depth, "memset( data, 0, sizeof( *data ) );\n" );
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL && o->is_number && o->default_specified ) {
            emitPrintf( depth, "data->%s = %u;\n", o->value_field_name, o->number_default );
        }
    }
    for( e = enumList; e != NULL; e = e->next ) {
        en = addEnumerator( e->name, "default" );
        emitPrintf( depth, "data->%s = %s;\n", e->name, en->name );
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_FINI( void )
{
    OPTION *o;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_FINI "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( HAS_OPT_STRING( o ) ) {
                emitPrintf( depth, FN_CLEAN_STRING "( &(data->%s) );\n", o->value_field_name );
            } else if( HAS_OPT_NUMBER( o ) ) {
                emitPrintf( depth, FN_CLEAN_NUMBER "( &(data->%s) );\n", o->value_field_name );
            }
        }
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static int usageCmp( const void *v1, const void *v2 )
{
    int     res;
    size_t  clen;
    OPTION  *o1 = *(OPTION **)v1;
    OPTION  *o2 = *(OPTION **)v2;
    char    *n1 = o1->sname;
    char    *n2 = o2->sname;

    res = 0;
    if( o1->chain != o2->chain ) {
        if( o1->chain == NULL ) {
            clen = o2->chain->clen;
        } else if( o2->chain == NULL ) {
            clen = o1->chain->clen;
        } else if( o1->chain->clen > o2->chain->clen ) {
            clen = o1->chain->clen;
        } else {
            clen = o2->chain->clen;
        }
        res = strnicmp( n1, n2, clen );
        if( res == 0 ) {
            res = strncmp( n1, n2, clen );
            if( res == 0 ) {
                if( o1->chain == NULL ) {
                    return( 1 );
                }
                if( o2->chain == NULL ) {
                    return( -1 );
                }
                n1 += clen;
                n2 += clen;
            }
        }
    }
    if( res == 0 ) {
        res = stricmp( n1, n2 );
        if( res == 0 ) {
            return( strcmp( n1, n2 ) );
        }
    }
    if( res < 0 ) {
        return( -1 );
    } else {
        return( 1 );
    }
}

static void catArg( char *arg )
{
    char *p;
    size_t len;

    len = strlen( tokbuff );
    p = &tokbuff[len];
    for( ; *arg != '\0'; ++arg ) {
        if( optFlag.no_equal ) {
            if( *arg != '=' ) {
                *p++ = *arg;
            }
        } else if( optFlag.alternate_equal ) {
            if( *arg != '=' ) {
                *p++ = *arg;
            } else {
                *p++ = alternateEqual;
            }
        } else {
            *p++ = *arg;
        }
    }
    *p = '\0';
}

static size_t genOptionUsageStart( OPTION *o )
{
    size_t  len;

    if( o->chain != NULL ) {
        tokbuff[0] = ' ';
        tokbuff[1] = ' ';
        tokbuff[2] = '\0';
        strcat( tokbuff, o->sname + o->chain->clen );
    } else {
        strcpy( tokbuff, "-" );
        cvtName( tokbuff + 1, o->name, CVT_USAGE );
    }
    if( o->is_number ) {
        if( o->default_specified ) {
            catArg( "[=<num>]" );
        } else {
            catArg( "=<num>" );
        }
    } else if( o->is_char ) {
        if( o->is_optional ) {
            catArg( "[=<char>]" );
        } else {
            catArg( "=<char>" );
        }
    } else if( o->is_id ) {
        if( o->is_optional ) {
            catArg( "[=<id>]" );
        } else {
            catArg( "=<id>" );
        }
    } else if( o->is_file ) {
        if( o->is_optional ) {
            catArg( "[=<file>]" );
        } else {
            catArg( "=<file>" );
        }
    } else if( o->is_path ) {
        if( o->is_optional ) {
            catArg( "[=<path>]" );
        } else {
            catArg( "=<path>" );
        }
    } else if( o->is_negate ) {
        catArg( "[-]" );
    } else if( o->is_special ) {
        if( o->special_arg_usage != NULL ) {
            // we don't want special processing done
            strcat( tokbuff, o->special_arg_usage );
        }
    }
    len = strlen( tokbuff );
    return( len );
}

static void fillOutSpaces( char *buff, size_t n )
{
    char *p;

    p = &buff[strlen( buff )];
    while( n > 0 ) {
        *p++ = ' ';
        --n;
    }
    *p = '\0';
}

static bool usageValid( OPTION *o, unsigned language )
{
    if( o->synonym != NULL )
        return( FALSE );
    if( o->lang_usage[language] == NULL )
        return( FALSE );
    if( o->lang_usage[language][0] == '\0' )
        return( FALSE );
    if( o->is_internal && ( targetMask & targetDbgMask ) == 0 ) {
        return( FALSE );
    }
    return( TRUE );
}

static void emitUsageH( bool page_flag )
{
    size_t len;
    char *q;
    char *s;

    len = strlen( tokbuff );
    if( len > maxUsageLen ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, tokbuff );
    }
    if( mfp != NULL && !page_flag ) {
        fprintf( mfp, "%s\n", tokbuff );
    }
    if( ufp != NULL ) {
        fprintf( ufp, "\"" );
        for( s = tokbuff; (q = strchr( s, '"' )) != NULL; s = q + 1 ) {
            // replace " with \"
            *q = '\0';
            fprintf( ufp, "%s\\\"", s );
        }
        fprintf( ufp, "%s%s\"\n", s, ( optFlag.zero_term ) ? "\\0" : "" );
    }
    
}

static void createChainHeader( OPTION **o, unsigned language, size_t max )
{
    char    *usage;
    CHAIN   *cn;
    size_t  len;

    cn = (*o)->chain;
    hdrbuff[0] = '-';
    cvtName( hdrbuff + 1, cn->name, CVT_STRING );
    strcat( hdrbuff, "{" );
    len = 0;
    for( ; *o != NULL && (*o)->chain == cn; ++o ) {
        if( (*o)->chain != NULL ) {
            if( len > 0 ) {
                strcat( hdrbuff, "," );
            }
            genOptionUsageStart( *o );
            strcat( hdrbuff, &tokbuff[2] );
            ++len;
        }
    }
    strcat( hdrbuff, "} " );
    len = strlen( hdrbuff );
    if( max > len )
        fillOutSpaces( hdrbuff, max - len );
    usage = cn->Usage[language];
    if( usage == NULL || *usage == '\0' ) {
        usage = cn->Usage[LANG_English];
    }
    strcat( hdrbuff, usage );
    strcpy( tokbuff, hdrbuff );
}

static void createUsageHeader( unsigned language, void (*process_line)( bool ) )
{
    char *s;
    char *d;
    char *title;
    TITLE *t;

    for( t = titleList; t != NULL; t = t->next ) {
        if( (t->target & targetMask) && (t->ntarget & targetMask) == 0 ) {
            title = t->lang_title[language];
            if( title == NULL || *title == '\0' ) {
                title = t->lang_title[LANG_English];
            }
            d = tokbuff;
            for( s = title; *s != '\0'; ++s ) {
                if( s[0] == '\\' && s[1] == 't' ) {
                    ++s;
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                    *d++ = ' ';
                } else {
                    *d++ = *s;
                }
            }
            *d = '\0';
            process_line( FALSE );
        }
    }
}

static void clearChainUsage( void )
{
    CHAIN   *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        cn->usage_used = 0;
    }
}

static void processUsage( unsigned language, void (*process_line)( bool ) )
{
    unsigned count;
    unsigned i;
    size_t max;
    size_t len;
    OPTION *o;
    OPTION **t;
    OPTION **c;
    char *page;

    maxUsageLen = 0;
    max = 0;
    count = 0;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, language ) ) {
            ++count;
            len = genOptionUsageStart( o );
            if( len > max ) {
                max = len;
            }
        }
    }
    ++max;
    t = calloc( count + 1, sizeof( OPTION * ) );
    c = t;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, language ) ) {
            *c++ = o;
        }
    }
    *c = NULL;
    qsort( t, count, sizeof( OPTION * ), usageCmp );
    page = pageUsage[language];
    if( page == NULL || *page == '\0' ) {
        page = pageUsage[LANG_English];
    }
    if( page != NULL && *page != '\0' ) {
        strcpy( tokbuff, page );
        process_line( TRUE );
    }
    createUsageHeader( language, process_line );
    clearChainUsage();
    for( i = 0; i < count; ++i ) {
        o = t[i];
        if( o->chain != NULL && !o->chain->usage_used ) {
            o->chain->usage_used = 1;
            createChainHeader( &t[i], language, max );
            process_line( FALSE );
        }
        tokbuff[0] = '\0';
        len = genOptionUsageStart( o );
        if( max > len )
            fillOutSpaces( tokbuff, max - len );
        if( o->chain != NULL ) {
            strcat( tokbuff, "- " );
        }
        strcat( tokbuff, o->lang_usage[language] );
        process_line( FALSE );
    }
    if( ( maxUsageLen / langMaxChar[language] ) > CONSOLE_WIDTH ) {
        fail( "usage message exceeds %u chars\n%s\n", CONSOLE_WIDTH, maxusgbuff );
    }
}

static void outputUsageH( void )
{
    processUsage( optFlag.lang, emitUsageH );
}

static void emitUsageB( bool page_flag )
{
    size_t len;

    page_flag = page_flag;
    len = strlen( tokbuff ) + 1;
    fwrite( tokbuff, len, 1, bfp );
    if( len > maxUsageLen ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, tokbuff );
    }
}

static void dumpInternational( void )
{
    unsigned lang;
    auto char fname[16];
    auto LocaleUsage usage_header;

    for( lang = LANG_FIRST_INTERNATIONAL; lang < LANG_MAX; ++lang ) {
        sprintf( fname, "usage%02u." LOCALE_DATA_EXT, lang );
        bfp = fopen( fname, "wb" );
        if( bfp == NULL ) {
            fail( "cannot open international file for write\n" );
        }
        memset( &usage_header, 0, sizeof( usage_header ) );
        usage_header.header.code = LS_Usage;
        usage_header.header.signature = LS_Usage_SIG;
        fwrite( &usage_header, offsetof( LocaleUsage, data ), 1, bfp );
        processUsage( lang, emitUsageB );
        fputc( 0, bfp );
        fclose( bfp );
        bfp = NULL;
    }
}

static void closeFiles( void )
{
    fclose( gfp );
    if( mfp != NULL )
        fclose( mfp );
    if( ofp != NULL )
        fclose( ofp );
    if( pfp != NULL )
        fclose( pfp );
    if( ufp != NULL ) {
        fclose( ufp );
    }
}

int main( int argc, char **argv )
{
    int defs_ok = _LANG_DEFS_OK();

    if( ! defs_ok ) {
        fail( "language index mismatch\n" );
    }
    procCmdLine( argc, argv );
    readInputFile();
    assignChainToOptions();
    checkForMissingUsages();
    stripUselessOptions();
    startParserH();
    outputFN_PROCESS();
    outputFN_INIT();
    outputFN_FINI();
    finishParserH();
    outputUsageH();
    if( optFlag.international ) {
        dumpInternational();
    }
    closeFiles();
    return( EXIT_SUCCESS );
}
