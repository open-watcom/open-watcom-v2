/****************************************************************************
*
*                            Open Watcom Project
*
* Copyright (c) 2002-2024 The Open Watcom Contributors. All Rights Reserved.
*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
*
*  ========================================================================
*
*    This file contains Original Code and/or Modifications of Original
*    Code as defined in and that are subject to the Sybase Open Watcom
*    Public License version 1.0 (the 'License'). You may not use this file
*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
*    provided with the Original Code and Modifications, and is also
*    available at www.sybase.com/developer/opensource.
*
*    The Original Code and all software distributed under the License are
*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
*    NON-INFRINGEMENT. Please see the License for the specific language
*    governing rights and limitations under the License.
*
*  ========================================================================
*
* Description:  Generate scaffolding for autogenerated option parsing.
*
****************************************************************************/


#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include <limits.h>
#include "bool.h"
#include "lsspec.h"
#include "wreslang.h"
#include "cvttable.h"

#include "clibext.h"


/* following must be ordered as US ASCII */
#define OPT_TAGS \
TAG( ARGEQUAL ) \
TAG( CHAIN ) \
TAG( CHAR ) \
TAG( CMT ) \
TAG( CODE ) \
TAG( ENUMERATE ) \
TAG( FILE ) \
TAG( FOOTER ) \
TAG( FOOTERU ) \
TAG( GROUP ) \
TAG( ID ) \
TAG( IMMEDIATE ) \
TAG( INTERNAL ) \
TAG( JFOOTER ) \
TAG( JFOOTERU ) \
TAG( JTITLE ) \
TAG( JTITLEU ) \
TAG( JUSAGE ) \
TAG( MULTIPLE ) \
TAG( NEGATE ) \
TAG( NOCHAIN ) \
TAG( NOEQUAL ) \
TAG( NTARGET ) \
TAG( NUMBER ) \
TAG( OPTION ) \
TAG( OPTIONAL ) \
TAG( PATH ) \
TAG( PREFIX ) \
TAG( SPECIAL ) \
TAG( TARGET ) \
TAG( TIMESTAMP ) \
TAG( TITLE ) \
TAG( TITLEU ) \
TAG( USAGE ) \
TAG( USAGECHAIN ) \
TAG( USAGEGROUP ) \
TAG( USAGENOCHAIN )

/*
 *******************************************
 * TAG        * sub-TAG
 *******************************************
 * ARGEQUAL
 * CHAIN
 * NOEQUAL
 *
 * FOOTER       FOOTERU, JFOOTER, JFOOTERU
 * TITLE        TITLEU, JTITLE, JTITLEU
 *
 * OPTION
 * USAGECHAIN
 * USAGEGROUP
 *              JUSAGE, USAGE
 *
 *******************************************
 * OPTION attributes sub-TAG
 *******************************************
 * CHAR
 * CMT
 * CODE
 * ENUMERATE
 * FILE
 * GROUP
 * ID
 * IMMEDIATE
 * INTERNAL
 * MULTIPLE
 * NEGATE
 * NOCHAIN
 * NTARGET
 * NUMBER
 * OPTIONAL
 * PATH
 * PREFIX
 * SPECIAL
 * TARGET
 * TIMESTAMP
 * USAGENOCHAIN
 *******************************************
 */

#define NEXT_ARG() \
        --argc1; ++argv1

#define NEXT_ARG_CHECK() \
        --argc1; ++argv1; if( argc1 < NUM_FILES ) { return( true ); }

#define BLANKARG( s )       (s[0] == '.' && s[1] == '\0')

// functions that are supplied by the host environment
#define FN_UNGET            "OPT_UNGET"                 // void ( void )
#define FN_GET_LOWER        "OPT_GET_LOWER"             // int ( void )
#define FN_RECOG            "OPT_RECOG"                 // bool ( int )
#define FN_RECOG_LOWER      "OPT_RECOG_LOWER"           // bool ( int )
#define FN_RERECOG          "OPT_RERECOG"               // bool ( int )
#define FN_END              "OPT_END"                   // bool ( void )

#define FN_NUMBER           "OPT_GET_NUMBER"            // bool ( unsigned * )
#define FN_NUMBER_DEFAULT   "OPT_GET_NUMBER_DEFAULT"    // bool ( unsigned *, unsigned )
#define FN_NUMBER_MULTIPLE  "OPT_GET_NUMBER_MULTIPLE"   // bool ( OPT_NUMBER ** )
#define FN_CHAR             "OPT_GET_CHAR"              // bool ( int * )
#define FN_CHAR_OPT         "OPT_GET_CHAR_OPT"          // bool ( int * )
#define FN_ID               "OPT_GET_ID"                // bool ( OPT_STRING ** )
#define FN_ID_OPT           "OPT_GET_ID_OPT"            // bool ( OPT_STRING ** )
#define FN_FILE             "OPT_GET_FILE"              // bool ( OPT_STRING ** )
#define FN_FILE_OPT         "OPT_GET_FILE_OPT"          // bool ( OPT_STRING ** )
#define FN_PATH             "OPT_GET_PATH"              // bool ( OPT_STRING ** )
#define FN_PATH_OPT         "OPT_GET_PATH_OPT"          // bool ( OPT_STRING ** )

#define FN_CLEAN_STRING     "OPT_CLEAN_STRING"          // void ( OPT_STRING ** )
#define FN_CLEAN_NUMBER     "OPT_CLEAN_NUMBER"          // void ( OPT_NUMBER ** )

#define FN_PROCESS          "OPT_PROCESS"               // bool ( OPT_STORAGE * )
#define FN_INIT             "OPT_INIT"                  // void ( OPT_STORAGE * )
#define FN_FINI             "OPT_FINI"                  // void ( OPT_STORAGE * )

#define USE_SWITCH_THRESHOLD    (4)
#define CONSOLE_WIDTH           (79)

#define BUFF_SIZE               1024

#define HAS_OPT_STRING(o)       ((o)->is_id || (o)->is_file || (o)->is_path || (o)->is_text)
#define HAS_OPT_NUMBER(o)       ((o)->is_number && (o)->is_multiple)

#define NOSENSITIVE             ' '

#define IS_SENSITIVE(c)         ((c)->s != NOSENSITIVE)

#define mytolower(c)            ((c < 'A' || c > 'Z') ? c : c - 'A' + 'a')
#define mytoupper(c)            ((c < 'a' || c > 'z') ? c : c - 'a' + 'A')
#define myisalpha(c)            ((c >= 'a' || c <= 'z') || (c >= 'A' || c <= 'Z'))
#define myisspace(c)            (c == ' ' || c == '\t')

#define IS_SELECTED(s)          ((s->target_mask & targetMask) && (s->ntarget_mask & targetMask) == 0)

#define IS_ASCII(c)             (c < 0x80)

#define GET_OUTPUT_BUF(l)       (outputbuff + l * BUFF_SIZE)

#define SKIP_SPACES(s)          while( myisspace( *s ) ) s++

typedef const char              *lang_data[LANG_RLE_MAX];

typedef unsigned long           targmask;

typedef int (*comp_fn)(const void *,const void *);

typedef void process_line_fn( void );

typedef enum tag_id {
    #define TAG( s )        TAG_##s ,
    OPT_TAGS
    #undef TAG
    TAG_UNKNOWN,
    TAG_NULL
} tag_id;

typedef enum flow_control {
    EC_NULL             = 0,
    EC_CONTINUE         = 0x01,
    EC_CHAIN            = 0x02,
    EC_SWITCH           = 0x04
} flow_control;

typedef enum cvt_name {
    CVT_NAME,
    CVT_PATTERN,
    CVT_USAGE
} cvt_name;

typedef struct target {
    targmask        mask;
    const char      *name;
} TARGET;

typedef struct iname {
    struct iname    *next;
    char            name[1];
} INAME;

typedef struct ename {
    struct ename    *next;
    INAME           *items;
    boolbit         is_timestamp : 1;
    boolbit         used         : 1;
    char            name[1];
} ENAME;

typedef struct text {
    struct text     *next;
    targmask        target_mask;
    targmask        ntarget_mask;
    boolbit         any_target  : 1;
    boolbit         is_u        : 1;
    lang_data       lang_usage;
    lang_data       lang_usageu;
} TEXT;

typedef struct chain {
    struct chain    *next;
    size_t          len;
    size_t          pattern_len;
    char            pattern[1];
} CHAIN;

typedef struct usagechain {
    struct usagechain *next;
    lang_data       lang_usage;
    size_t          len;
    size_t          pattern_len;
    char            pattern[1];
} USAGECHAIN;

typedef struct usagegroup {
    struct usagegroup *next;
    lang_data       lang_usage;
    USAGECHAIN      *usageChainList;
    char            id[1];
} USAGEGROUP;


typedef struct option {
    struct option   *next;
    struct option   *synonym;
    lang_data       lang_usage;
    char            *check_func;
    char            *special_func;
    char            *immediate_func;
    char            *usage_argid;
    char            *field_name;
    char            *value_field_name;
    ENAME           *enumerate;
    char            *code;
    unsigned        number_default;
    targmask        target_mask;
    targmask        ntarget_mask;
    boolbit         default_specified : 1;
    boolbit         any_target        : 1;
    boolbit         usage_used        : 1;
    boolbit         nochain           : 1;
    boolbit         usage_nochain     : 1;
    boolbit         is_simple         : 1;
    boolbit         is_immediate      : 1;
    boolbit         is_code           : 1;
    boolbit         is_internal       : 1;
    boolbit         is_multiple       : 1;
    boolbit         is_number         : 1;
    boolbit         is_id             : 1;
    boolbit         is_char           : 1;
    boolbit         is_file           : 1;
    boolbit         is_text           : 1;
    boolbit         is_optional       : 1;
    boolbit         is_path           : 1;
    boolbit         is_special        : 1;
    boolbit         is_prefix         : 1;
    boolbit         is_timestamp      : 1;
    boolbit         is_negate         : 1;
    char            equal_char;
    CHAIN           *chain;
    USAGECHAIN      *usageChain;
    USAGEGROUP      *usageGroup;
    size_t          name_len;
    char            *name;
    char            pattern[1];
} OPTION;

typedef struct codeseq {
    struct codeseq  *sibling;
    struct codeseq  *children;
    OPTION          *option;
    char            c;
    char            s;
    boolbit         accept        : 1;
    boolbit         is_chain      : 1;
    boolbit         is_chain_root : 1;
    boolbit         sel           : 1;
} CODESEQ;

static unsigned     line;
static unsigned     errcount = 0;

static FILE         *gfp = NULL;
static FILE         *ofp = NULL;
static FILE         *pfp = NULL;
static FILE         *ufp = NULL;
static FILE         *mfp = NULL;
static FILE         *bfp = NULL;
static FILE         *ofpg = NULL;

static char         ibuff[BUFF_SIZE];
static char         tagbuff[BUFF_SIZE];
static char         tokbuff[BUFF_SIZE];
static char         tmpbuff[BUFF_SIZE];
static char         hdrbuff[BUFF_SIZE];
static char         maxusgbuff[BUFF_SIZE];

static char         alternateEqual;
static size_t       maxUsageLen;
static targmask     targetMask = 0;
static targmask     targetAnyMask;
static targmask     targetDbgMask;
static targmask     targetUnusedMask;

static tag_id       getsUsage = TAG_NULL;

static char         *outputbuff = NULL;
static lang_data    outputdata;

static int          fno = 0;

#define TAGS_COUNT  (sizeof( tagNames ) / sizeof( tagNames[0] ))
static const char *tagNames[] = {
    #define TAG( s )        #s ,
    OPT_TAGS
    #undef TAG
};

#define TAG( s )        static void do##s( const char * );
OPT_TAGS
#undef TAG

static void (*processTag[])( const char * ) = {
    #define TAG( s )        do##s ,
    OPT_TAGS
    #undef TAG
    NULL
};

#define TARGETS_COUNT  (sizeof( validTargets ) / sizeof( validTargets[0] ))
static const char *validTargets[] = {
/* default targets */
    "any",
    "dbg",
    "unused",
/* architecture targets */
    "i86",
    "386",
    "x64",
    "axp",
    "ppc",
    "mps",
    "a64",
    "arm",
    "sparc",
/* host OS targets */
    "bsd",
    "dos",
    "linux",
    "nov",          /* Netware */
    "nt",
    "os2",
    "osx",
    "pls",          /* DOS Pharlap extender */
    "qnx",
    "rsi",          /* DOS DOS4G extender */
    "haiku",
    "rdos",
    "win",
/* extra targets */
    "targ1",
    "targ2",
};

static const char * const langName[] = {
    #define LANG_RLE_DEF( id, val, dbcs )   #id ,
    LANG_RLE_DEFS
    #undef LANG_RLE_DEF
};

static uint_8 const langMaxChar[] = {
    #define LANG_RLE_DEF( id, val, dbcs )   dbcs ,
    LANG_RLE_DEFS
    #undef LANG_RLE_DEF
};

/*
 * Shift-JIS (CP932) lead byte ranges
 * 0x81-0x9F
 * 0xE0-0xFC
 */
static cvt_chr cvt_table_932[] = {
    #define pickb(s,u) {s, u},
    #define picki(s,u)
    #include "cp932uni.h"
    #undef picki
    #undef pickb
};

static const char *usageMsg[] = {
    "optencod [options] <gml-file> <parser-h> <parser-c> <usage-h> <target>*",
    "",
    "Options:",
    "  -c comma separated list",
    "  -i create international file with non-english data",
    "  -l=<lang-n> is the language(number) used for output data",
    "  -n '\0' terminated items",
    "  -nn '\n' terminated items",
    "  -p generate only parser code",
    "  -q quiet operation",
    "  -rc=<macro-name> generate files for resource compiler",
    "  -t report missing non-english data",
    "  -u=<usage-u> is the output file for the QNX usage file",
    "  -utf8 output text use UTF-8 encoding",
    "  -x=<id> use id to extend symbols to be unique for more instances",
    "",
    "    <gml-file> is the tagged input GML file",
    "    <parser-h> is the output file for the command line parser data declaration",
    "    <parser-c> is the output file for the command line parser code",
    "    <usage-h> is the output file for the usage string file",
    "    <target> can be chosen from:",
    NULL
};

static struct {
    boolbit     international       : 1;
    boolbit     quiet               : 1;
    boolbit     no_equal            : 1;
    boolbit     alternate_equal     : 1;
    boolbit     rc                  : 1;
    boolbit     out_utf8            : 1;
    boolbit     report_missing_data : 1;
    boolbit     parser_only         : 1;
    char        *rc_macro;
    char        *line_term;
    char        *list_sep;
    char        *sid;
    wres_lang_id lang;
} optFlag;

static TARGET       *targetList;
static ENAME        *enumList;
static OPTION       *optionList;
static OPTION       *uselessOptionList;
static TEXT         *titleList;
static TEXT         *footerList;
static CHAIN        *chainList;
static USAGEGROUP   blankUsageGroup;
static USAGEGROUP   *usageGroupList;
static USAGEGROUP   *lastUsageGroup;
static USAGECHAIN   *lastUsageChain = NULL;
static TEXT         *targetTitle;
static TEXT         *targetFooter;

static void emitCode( CODESEQ *head, unsigned depth, flow_control control );

static int mystricmp( const char *p1, const char *p2 )
{
    while( mytolower( *p1 ) == mytolower( *p2 ) ) {
        if( *p1 == '\0') {
            return( 0 );
        }
        p1++; p2++;
    }
    return( mytolower( *p1 ) - mytolower( *p2 ) );
}

#if 0
static int compare_enc( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->s - p2->s );
}
#endif

static int compare_utf8( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->u - p2->u );
}

static size_t utf8_to_cp932( const char *src, char *dst )
{
    size_t      i;
    size_t      o;
    size_t      src_len;
    cvt_chr     x;
    cvt_chr     *p;

    src_len = strlen( src );
    o = 0;
    for( i = 0; i < src_len && o < BUFF_SIZE - 6; i++ ) {
        x.u = (unsigned char)src[i];
        if( IS_ASCII( x.u ) ) {
            /*
             * ASCII (0x00-0x7F), no conversion
             */
            dst[o++] = (char)x.u;
        } else {
            /*
             * UTF-8 to UNICODE conversion
             */
            if( (x.u & 0xF0) == 0xE0 ) {
                x.u &= 0x0F;
                x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            } else {
                x.u &= 0x1F;
            }
            x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            /*
             * UNICODE to CP932 encoding conversion
             */
            p = bsearch( &x, cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
            if( p == NULL ) {
                fprintf( stderr, "unknown unicode character: 0x%4.4X\n", x.u );
                x.s = '?';
            } else {
                x.s = p->s;
            }
            if( x.s > 0xFF ) {
                /* write lead byte first */
                dst[o++] = (char)(x.s >> 8);
            }
            dst[o++] = (char)x.s;
        }
    }
    dst[o] = '\0';
    return( o );
}

static const char *getLangData( lang_data langdata, wres_lang_id lang )
{
    const char *p;

    p = langdata[lang];
    if( p == NULL
      || *p == '\0' ) {
        p = langdata[LANG_RLE_ENGLISH];
    }
    return( p );
}

static void outputInit( void )
{
    wres_lang_id lang;
    char *p;

    p = outputbuff = calloc( LANG_RLE_MAX, BUFF_SIZE );
    for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
        outputdata[lang] = p;
        p += BUFF_SIZE;
    }
}

static void outputFini( void )
{
    free( outputbuff );
}

static void error( const char *msg, ... )
{
    va_list args;

    if( line > 0 ) {
        fprintf( stderr, "error on line %u\n", line );
    }
    va_start( args, msg );
    vfprintf( stderr, msg, args );
    va_end( args );
    errcount++;
}

#if defined( __WATCOMC__ )
#pragma abort   fail
#endif
static void fail( const char *msg, ... )
{
    va_list args;

    if( line > 0 ) {
        fprintf( stderr, "error on line %u\n", line );
    }
    va_start( args, msg );
    vfprintf( stderr, msg, args );
    va_end( args );
    exit( EXIT_FAILURE );
}

static void dumpUsage( void )
{
    const char **p;
    int        i;

    for( p = usageMsg; *p != NULL; ++p ) {
        fprintf( stderr, "%s\n", *p );
    }
    fprintf( stderr, "        " );
    for( i = 0; i < TARGETS_COUNT; i++ ) {
        fprintf( stderr, "%s ", validTargets[i] );
    }
    fprintf( stderr, "\n" );
}

static void emitPrintf( unsigned depth, const char *msg, ... )
{
    va_list args;
    unsigned i;

    if( pfp != NULL ) {
        for( i = ( depth >> 1 ); i != 0; --i ) {
            fprintf( pfp, "\t" );
        }
        if( depth & 1 ) {
            fprintf( pfp, "    " );
        }
        va_start( args, msg );
        vfprintf( pfp, msg, args );
        va_end( args );
    }
}

static char *cvtOptionSpec( char *dst, const char *src, cvt_name cvt )
{
    char c;

    while( (c = *src++) != '\0' ) {
        if( c == '\\' ) {
            if( cvt == CVT_PATTERN ) {
                *dst++ = c;
            }
            c = *src++;
        } else if( cvt != CVT_USAGE ) {
            c = mytolower( c );
        }
        *dst++ = c;
    }
    *dst = '\0';
    return( dst );
}

static bool cmpOptPattern( const char *pattern1, const char *pattern2 )
{
    char    c1;
    char    c2;

    for( ;; ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
        if( c1 == '\0' ) {
            break;
        }
    }
    return( true );
}

static bool cmpChainPattern( const char *pattern1, const char *pattern2, size_t pattern_len )
{
    size_t  i;
    char    c1;
    char    c2;

    for( i = 0; i < pattern_len; i++ ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
            i++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
    }
    return( true );
}

int target_compare_qsort( const void *p1, const void *p2 )
{
    const TARGET *p1c = (const TARGET *)p1;
    const TARGET *p2c = (const TARGET *)p2;
    return( stricmp( p1c->name, p2c->name ) );
}

int target_compare_bsearch( const void *p1, const void *p2 )
{
    const char *p1c = (const char *)p1;
    const TARGET *p2c = (const TARGET *)p2;
    return( stricmp( p1c, p2c->name ) );
}

static targmask findTarget( char const *t )
{
    const TARGET *key;

    key = (const TARGET *)bsearch( t, targetList, TARGETS_COUNT, sizeof( TARGET ), target_compare_bsearch );
    if( key == NULL )
        return( 0 );
    return( key->mask );
}

static void initTargets( void )
{
    int         i;
    targmask    next_mask = 1;

    targetList = calloc( TARGETS_COUNT, sizeof( TARGET ) );
    for( i = 0; i < TARGETS_COUNT; i++ ) {
        targetList[i].name = validTargets[i];
        targetList[i].mask = next_mask;
        next_mask <<= 1;
        if( next_mask == 0 ) {
            fail( "too many targets defined\n" );
        }
    }
    qsort( targetList, TARGETS_COUNT, sizeof( TARGET ), target_compare_qsort );
}

static void finiTargets( void )
{
    free( targetList );
}

static ENAME *addEnumName( ENAME **h, const char *n )
{
    size_t len;
    ENAME *e;

    for( e = *h; e != NULL; e = e->next ) {
        if( strcmp( n, e->name ) == 0 ) {
            return( e );
        }
    }
    len = strlen( n );
    e = malloc( sizeof( *e ) + len );
    strcpy( e->name, n );
    e->next = *h;
    *h = e;
    e->items = NULL;
    return( e );
}

static INAME *addEnumerator( ENAME *en, const char *field_name )
{
    INAME *ei;
    size_t len;

    strcpy( tmpbuff, en->name );
    strcat( tmpbuff, "_" );
    strcat( tmpbuff, field_name );
    for( ei = en->items; ei != NULL; ei = ei->next ) {
        if( strcmp( tmpbuff, ei->name ) == 0 ) {
            return( ei );
        }
    }
    len = strlen( tmpbuff );
    ei = malloc( sizeof( *ei ) + len );
    strcpy( ei->name, tmpbuff );
    ei->next = en->items;
    en->items = ei;
    return( ei );
}

static USAGEGROUP *findUsageGroup( const char *id )
{
    USAGEGROUP  *ugr;

    for( ugr = usageGroupList; ugr != NULL; ugr = ugr->next ) {
        if( strcmp( ugr->id, id ) == 0 ) {
            break;
        }
    }
    return( ugr );
}

static void initUsageGroup( void )
{
    memset( &blankUsageGroup, 0, sizeof( blankUsageGroup ) );
    usageGroupList = &blankUsageGroup;
    lastUsageGroup = NULL;
}

static void addUsageGroup( const char *id )
{
    size_t      id_len;
    USAGEGROUP  *ugr;

    id_len = strlen( id );
    ugr = calloc( 1, sizeof( *ugr ) + id_len );
    memcpy( ugr->id, id, id_len + 1 );
    if( lastUsageGroup == NULL ) {
        usageGroupList->next = ugr;
    } else {
        lastUsageGroup->next = ugr;
    }
    lastUsageGroup = ugr;
}

static CHAIN *findChain( const char *pattern )
{
    CHAIN *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( strcmp( pattern, cn->pattern ) == 0 ) {
            break;
        }
    }
    return( cn );
}

static void addChain( char *pattern )
{
    size_t pattern_len;
    CHAIN *cn;

    pattern_len = cvtOptionSpec( pattern, pattern, CVT_PATTERN ) - pattern;
    cn = calloc( 1, sizeof( *cn ) + pattern_len );
    cn->pattern_len = pattern_len;
    memcpy( cn->pattern, pattern, pattern_len + 1 );
    cn->len = cvtOptionSpec( pattern, pattern, CVT_NAME ) - pattern;
    cn->next = chainList;
    chainList = cn;
}

static USAGECHAIN *findUsageChain( USAGEGROUP *ugr, const char *pattern )
{
    USAGECHAIN  *ucn;

    for( ucn = ugr->usageChainList; ucn != NULL; ucn = ucn->next ) {
        if( strcmp( pattern, ucn->pattern ) == 0 ) {
            break;
        }
    }
    return( ucn );
}

static void addUsageChain( USAGEGROUP *ugr, char *pattern )
{
    size_t      pattern_len;
    USAGECHAIN  *ucn;

    pattern_len = cvtOptionSpec( pattern, pattern, CVT_PATTERN ) - pattern;
    ucn = calloc( 1, sizeof( *ucn ) + pattern_len );
    ucn->pattern_len = pattern_len;
    memcpy( ucn->pattern, pattern, pattern_len + 1 );
    ucn->len = cvtOptionSpec( pattern, pattern, CVT_NAME ) - pattern;
    ucn->next = ugr->usageChainList;
    ugr->usageChainList = ucn;
    lastUsageChain = ucn;
}

static FILE *initFILE( const char *fnam, const char *fmod )
{
    FILE        *fp;
    bool        open_read;

    fp = NULL;
    if( *fnam != '\0' && !BLANKARG( fnam ) ) {
        open_read = ( strchr( fmod, 'r' ) != NULL );
        fp = fopen( fnam, fmod );
        if( fp == NULL ) {
            fail( "cannot open '%s' for %s", fnam, ( open_read ) ? "input" : "output" );
        }
    }
    return( fp );
}

static const char *nextWord( const char *s, char *o )
{
    char    *start;

    start = o;
    while( *s != '\0' ) {
        if( myisspace( *s ) )
            break;
        *o++ = *s++;
    }
    *o = '\0';
    if( BLANKARG( start ) ) {
        *start = '\0';
    }
    SKIP_SPACES( s );
    return( s );
}

static const char *nextTag( const char *s, char *o )
{
    while( *s != '\0' ) {
        if( myisspace( *s ) )
            break;
        if( *s == '.' ) {
            s++;
            break;
        }
        *o++ = *s++;
    }
    *o = '\0';
    SKIP_SPACES( s );
    return( s );
}

int tag_compare( const void *p1, const void *p2 )
{
    const char *p1c = (const char *)p1;
    const char **p2c = (const char **)p2;
    return( mystricmp( p1c, *p2c ) );
}

static tag_id findTag( char const *t )
{
    const char **key;

    key = (char const **)bsearch( t, tagNames, TAGS_COUNT, sizeof( char * ), tag_compare );
    if( key == NULL )
        return( TAG_UNKNOWN );
    return( key - tagNames );
}

static tag_id isTag( const char **eot )
{
    tag_id tag;
    const char *p;

    p = ibuff;
    SKIP_SPACES( p );
    if( *p++ == ':' ) {
        p = nextTag( p, tagbuff );
        if( (tag = findTag( tagbuff )) == TAG_UNKNOWN )
            error( "unknown tag: %s\n", tagbuff );
        *eot = p;
        return( tag );
    }
    return( TAG_NULL );
}

static OPTION *pushNewOption( char *pattern, OPTION *o )
{
    size_t  len;
    OPTION  *newo;

    len = strlen( pattern );
    newo = calloc( 1, sizeof( *newo ) + len );
    memcpy( newo->pattern, pattern, len + 1 );
    len = cvtOptionSpec( pattern, pattern, CVT_NAME ) - pattern;
    newo->name_len = len;
    newo->name = calloc( 1, len + 1 );
    memcpy( newo->name, pattern, len + 1 );
    newo->synonym = o;
    newo->is_simple = true;
    newo->next = optionList;
    newo->equal_char = '\0';
    newo->target_mask = targetAnyMask;
    newo->any_target = true;
    newo->usageGroup = usageGroupList;
    optionList = newo;
    return( newo );
}

static char *pickUpRest( const char *p )
{
    size_t  len;
    char    *dst;
    char    *out;

    // replace leading '.' character by space
    // it is used to specify spaces on the beginning of text
    // if only '.' character than it is as blank text
    // if only two '.' character than it is single space text
    len = strlen( p );
    out = dst = malloc( len + 1 );
    if( BLANKARG( p ) ) {
        len = 0;
    } else if( p[0] == '.'
      && p[1] == '.'
      && p[2] == '\0' ) {
        len = 0;
        *dst++ = ' ';
    } else {
        if( p[0] == '.' ) {
            len--;
            *dst++ = ' ';
            p++;
        }
        if( len > 0 ) {
            memcpy( dst, p, len );
        }
    }
    dst[len] = '\0';
    return( out );
}

// :argequal. <char>
static void doARGEQUAL( const char *p )
{
    char    c;

    if( *p == '\0' ) {
        error( ":argequal. tag requires <char> parameter\n" );
    } else {
        if( p[0] == '.'
          && p[1] == '.' ) {
            c = ' ';
        } else {
            c = *p;
        }
        if( getsUsage == TAG_OPTION ) {
            OPTION *o;

            for( o = optionList; o != NULL; o = o->synonym ) {
                o->equal_char = c;
            }
        } else {
            alternateEqual = c;
            optFlag.alternate_equal = true;
        }
    }
    if( getsUsage != TAG_OPTION ) {
        getsUsage = TAG_ARGEQUAL;
    }
}

// :cmt comment text
static void doCMT( const char *p )
{
    /* unused parameters */ (void)p;
}

// :internal.
static void doINTERNAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_internal = true;
    }
}

// :option. <option> <synonym> ...
static void doOPTION( const char *p )
{
    OPTION *synonym;

    targetTitle = NULL;
    targetFooter = NULL;
    synonym = NULL;
    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        synonym = pushNewOption( tokbuff, synonym );
    }
    getsUsage = TAG_OPTION;
}

// :target. <targ> <targ> ...
static void doTARGET( const char *p )
{
    targmask    mask;
    OPTION      *o;

    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            error( "invalid target name '%s'\n", tokbuff );
        } else if( targetTitle != NULL ) {
            if( targetTitle->any_target ) {
                targetTitle->target_mask = mask;
                targetTitle->any_target = false;
            } else {
                targetTitle->target_mask |= mask;
            }
        } else if( targetFooter != NULL ) {
            if( targetFooter->any_target ) {
                targetFooter->target_mask = mask;
                targetFooter->any_target = false;
            } else {
                targetFooter->target_mask |= mask;
            }
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                if( o->any_target ) {
                    o->target_mask = mask;
                    o->any_target = false;
                } else {
                    o->target_mask |= mask;
                }
            }
        }
    }
}

// :ntarget. <targ> <targ> ...
static void doNTARGET( const char *p )
{
    targmask    mask;
    OPTION      *o;

    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            error( "invalid target name '%s'\n", tokbuff );
        } else if( targetTitle != NULL ) {
            targetTitle->ntarget_mask |= mask;
        } else if( targetFooter != NULL ) {
            targetFooter->ntarget_mask |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->ntarget_mask |= mask;
            }
        }
    }
}

// :number. [<fn>] [<default>] [<usage argid>]
static void doNUMBER( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_number = true;
        o->is_simple = false;
        o->is_text = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( *tokbuff != '\0' ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( *tokbuff != '\0' ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->number_default = atoi( tokbuff );
                o->default_specified = true;
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :multiple.
static void doMULTIPLE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_multiple = true;
    }
}

// :nochain.
static void doNOCHAIN( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->nochain = true;
    }
}

// :id. [<fn>] [<usage argid>]
static void doID( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_id = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( *tokbuff != '\0' ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :char. [<fn>] [<usage argid>]
static void doCHAR( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_char = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( *tokbuff != '\0' ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->check_func = strdup( tokbuff );
            }
        }
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :immediate. <fn> [<usage argid>]
static void doIMMEDIATE( const char *p )
{
    OPTION *o;

    if( *p == '\0' ) {
        error( ":immediate. tag requires <fn> parameter\n" );
        return;
    }
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_immediate = true;
        o->is_simple = false;
    }
    p = nextWord( p, tokbuff );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->immediate_func = strdup( tokbuff );
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :code. <source-code>
static void doCODE( const char *p )
{
    OPTION *o;

    if( *p == '\0' ) {
        error( ":code. tag requires <source-code> parameter\n" );
        return;
    }
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_code = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->code = strdup( p );
        }
    }
}

// :file. [<usage argid>]
static void doFILE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_file = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :optional.
static void doOPTIONAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_optional = true;
    }
}
// :negate.
static void doNEGATE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_negate = true;
        if( o->enumerate != NULL ){
            error( ":negate. tag can be used with non-enumeration option for negate tag\n" );
        }
    }
}


// :noequal.
static void doNOEQUAL( const char *p )
{
    /* unused parameters */ (void)p;

    optFlag.no_equal = true;
    getsUsage = TAG_NOEQUAL;
}

// :path. [<usage argid>]
static void doPATH( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_path = true;
        o->is_simple = false;
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :chain. <option> <option> ...
//
// mark options that start with <option> as chainable
// i.e., -oa -ox == -oax
static void doCHAIN( const char *p )
{
    getsUsage = TAG_CHAIN;
    if( *p == '\0' ) {
        error( ":chain. tag requires <option> parameter\n" );
        return;
    }
    while( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        if( findChain( tokbuff ) != NULL ) {
            error( ":chain. tag <option> value '%s' is already defined\n", tokbuff );
        } else {
            addChain( tokbuff );
        }
    }
}

// :enumerate. <name> [<option>]
static void doENUMERATE( const char *p )
{
    ENAME *en;
    OPTION *o;

    if( *p == '\0' ) {
        error( ":enumerate. tag requires <name> parameter\n" );
        return;
    }
    p = nextWord( p, tokbuff );
    en = addEnumName( &enumList, tokbuff );
    p = nextWord( p, tokbuff );
    if( *tokbuff != '\0' ) {
        addEnumerator( en, tokbuff );
    }
    addEnumerator( en, "default" );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->enumerate = en;
        if( o->is_timestamp ) {
            en->is_timestamp = true;
        }
        if( *tokbuff != '\0' ) {
            o->field_name = strdup( tokbuff );
        }
    }
}

// :special. <fn> [<usage argid>]
static void doSPECIAL( const char *p )
{
    OPTION *o;

    if( *p == '\0' ) {
        error( ":special. tag requires <fn> parameter\n" );
        return;
    }
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_special = true;
        o->is_text = true;
        o->is_simple = false;
    }
    p = nextWord( p, tokbuff );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->special_func = strdup( tokbuff );
    }
    if( *p != '\0' ) {
        p = nextWord( p, tokbuff );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usage_argid = strdup( tokbuff );
        }
    }
}

// :prefix.
static void doPREFIX( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_prefix = true;
        o->is_simple = false;
    }
}

// :usage. <usage-text>
static void doUSAGE( const char *p )
{
    OPTION *o;

    switch( getsUsage ) {
    case TAG_USAGECHAIN:
        lastUsageChain->lang_usage[LANG_RLE_ENGLISH] = pickUpRest( p );
        break;
    case TAG_USAGEGROUP:
        lastUsageGroup->lang_usage[LANG_RLE_ENGLISH] = pickUpRest( p );
        break;
    case TAG_OPTION:
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->lang_usage[LANG_RLE_ENGLISH] = pickUpRest( p );
        }
        break;
    default:
        error( ":usage. tag can follow only :usagechain., :usagegroup., or :option. tag\n" );
    }
}

// :jusage. <kanji-usage-text>
static void doJUSAGE( const char *p )
{
    char *usage;
    OPTION *o;

    switch( getsUsage ) {
    case TAG_USAGECHAIN:
        if( lastUsageChain->lang_usage[LANG_RLE_ENGLISH] == NULL ) {
            error( ":jusage. tag last :usagechain. hasn't define English text.\n" );
        }
        lastUsageChain->lang_usage[LANG_RLE_JAPANESE] = pickUpRest( p );
        break;
    case TAG_USAGEGROUP:
        if( lastUsageGroup->lang_usage[LANG_RLE_ENGLISH] == NULL ) {
            error( ":jusage. tag last :usagegroup. hasn't define English text.\n" );
        }
        lastUsageGroup->lang_usage[LANG_RLE_JAPANESE] = pickUpRest( p );
        break;
    case TAG_OPTION:
        for( o = optionList; o != NULL; o = o->synonym ) {
            usage = pickUpRest( p );
            if( *usage == '\0' ) {
                free( usage );
                usage = strdup( o->lang_usage[LANG_RLE_ENGLISH] );
            }
            o->lang_usage[LANG_RLE_JAPANESE] = usage;
        }
        break;
    default:
        error( ":jusage. tag can follow only :usagechain., :usagegroup., or :option. tag\n" );
    }
}

// :title. <text>
static void doTITLE( const char *p )
{
    TEXT    **i;
    TEXT    *t;

    i = &titleList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( 1, sizeof( *t ) );
    t->next = *i;
    *i = t;
    t->lang_usage[LANG_RLE_ENGLISH] = pickUpRest( p );
    t->target_mask = targetAnyMask;
    t->any_target = true;
    targetTitle = t;
    targetFooter = NULL;
    getsUsage = TAG_TITLE;
}

// :titleu. <text>
static void doTITLEU( const char *p )
{
    if( getsUsage != TAG_TITLE || targetTitle == NULL ) {
        error( ":titleu. tag must follow a :title. tag\n" );
        return;
    }
    targetTitle->lang_usageu[LANG_RLE_ENGLISH] = pickUpRest( p );
    targetTitle->is_u = true;
}

// :jtitle. <text>
static void doJTITLE( const char *p )
{
    if( getsUsage != TAG_TITLE || targetTitle == NULL ) {
        error( ":jtitle. tag must follow a :title. tag\n" );
        return;
    }
    targetTitle->lang_usage[LANG_RLE_JAPANESE] = pickUpRest( p );
}

// :jtitleu. <text>
static void doJTITLEU( const char *p )
{
    if( getsUsage != TAG_TITLE || targetTitle == NULL ) {
        error( ":jtitleu. tag must follow a :title. tag\n" );
        return;
    }
    targetTitle->lang_usageu[LANG_RLE_JAPANESE] = pickUpRest( p );
    targetTitle->is_u = true;
}

// :footer. <text>
static void doFOOTER( const char *p )
{
    TEXT    **i;
    TEXT    *t;

    i = &footerList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( 1, sizeof( *t ) );
    t->next = *i;
    *i = t;
    t->lang_usage[LANG_RLE_ENGLISH] = pickUpRest( p );
    t->target_mask = targetAnyMask;
    t->any_target = true;
    targetFooter = t;
    targetTitle = NULL;
    getsUsage = TAG_FOOTER;
}

// :footeru. <text>
static void doFOOTERU( const char *p )
{
    if( getsUsage != TAG_FOOTER || targetFooter == NULL ) {
        error( ":footeru. tag must follow a :footer. tag\n" );
        return;
    }
    targetFooter->lang_usageu[LANG_RLE_ENGLISH] = pickUpRest( p );
    targetFooter->is_u = true;
}

// :jfooter. <text>
static void doJFOOTER( const char *p )
{
    if( getsUsage != TAG_FOOTER || targetFooter == NULL ) {
        error( ":jfooter. tag must follow a :footer. tag\n" );
        return;
    }
    targetFooter->lang_usage[LANG_RLE_JAPANESE] = pickUpRest( p );
}

// :jfooteru. <text>
static void doJFOOTERU( const char *p )
{
    if( getsUsage != TAG_FOOTER || targetFooter == NULL ) {
        error( ":jfooteru. tag must follow a :footer. tag\n" );
        return;
    }
    targetFooter->lang_usageu[LANG_RLE_JAPANESE] = pickUpRest( p );
    targetFooter->is_u = true;
}

// :group. <group_id>
static void doGROUP( const char *p )
{
    OPTION      *o;
    USAGEGROUP  *ugr;

    if( *p == '\0' ) {
        error( ":group. tag requires <group_id> parameter\n" );
        return;
    }
    p = nextWord( p, tokbuff );
    ugr = findUsageGroup( tokbuff );
    if( ugr == NULL ) {
        error( ":group. tag <group_id> value '%s' is not found.\n", tokbuff );
    } else {
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->usageGroup = ugr;
        }
    }
}


// :timestamp.
static void doTIMESTAMP( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_timestamp = true;
        o->is_simple = false;
        if( o->enumerate != NULL ) {
            o->enumerate->is_timestamp = true;
        }
    }
}

// :usagechain. <group_id> <option>
//
// mark options that start with <option> as group in usage text
// i.e., -fp0 -fp1 ==> -fp{0,1}
static void doUSAGECHAIN( const char *p )
{
    USAGEGROUP  *ugr;

    if( *p == '\0' ) {
        error( ":usagechain. tag requires <group_id> parameter\n" );
        return;
    }
    p = nextWord( p, tokbuff );
    if( *p == '\0' ) {
        error( ":usagechain. tag requires <option> parameter\n" );
        return;
    }
    ugr = findUsageGroup( tokbuff );
    if( ugr == NULL ) {
        error( ":usagechain. tag <group_id> value '%s' is not found.\n", tokbuff );
        return;
    }
    nextWord( p, tokbuff );
    if( findUsageChain( ugr, tokbuff ) != NULL ) {
        error( ":usagechain. tag <option> value '%s' is already defined for <group_id> '%s'.\n", tokbuff, ugr->id );
        return;
    }
    addUsageChain( ugr, tokbuff );
    getsUsage = TAG_USAGECHAIN;
}

// :usagegroup. <group_id>
//
// define group <group_id> for block of options
//
static void doUSAGEGROUP( const char *p )
{
    if( *p == '\0' ) {
        error( ":usagegroup. tag requires <group_id> parameter\n" );
        return;
    }
    nextWord( p, tokbuff );
    if( findUsageGroup( tokbuff ) != NULL ) {
        error( ":usagegroup. <group_id> '%s' already defined\n", tokbuff );
        return;
    }
    addUsageGroup( tokbuff );
    getsUsage = TAG_USAGEGROUP;
}

// :usagenochain.
static void doUSAGENOCHAIN( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->usage_nochain = true;
    }
}

static void checkForGMLEscape( const char *p )
{
    bool is_escape;
    char c1, c2;

    c1 = *p++;
    if( c1 == '\0'
      || ! isalpha( c1 ) ) {
        return;
    }
    c2 = *p++;
    if( c2 == '\0'
      || ! isalpha( c2 ) ) {
        return;
    }
    is_escape = false;
    if( *p == '\0'
      || ! isalpha( *p ) ) {
        is_escape = true;
    }
    if( is_escape ) {
        error( "possible GML escape sequence: &%c%c\n", c1, c2 );
    }
}

static void checkForGMLEscapeSequences( void )
{
    char c;
    char *p;

    for( p = ibuff; (c = *p++) != '\0'; ) {
        if( c == '&' ) {
            checkForGMLEscape( p );
        }
    }
}

static char *my_fgets( char *buff, int buff_len, FILE *fp )
{
    char    *p;
    size_t  len;

    p = fgets( buff, buff_len, fp );
    if( p != NULL ) {
        for( len = strlen( p ); len > 0 && ( p[len - 1] == '\n' || p[len - 1] == '\r' ); len-- )
            ;
        p[len] = '\0';
    }
    return( p );
}

static void readInputFile( void )
{
    const char  *eot;
    tag_id      tag;

    for( ; my_fgets( ibuff, sizeof( ibuff ), gfp ) != NULL; ) {
        ++line;
        checkForGMLEscapeSequences();
        tag = isTag( &eot );
        if( tag != TAG_NULL ) {
            (*processTag[tag])( eot );
        }
    }
}

static void checkForMissingUsages( void )
{
    OPTION      *o;
    TEXT        *t;
    USAGECHAIN  *ucn;
    USAGEGROUP  *ugr;
    wres_lang_id start_lang;
    wres_lang_id end_lang;
    wres_lang_id lang;
    int         j;

    if( optFlag.international ) {
        start_lang = 0;
        end_lang = LANG_RLE_MAX;
    } else {
        start_lang = LANG_RLE_ENGLISH;
        end_lang = start_lang + 1;
    }
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->usageChain == NULL
          || cmpOptPattern( o->pattern, o->usageChain->pattern ) ) {
            for( lang = start_lang; lang < end_lang; ++lang ) {
                if( ( lang == LANG_RLE_ENGLISH || optFlag.report_missing_data ) && o->lang_usage[lang] == NULL ) {
                    error( "option '%s' has no %s usage text\n", o->pattern, langName[lang] );
                }
            }
        }
    }
    j = 1;
    for( t = titleList; t != NULL; t = t->next ) {
        for( lang = start_lang; lang < end_lang; ++lang ) {
            if( ( lang == LANG_RLE_ENGLISH || optFlag.report_missing_data ) && t->lang_usage[lang] == NULL ) {
                error( "title(%d) has no %s usage text\n", j, langName[lang] );
            }
        }
        j++;
    }
    j = 1;
    for( t = footerList; t != NULL; t = t->next ) {
        for( lang = start_lang; lang < end_lang; ++lang ) {
            if( ( lang == LANG_RLE_ENGLISH || optFlag.report_missing_data ) && t->lang_usage[lang] == NULL ) {
                error( "footer(%d) has no %s usage text\n", j, langName[lang] );
            }
        }
        j++;
    }
    for( ugr = usageGroupList->next; ugr != NULL; ugr = ugr->next ) {
        for( lang = start_lang; lang < end_lang; ++lang ) {
            if( optFlag.report_missing_data && ugr->lang_usage[lang] == NULL ) {
                error( "group '%s' has no %s usage text\n", ugr->id, langName[lang] );
            }
        }
        for( ucn = ugr->usageChainList; ucn != NULL; ucn = ucn->next ) {
            for( lang = start_lang; lang < end_lang; ++lang ) {
                if( optFlag.report_missing_data && ucn->lang_usage[lang] == NULL ) {
                    error( "chain '%s' has no %s usage text\n", ucn->pattern, langName[lang] );
                }
            }
        }
    }
}

static void assignCodeChainToOptions( void )
{
    OPTION  *o;
    CHAIN   *cn;
    CHAIN   *cnx;

    for( o = optionList; o != NULL; o = o->next ) {
        cnx = NULL;
        if( !o->nochain ) {
            for( cn = chainList; cn != NULL; cn = cn->next ) {
                if( cmpChainPattern( cn->pattern, o->pattern, cn->pattern_len ) ) {
                    if( cnx == NULL || cnx->pattern_len < cn->pattern_len ) {
                        cnx = cn;
                    }
                }
            }
        }
        o->chain = cnx;
    }
}

static void assignUsageChainToOptions( void )
{
    OPTION      *o;
    USAGECHAIN  *ucn;
    USAGECHAIN  *ucnx;

    for( o = optionList; o != NULL; o = o->next ) {
        ucnx = NULL;
        if( !o->usage_nochain ) {
            for( ucn = o->usageGroup->usageChainList; ucn != NULL; ucn = ucn->next ) {
                if( cmpChainPattern( ucn->pattern, o->pattern, ucn->pattern_len ) ) {
                    if( ucnx == NULL || ucnx->pattern_len < ucn->pattern_len ) {
                        ucnx = ucn;
                    }
                }
            }
        }
        o->usageChain = ucnx;
    }
}

static void stripUselessOptions( void )
{
    OPTION **h;
    OPTION *o;
    OPTION *o_next;

    h = &optionList;
    for( o = *h; o != NULL; o = o_next ) {
        o_next = o->next;
        if( IS_SELECTED( o ) ) {
            if( o->enumerate != NULL )
                o->enumerate->used = true;
            h = &(o->next);
        } else {
            o->next = uselessOptionList;
            uselessOptionList = o;
            *h = o_next;
        }
    }
}

static char *strpcpy( char *d, const char *s )
{
    size_t len;

    len = strlen( s );
    strcpy( d, s );
    return( d + len );
}

static char *special_char( char *f, char c )
{
    if( c == '~' ) {
        f = strpcpy( f, "_tilde" );
    } else if( c == '+' ) {
        f = strpcpy( f, "_plus" );
    } else if( c == '!' ) {
        f = strpcpy( f, "_exclamation" );
    } else if( c == '#' ) {
        f = strpcpy( f, "_sharp" );
    } else if( c == '?' ) {
        f = strpcpy( f, "_question" );
    } else if( c == '@' ) {
        f = strpcpy( f, "_at" );
    } else if( c == '"' ) {
        f = strpcpy( f, "_dquote" );
    } else {
        *f++ = '_';
    }
    return( f );
}

static void makeFieldName( const char *pattern, char *f )
{
    char c;
    bool sensitive;
    bool is_special;

    c = *pattern++;
    if( c == '\\' ) {
        c = *pattern++;
    } else {
        c = mytolower( c );
    }
    if( c != '\0' ) {
        is_special = false;
        if( isalnum( c ) ) {
            if( isdigit( c ) )
                *f++ = '_';
            *f++ = c;
        } else {
            f = special_char( f, c );
            is_special = true;
        }
        sensitive = false;
        for( ; (c = *pattern++) != '\0'; ) {
            if( c == '\\' ) {
                sensitive = true;
                continue;
            }
            if( isalnum( c ) ) {
                if( is_special
                  && *( f - 1 ) != '_' )
                    *f++ = '_';
                if( !sensitive )
                    c = mytolower( c );
                *f++ = c;
                is_special = false;
            } else {
                f = special_char( f, c );
                is_special = true;
            }
            sensitive = false;
        }
    }
    *f = '\0';
}

static void initOptionFields( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( o->field_name == NULL ) {
                makeFieldName( o->pattern, tokbuff );
                o->field_name = strdup( tokbuff );
            }
            if( o->value_field_name == NULL ) {
                strcpy( tokbuff, o->field_name );
                strcat( tokbuff, "_value" );
                o->value_field_name = strdup( tokbuff );
            }
        }
    }
}

static void startParserH( void )
{
    OPTION *o;
    ENAME *en;
    FILE *fp;

    if( !optFlag.parser_only ) {
        if( optFlag.sid != NULL && *optFlag.sid != '\0' ) {
            fp = ofpg;
        } else {
            fp = ofp;
        }
        if( fp != NULL ) {
            fprintf( fp, "#ifndef OPT_STRING\n" );
            fprintf( fp, "#define OPT_STRING opt_string\n" );
            fprintf( fp, "typedef struct opt_string {\n" );
            fprintf( fp, "    struct opt_string *next;\n" );
            fprintf( fp, "    char data[1];\n" );
            fprintf( fp, "} opt_string;\n" );
            fprintf( fp, "#endif\n" );
            fprintf( fp, "#ifndef OPT_NUMBER\n" );
            fprintf( fp, "#define OPT_NUMBER opt_number\n" );
            fprintf( fp, "typedef struct opt_number {\n" );
            fprintf( fp, "    struct opt_number *next;\n" );
            fprintf( fp, "    unsigned number;\n" );
            fprintf( fp, "} opt_number;\n" );
            fprintf( fp, "#endif\n" );
        }
        if( ofp != NULL ) {
            fprintf( ofp, "typedef struct opt_storage%s OPT_STORAGE%s;\n", optFlag.sid, optFlag.sid );
            fprintf( ofp, "struct opt_storage%s {\n", optFlag.sid );
            fprintf( ofp, "    unsigned     timestamp;\n" );
            for( o = optionList; o != NULL; o = o->next ) {
                if( o->synonym == NULL ) {
                    if( o->is_number ) {
                        if( HAS_OPT_NUMBER( o ) ) {
                            fprintf( ofp, "    OPT_NUMBER   *%s;\n", o->value_field_name );
                        } else {
                            fprintf( ofp, "    unsigned     %s;\n", o->value_field_name );
                        }
                    } else if( o->is_char ) {
                        fprintf( ofp, "    int          %s;\n", o->value_field_name );
                    } else if( HAS_OPT_STRING( o ) ) {
                        fprintf( ofp, "    OPT_STRING   *%s;\n", o->value_field_name );
                    }
                    /*
                     * the enumeration is shared by several options that
                     * require enumeration timestamp to be processed instead
                     * of option simple timestamp
                     * in case of enumeration it is skiped and processed in next code
                     */
                    if( o->enumerate == NULL ) {
                        if( o->is_timestamp ) {
                            fprintf( ofp, "    unsigned     %s_timestamp;\n", o->field_name );
                        }
                    }
                }
            }
            /*
             * this section process only enumerations (field + timestamp)
             */
            for( en = enumList; en != NULL; en = en->next ) {
                if( !en->used )
                    continue;
                fprintf( ofp, "    unsigned     %s;\n", en->name );
                if( en->is_timestamp ) {
                    fprintf( ofp, "    unsigned     %s_timestamp;\n", en->name );
                }
            }
            for( o = optionList; o != NULL; o = o->next ) {
                if( o->synonym == NULL ) {
                    if( o->enumerate == NULL ) {
                        fprintf( ofp, "    boolbit      %s : 1;\n", o->field_name );
                    }
                }
            }
            fprintf( ofp, "};\n" );
            fprintf( ofp, "extern void " FN_INIT "%s( OPT_STORAGE%s *data );\n", optFlag.sid, optFlag.sid );
            fprintf( ofp, "extern void " FN_FINI "%s( OPT_STORAGE%s *data );\n", optFlag.sid, optFlag.sid );
        }
    }
    if( ofp != NULL ) {
        fprintf( ofp, "extern bool " FN_PROCESS "%s( OPT_STORAGE%s *data );\n", optFlag.sid, optFlag.sid );
    }
}

static void finishParserH( void )
{
    ENAME *en;
    unsigned value;
    INAME *ei;

    if( ofp != NULL ) {
        value = 0;
        for( en = enumList; en != NULL; en = en->next ) {
            if( !en->used )
                continue;
            for( ei = en->items; ei != NULL; ei = ei->next ) {
                ++value;
                fprintf( ofp, "#define OPT_ENUM%s_%s %u\n", optFlag.sid, ei->name, value );
            }
        }
    }
}

static CODESEQ *newCode( OPTION *o, char c, char s )
{
    CODESEQ *code;

    code = calloc( 1, sizeof( *code ) );
    code->option = o;
    code->c = c;
    code->s = s;
    return( code );
}

static CODESEQ *addCode( CODESEQ **splice, OPTION *o, char c, char s )
{
    CODESEQ *code;

    for( code = *splice; code != NULL; code = *splice ) {
        if( code->c == c
          && code->s == s ) {
            break;
        }
        splice = &(code->sibling);
    }
    if( code == NULL ) {
        code = newCode( o, c, s );
        *splice = code;
    }
    return( code );
}

static CODESEQ *addOptionCodeSeq( CODESEQ *head, OPTION *o )
{
    char    *pattern;
    char    c;
    char    s;
    CODESEQ *code;
    CODESEQ **splice;

    code = head;
    splice = &head;
    for( pattern = o->pattern; (c = *pattern++) != '\0'; ) {
        s = NOSENSITIVE;
        if( c == '\\' ) {
            c = *pattern++;
            if( myisalpha( c ) ) {
                s = c;
                c = mytolower( c );
            }
        }
        code = addCode( splice, o, c, s );
        splice = &(code->children);
    }
    code->accept = true;
    code->option = o;
    return( head );
}

static CODESEQ *reorderCode( CODESEQ *head )
{
    CODESEQ *a;
    CODESEQ *c;
    CODESEQ *n;
    CODESEQ **s;

    c = head;
    if( c->sibling != NULL ) {
        a = NULL;
        s = &head;
        // accepting states move to the end
        for( c = head; c != NULL; c = n ) {
            n = c->sibling;
            if( c->accept ) {
                *s = n;
                c->sibling = a;
                a = c;
            } else {
                s = &(c->sibling);
            }
        }
        *s = a;
        s = &(head->sibling);
        // sensitive states move to the front
        for( c = head; c != NULL; c = n ) {
            n = c->sibling;
            if( IS_SENSITIVE( c ) ) {
                *s = n;
                c->sibling = head;
                head = c;
            } else {
                s = &(c->sibling);
            }
        }
    }
    for( c = head; c != NULL; c = c->sibling ) {
        if( c->children != NULL ) {
            c->children = reorderCode( c->children );
        }
    }
    return( head );
}

static bool markChainCode( CODESEQ *head, size_t level )
{
    CODESEQ *c;
    bool    rc;

    rc = false;
    for( c = head; c != NULL; c = c->sibling ) {
        if( c->option->chain != NULL ) {
            if( c->children != NULL
              && level <= c->option->chain->len ) {
                if( markChainCode( c->children, level + 1 ) ) {
                    if( level == c->option->chain->len ) {
                        c->is_chain_root = true;
                    }
                }
            } else if( c->option->name_len == c->option->chain->len + 1 ) {
                c->is_chain = true;
                rc = true;
                /*
                 * this is an extension, you can use two forms of input
                 * with one character <option character> or <option character>+
                 * even if only one character is allowed
                 */
                if( c->children != NULL
                  && c->children->c == '+' ) {
                    c->children->is_chain = true;
                }
            }
        }
    }
    return( rc );
}

static CODESEQ *genCode( OPTION *o )
{
    CODESEQ *head;

    head = NULL;
    for( ; o != NULL; o = o->next ) {
        head = addOptionCodeSeq( head, o );
    }
    head = reorderCode( head );
    markChainCode( head, 1 );
    return( head );
}

static void emitSuccessCode( unsigned depth, flow_control control )
{
    if( control & EC_CONTINUE ) {
        emitPrintf( depth, "continue;\n" );
    } else {
        emitPrintf( depth, "return( false );\n" );
    }
}

static void emitAcceptCode( CODESEQ *c, unsigned depth, flow_control control )
{
    INAME *ei;
    OPTION *o;
    struct {
        boolbit     close_value_if : 1;
    } flag;

    o = c->option;
    while( o->synonym != NULL ) {
        o = o->synonym;
    }
    if( o->is_prefix ) {
        emitPrintf( depth, "if( " FN_END "() ) {\n" );
        ++depth;
    }
    flag.close_value_if = false;
    if( o->is_special ) {
        emitPrintf( depth, "if( %s( &(data->%s) ) ) {\n", o->special_func, o->value_field_name );
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_number ) {
        if( o->default_specified ) {
            emitPrintf( depth, "if( " FN_NUMBER_DEFAULT "( &(data->%s ), %u ) ) {\n", o->value_field_name, o->number_default );
        } else if( o->is_multiple ) {
            emitPrintf( depth, "if( " FN_NUMBER_MULTIPLE "( &(data->%s ) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_NUMBER "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_char ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_CHAR_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_CHAR "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_id ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_ID_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_ID "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_file ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_FILE_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_FILE "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_path ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_PATH_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_PATH "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    }
    if( o->check_func != NULL ) {
        emitPrintf( depth, "%s( &(data->%s) );\n", o->check_func, o->value_field_name );
    }
    if( o->enumerate != NULL ) {
        ei = addEnumerator( o->enumerate, o->field_name );
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->enumerate->name );
        }
        emitPrintf( depth, "data->%s = OPT_ENUM%s_%s;\n", o->enumerate->name, optFlag.sid, ei->name );
        if( o->is_immediate ) {
            emitPrintf( depth, "%s( data, true );\n", o->immediate_func );
        }
    } else {
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->field_name );
        }
        if( o->is_negate ) {
            emitPrintf( depth, "if( %s( '-' ) ) {\n", FN_RECOG );
            emitPrintf( depth+1, "data->%s = false;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, false );\n", o->immediate_func );
            }
            emitPrintf( depth, "} else {\n" );
            emitPrintf( depth+1, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, true );\n", o->immediate_func );
            }
            emitPrintf( depth, "}\n" );
        } else {
            emitPrintf( depth, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth, "%s( data, true );\n", o->immediate_func );
            }
        }
    }
    if( o->is_code ) {
        emitPrintf( depth, "%s;\n", o->code );
    }
    if( flag.close_value_if ) {
        --depth;
        emitPrintf( depth, "}\n" );
    }
    emitSuccessCode( depth, control );
    if( o->is_prefix ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, "break;\n" );
    }
}

static void emitCodeTree( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->children != NULL ) {
        if( c->is_chain ) {
            emitCode( c->children, depth, (control & ~EC_CHAIN) | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        } else if( c->is_chain_root ) {
            emitCode( c->children, depth, control | EC_CHAIN | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~EC_CONTINUE );
            } else {
                emitSuccessCode( depth, control );
            }
        } else {
            emitCode( c->children, depth, control & ~EC_CHAIN );
            if( c->accept ) {
                emitAcceptCode( c, depth, control );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        }
    } else {
        if( c->option->chain != NULL ) {
            emitAcceptCode( c, depth, control );
        } else {
            emitAcceptCode( c, depth, control & ~EC_CONTINUE );
        }
    }
}

static void emitIfCode( CODESEQ *c, unsigned depth, flow_control control )
{
    if( IS_SENSITIVE( c ) ) {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG, c->s );
    } else {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG_LOWER, c->c );
    }
    emitCodeTree( c, depth + 1, control );
    emitPrintf( depth, "}\n" );
}

static void emitCodeBlk( CODESEQ *head, unsigned depth, flow_control control )
{
    CODESEQ *c;

    if( control & EC_CHAIN ) {
        emitPrintf( depth, "do {\n" );
        ++depth;
    }
    if( control & EC_SWITCH ) {
        emitPrintf( depth, "switch( " FN_GET_LOWER "() ) {\n" );
        ++depth;
        for( c = head; c != NULL; c = c->sibling ) {
            if( c->sel ) {
                if( IS_SENSITIVE( c ) ) {
                    emitPrintf( depth - 1, "case '%c':\n", c->s );
                } else {
                    emitPrintf( depth - 1, "case '%c':\n", c->c );
                }
                emitCodeTree( c, depth, control & ~EC_SWITCH );
            }
        }
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, FN_UNGET "();\n" );
    } else {
        for( c = head; c != NULL; c = c->sibling ) {
            if( c->sel ) {
                emitIfCode( c, depth, control );
            }
        }
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "break;\n" );
        --depth;
        emitPrintf( depth, "} while( ! " FN_END "() );\n" );
    }
}

static void emitCode( CODESEQ *head, unsigned depth, flow_control control )
{
    CODESEQ     *c;
    unsigned    count;

    count = 0;
    for( c = head; c != NULL; c = c->sibling ) {
        if( count == 0
          && ( IS_SENSITIVE( c )
          || (control & EC_CHAIN)
          && !c->is_chain ) ) {
            emitIfCode( c, depth, control );
            c->sel = false;
        } else {
            ++count;
            c->sel = true;
        }
    }
    if( count > 0 ) {
        if( count >= USE_SWITCH_THRESHOLD )
            control |= EC_SWITCH;
        emitCodeBlk( head, depth, control );
    }
}

static void outputFN_PROCESS( void )
{
    unsigned depth = 0;
    CODESEQ *codeseq;

    emitPrintf( depth, "bool " FN_PROCESS "%s( OPT_STORAGE%s *data )\n", optFlag.sid, optFlag.sid );
    emitPrintf( depth, "{\n" );
    ++depth;
    codeseq = genCode( optionList );
    emitCode( codeseq, depth, EC_NULL );
    emitPrintf( depth, "return( true );\n" );
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_INIT( void )
{
    OPTION *o;
    ENAME *en;
    INAME *ei;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_INIT "%s( OPT_STORAGE%s *data )\n", optFlag.sid, optFlag.sid );
    emitPrintf( depth, "{\n" );
    ++depth;
    emitPrintf( depth, "memset( data, 0, sizeof( *data ) );\n" );
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL
          && o->is_number
          && o->default_specified ) {
            emitPrintf( depth, "data->%s = %u;\n", o->value_field_name, o->number_default );
        }
    }
    for( en = enumList; en != NULL; en = en->next ) {
        if( !en->used )
            continue;
        ei = addEnumerator( en, "default" );
        emitPrintf( depth, "data->%s = OPT_ENUM%s_%s;\n", en->name, optFlag.sid, ei->name );
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_FINI( void )
{
    OPTION *o;
    unsigned depth;
    bool no_data;

    depth = 0;
    emitPrintf( depth, "void " FN_FINI "%s( OPT_STORAGE%s *data )\n", optFlag.sid, optFlag.sid );
    emitPrintf( depth, "{\n" );
    no_data = true;
    ++depth;
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( HAS_OPT_STRING( o ) ) {
                emitPrintf( depth, FN_CLEAN_STRING "( &(data->%s) );\n", o->value_field_name );
                no_data = false;
            } else if( HAS_OPT_NUMBER( o ) ) {
                emitPrintf( depth, FN_CLEAN_NUMBER "( &(data->%s) );\n", o->value_field_name );
                no_data = false;
            }
        }
    }
    if( no_data ) {
        emitPrintf( depth, "(void)data;\n" );
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static int usageCmp( const void *v1, const void *v2 )
{
    int     res;
    size_t  chain_len;
    OPTION  *o1 = *(OPTION **)v1;
    OPTION  *o2 = *(OPTION **)v2;
    char    *n1 = o1->name;
    char    *n2 = o2->name;

    res = 0;
    if( o1->usageChain != o2->usageChain ) {
        if( o1->usageChain == NULL ) {
            chain_len = o2->usageChain->len;
        } else if( o2->usageChain == NULL ) {
            chain_len = o1->usageChain->len;
        } else if( o1->usageChain->len > o2->usageChain->len ) {
            chain_len = o1->usageChain->len;
        } else {
            chain_len = o2->usageChain->len;
        }
        res = strnicmp( n1, n2, chain_len );
        if( res == 0 ) {
            res = strncmp( n1, n2, chain_len );
            if( res == 0 ) {
                if( o1->usageChain == NULL ) {
                    return( 1 );
                }
                if( o2->usageChain == NULL ) {
                    return( -1 );
                }
                n1 += chain_len;
                n2 += chain_len;
            }
        }
    }
    if( res == 0 ) {
        res = mystricmp( n1, n2 );
        if( res == 0 ) {
            return( strcmp( n1, n2 ) );
        }
    }
    if( res < 0 ) {
        return( -1 );
    } else {
        return( 1 );
    }
}

static char *catArg( char *arg, char *buf, char equal_char )
{
    for( ; *arg != '\0'; ++arg ) {
        if( equal_char != '\0' ) {
            if( *arg != '=' ) {
                *buf++ = *arg;
            } else {
                *buf++ = equal_char;
            }
        } else if( optFlag.no_equal ) {
            if( *arg != '=' ) {
                *buf++ = *arg;
            }
        } else if( optFlag.alternate_equal ) {
            if( *arg != '=' ) {
                *buf++ = *arg;
            } else {
                *buf++ = alternateEqual;
            }
        } else {
            *buf++ = *arg;
        }
    }
    *buf = '\0';
    return( buf );
}

static char *genOptionUsageStart( OPTION *o, char *buf, bool no_prefix )
{
    if( o->usageChain != NULL ) {
        if( !no_prefix ) {
            *buf++ = ' ';
            *buf++ = ' ';
        }
        strcpy( buf, o->name + o->usageChain->len );
        buf += strlen( buf );
    } else {
        *buf++ = '-';
        buf = cvtOptionSpec( buf, o->pattern, CVT_USAGE );
    }
    if( o->is_special ) {
        if( o->usage_argid != NULL ) {
            if( o->is_optional ) {
                buf = catArg( "[", buf, o->equal_char );
                buf = catArg( o->usage_argid, buf, '\0' );
                buf = catArg( "]", buf, '\0' );
            } else {
                buf = catArg( o->usage_argid, buf, '\0' );
            }
        }
    } else if( o->usage_argid != NULL ) {
        if( o->is_optional ) {
            buf = catArg( "[=", buf, o->equal_char );
            buf = catArg( o->usage_argid, buf, '\0' );
            buf = catArg( "]", buf, '\0' );
        } else {
            buf = catArg( "=", buf, o->equal_char );
            buf = catArg( o->usage_argid, buf, '\0' );
        }
    } else if( o->is_number ) {
        if( o->default_specified
          || o->is_optional ) {
            buf = catArg( "[=<num>]", buf, o->equal_char );
        } else {
            buf = catArg( "=<num>", buf, o->equal_char );
        }
    } else if( o->is_char ) {
        if( o->is_optional ) {
            buf = catArg( "[=<char>]", buf, o->equal_char );
        } else {
            buf = catArg( "=<char>", buf, o->equal_char );
        }
    } else if( o->is_id ) {
        if( o->is_optional ) {
            buf = catArg( "[=<id>]", buf, o->equal_char );
        } else {
            buf = catArg( "=<id>", buf, o->equal_char );
        }
    } else if( o->is_file ) {
        if( o->is_optional ) {
            buf = catArg( "[=<file>]", buf, o->equal_char );
        } else {
            buf = catArg( "=<file>", buf, o->equal_char );
        }
    } else if( o->is_path ) {
        if( o->is_optional ) {
            buf = catArg( "[=<path>]", buf, o->equal_char );
        } else {
            buf = catArg( "=<path>", buf, o->equal_char );
        }
    } else if( o->is_negate ) {
        buf = catArg( "[-]", buf, '\0' );
    }
    return( buf );
}

static bool usageOptionValid( OPTION *o )
{
    if( o->synonym != NULL )
        return( false );
    if( o->is_internal
      && (targetMask & targetDbgMask) == 0 )
        return( false );
    return( true );
}

static void emitQuotedString( FILE *fp, const char *str, const char *line_term, char *list_sep )
{
    size_t      len;
    const char  *q;
    const char  *s;

    fprintf( fp, "\"" );
    for( s = str; (q = strchr( s, '"' )) != NULL; s = q + 1 ) {
        // replace " with \"
        len = q - s;
        memcpy( tmpbuff, s, len );
        tmpbuff[len] = '\0';
        fprintf( fp, "%s\\\"", tmpbuff );
    }
    fprintf( fp, "%s%s\"%s", s, line_term, list_sep );
}

static void emitUsageH( void )
{
    static int  line_offs = 0;
    size_t      len;
    const char  *str;

    if( optFlag.rc ) {
        if( ufp != NULL ) {
            fprintf( ufp, "pick((%s+%d), ", optFlag.rc_macro, line_offs++ );
            str = getLangData( outputdata, LANG_RLE_ENGLISH );
            emitQuotedString( ufp, str, "", "" );
            fprintf( ufp, ", " );
            str = getLangData( outputdata, LANG_RLE_JAPANESE );
            if( !optFlag.out_utf8 ) {
                utf8_to_cp932( str, tmpbuff );
                str = tmpbuff;
            }
            emitQuotedString( ufp, str, "", "" );
            fprintf( ufp, ")\n" );
        }
    } else {
        str = getLangData( outputdata, optFlag.lang );
        len = strlen( str );
        if( maxUsageLen < len ) {
            maxUsageLen = len;
            strcpy( maxusgbuff, str );
        }
        if( ufp != NULL ) {
            emitQuotedString( ufp, str, optFlag.line_term, optFlag.list_sep );
            fprintf( ufp, "\n" );
        }
    }

}

static void emitUsageHQNX( void )
{
    const char *str;

    if( mfp != NULL ) {
        str = getLangData( outputdata, optFlag.lang );
        fprintf( mfp, "%s\n", str );
    }

}

static void process_output( process_line_fn *process_line )
{
    process_line();
    if( process_line == emitUsageH ) {
        emitUsageHQNX();
    }
}

static void expand_tab( const char *s, char *buf )
{
    int len;

    for( ; *s != '\0'; ++s ) {
        if( s[0] == '\\'
          && s[1] == 't' ) {
            ++s;
            for( len = 8; len-- > 0; ) {
                *buf++ = ' ';
            }
        } else {
            *buf++ = *s;
        }
    }
    *buf = '\0';
}

#define HEADER_LEFT_MARGIN   8

static void outputUsageGroupHeader( lang_data langdata, process_line_fn *process_line )
{
    wres_lang_id    lang;
    const char      *str;
    size_t          len;
    char            *buf;

    str = getLangData( langdata, LANG_RLE_ENGLISH );
    if( str != NULL ) {
        for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
            buf = GET_OUTPUT_BUF( lang );
            str = getLangData( langdata, lang );
            len = strlen( str );
            if( len < 80 ) {
                len = ( 80 - len ) / 2;
                if( len > HEADER_LEFT_MARGIN )
                    len = HEADER_LEFT_MARGIN;
                while( len-- > 0 ) {
                    *buf++ = ' ';
                }
            }
            strcpy( buf, str );
        }
        process_output( process_line );
    }
}

static void outputUsageLangdata( lang_data langdata, process_line_fn *process_line )
{
    wres_lang_id    lang;
    const char      *str;

    for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
        str = getLangData( langdata, lang );
        expand_tab( str, GET_OUTPUT_BUF( lang ) );
    }
    process_line();
}

static void outputUsageCommon( TEXT *t, process_line_fn *process_line )
{
    while( t != NULL ) {
        if( IS_SELECTED( t ) ) {
            outputUsageLangdata( t->lang_usage, process_line );
            if( process_line == emitUsageH ) {
                outputUsageLangdata( ( t->is_u ) ? t->lang_usageu : t->lang_usage, emitUsageHQNX );
            }
        }
        t = t->next;
    }
}

static bool createUsageChainHeaderPrefix( OPTION **o, char *buf, size_t max )
{
    size_t      len;
    USAGECHAIN  *ucn;
    char        *stop;

    stop = buf + max;
    ucn = (*o)->usageChain;
    *buf++ = '-';
    buf = cvtOptionSpec( buf, ucn->pattern, CVT_NAME );
    *buf++ = '{';
    len = 0;
    for( ; *o != NULL; o++ ) {
        if( (*o)->usageChain == ucn ) {
            if( len > 0 ) {
                *buf++ = ',';
            }
            buf = genOptionUsageStart( *o, buf, true );
            ++len;
        }
    }
    *buf++ = '}';
    *buf++ = ' ';
    while( buf < stop )
        *buf++ = ' ';
    *buf = '\0';
    return( buf == stop );
}

static void outputUsageChainHeader( OPTION **o, process_line_fn *process_line, size_t max )
{
    char            *buf;
    size_t          len;
    wres_lang_id    lang;
    const char      *str;

    if( createUsageChainHeaderPrefix( o, hdrbuff, max ) ) {
        for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
            buf = GET_OUTPUT_BUF( lang );
            strcpy( buf, hdrbuff );
            str = getLangData( (*o)->usageChain->lang_usage, lang );
            if( str != NULL ) {
                strcpy( buf + max, str );
            }
        }
    } else {
        str = getLangData( (*o)->usageChain->lang_usage, LANG_RLE_ENGLISH );
        if( str != NULL ) {
            for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
                buf = GET_OUTPUT_BUF( lang );
                for( len = max / 2; len-- > 0; )
                    *buf++ = ' ';
                str = getLangData( (*o)->usageChain->lang_usage, lang );
                if( str != NULL ) {
                    strcpy( buf, str );
                }
            }
            process_output( process_line );
        }
        for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
            strcpy( GET_OUTPUT_BUF( lang ), hdrbuff );
        }
    }
    process_output( process_line );
}

static char *createOptionPrefix( OPTION *o, char *buf, size_t max )
{
    char    *stop;

    stop = buf + max;
    buf = genOptionUsageStart( o, buf, false );
    while( buf < stop )
        *buf++ = ' ';
    if( o->usageChain != NULL ) {
        *buf++ = '-';
        *buf++ = ' ';
    }
    *buf = '\0';
    return( buf );
}

static void outputUsageOption( OPTION *o, process_line_fn *process_line, size_t max )
{
    char            *buf;
    size_t          len;
    wres_lang_id    lang;
    const char      *str;

    o->usage_used = true;
    len = createOptionPrefix( o, hdrbuff, max ) - hdrbuff;
    for( lang = 0; lang < LANG_RLE_MAX; lang++ ) {
        buf = GET_OUTPUT_BUF( lang );
        strcpy( buf, hdrbuff );
        str = getLangData( o->lang_usage, lang );
        strcpy( buf + len, str );
    }
    process_output( process_line );
}

static void outputUsageChain( OPTION **oo, size_t i, size_t count, process_line_fn *process_line, size_t max )
{
    USAGECHAIN  *ucn;

    ucn = oo[i]->usageChain;
    outputUsageChainHeader( &oo[i], process_line, max );
    for( ; i < count; i++ ) {
        if( oo[i]->usage_used )
            continue;
        if( oo[i]->usageChain == ucn ) {
            outputUsageOption( oo[i], process_line, max );
        }
    }
}

static bool checkUsageLength( size_t len )
{
    return( ( len / langMaxChar[optFlag.lang] ) > CONSOLE_WIDTH );
}

static void processUsage( process_line_fn *process_line, USAGEGROUP *ugr )
{
    unsigned    count;
    unsigned    i;
    size_t      max;
    size_t      len;
    OPTION      *o;
    OPTION      **oo;
    OPTION      **c;

    maxUsageLen = 0;
    max = 0;
    count = 0;
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->usageGroup != ugr )
            continue;
        if( usageOptionValid( o ) ) {
            ++count;
            len = genOptionUsageStart( o, tmpbuff, false ) - tmpbuff;
            if( max < len ) {
                max = len;
            }
        }
    }
    ++max;
    if( count > 0 ) {
        oo = calloc( count + 1, sizeof( OPTION * ) );
        c = oo;
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->usageGroup != ugr )
                continue;
            if( usageOptionValid( o ) ) {
                *c++ = o;
            }
        }
        *c = NULL;
        qsort( oo, count, sizeof( OPTION * ), usageCmp );

        for( i = 0; i < count; ++i ) {
            oo[i]->usage_used = false;
        }

        if( ugr != usageGroupList ) {
            outputUsageGroupHeader( ugr->lang_usage, process_line );
        }
        for( i = 0; i < count; ++i ) {
            if( oo[i]->usage_used )
                continue;
            if( oo[i]->usageChain != NULL ) {
                outputUsageChain( oo, i, count, process_line, max );
            } else {
                outputUsageOption( oo[i], process_line, max );
            }
        }
        free( oo );
        if( checkUsageLength( maxUsageLen ) ) {
            fprintf( stderr, "usage message exceeds %u chars\n%s\n", CONSOLE_WIDTH, maxusgbuff );
        }
    }
}

static void outputUsage( process_line_fn *process_line )
{
    USAGEGROUP  *ugr;

    outputUsageCommon( titleList, process_line );

    for( ugr = usageGroupList; ugr != NULL; ugr = ugr->next ) {
        processUsage( process_line, ugr );
    }

    outputUsageCommon( footerList, process_line );
}

static void outputUsageH( void )
{
    outputUsage( emitUsageH );
}

static void emitUsageB( void )
{
    size_t len;
    const char *str;

    str = getLangData( outputdata, optFlag.lang );
    if( optFlag.lang == LANG_RLE_JAPANESE ) {
        if( !optFlag.out_utf8 ) {
            utf8_to_cp932( str, tmpbuff );
            str = tmpbuff;
        }
    }
    len = strlen( str ) + 1;
    fwrite( str, len, 1, bfp );
    if( maxUsageLen < len ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, str );
    }
}

static void dumpInternational( void )
{
    char        fname[16];
    LocaleUsage usage_header;

    if( optFlag.international ) {
        for( optFlag.lang = LANG_RLE_FIRST_INTERNATIONAL; optFlag.lang < LANG_RLE_MAX; optFlag.lang++ ) {
            sprintf( fname, "usage%02u." LOCALE_DATA_EXT, optFlag.lang );
            bfp = fopen( fname, "wb" );
            if( bfp == NULL ) {
                fail( "cannot open international file for write\n" );
            }
            memset( &usage_header, 0, sizeof( usage_header ) );
            usage_header.header.code = LS_Usage;
            usage_header.header.signature = LS_Usage_SIG;
            fwrite( &usage_header, offsetof( LocaleUsage, data ), 1, bfp );

            outputUsage( emitUsageB );

            fputc( 0, bfp );
            fclose( bfp );
            bfp = NULL;
        }
    }
}

static void closeFiles( void )
{
    if( gfp != NULL )
        fclose( gfp );
    if( mfp != NULL )
        fclose( mfp );
    if( ofp != NULL )
        fclose( ofp );
    if( pfp != NULL )
        fclose( pfp );
    if( ufp != NULL ) {
        fclose( ufp );
    if( ofpg != NULL )
        fclose( ofpg );
    }
}

static void initUTF8( void )
{
    if( !optFlag.out_utf8 ) {
        qsort( cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
    }
}

static char *ReadIndirectFile( char *name )
/*****************************************/
{
    char        *str;
    FILE        *fp;
    size_t      len;
    char        ch;

    str = NULL;
    fp = fopen( name, "rb" );
    if( fp != NULL ) {
        fseek( fp, 0, SEEK_END );
        len = ftell( fp );
        fseek( fp, 0, SEEK_SET );
        str = malloc( len + 1 );
        fread( str, 1, len, fp );
        str[len] = '\0';
        fclose( fp );
        // go through characters changing \r, \n etc into ' '
        for( ; (ch = *str) != '\0'; str++ ) {
            if( ch == 0x1A ) {      // if end of file
                *str = '\0';        // - mark end of str
                break;
            }
            if( ch != ' '
              && myisspace( ch ) ) {
                *str = ' ';
            }
        }
    }
    return( str );
}

static char *getFileName( char *str, char *name )
/***********************************************/
{
    char        ch;

    SKIP_SPACES( str );
    if( *str == '\"' ) {
        str++;
        while( (ch = *str) != '\0' ) {
            str++;
            if( ch == '"' ) {
                break;
            }
            if( ch == '\\'
              && *str == '"' ) {
                ch = *str++;
            }
            *name++ = ch;
        }
    } else {
        while( *str != '\0'
          && !myisspace( *str ) ) {
            *name++ = *str++;
        }
    }
    *name = '\0';
    return( str );
}

static char *ProcessOption( char *s, char *option_start )
/*******************************************************/
{
    switch( *s++ ) {
    case 'c':
        optFlag.list_sep = ",";
        return( s );
    case 'i':
        optFlag.international = true;
        return( s );
    case 'l':
        if( *s++ == '=' ) {
            optFlag.lang = strtol( s, &s, 10 );
            return( s );
        }
        break;
    case 'n':
        if( *s == 'n' ) {
            s++;
            optFlag.line_term = "\\n";
        } else {
            optFlag.line_term = "\\0";
        }
        return( s );
    case 'p':
        optFlag.parser_only = true;
        return( s );
    case 'q':
        optFlag.quiet = true;
        return( s );
    case 'r':
        if( *s++ == 'c'
          && *s++ == '=' ) {
            optFlag.rc = true;
            SKIP_SPACES( s );
            optFlag.rc_macro = option_start;
            while( *s != '\0' ) {
                if( myisspace( *s ) ) {
                    s++;
                    break;
                }
                *option_start++ = *s++;
            }
            *option_start = '\0';
            return( s );
        }
        break;
    case 't':
        optFlag.report_missing_data = true;
        return( s );
    case 'u':
        if( *s == '=' ) {
            s = getFileName( s + 1, option_start );
            mfp = fopen( option_start, "wb" );
            if( mfp == NULL ) {
                fail( "cannot open '%s' for output", option_start );
            }
            return( s );
        } else if( *s++ == 't'
          && *s++ == 'f'
          && *s++ == '8' ) {
            optFlag.out_utf8 = true;
            return( s );
        }
        break;
    case 'x':
        if( *s == '=' ) {
            s++;
            SKIP_SPACES( s );
            optFlag.sid = option_start;
            while( *s != '\0' ) {
                if( myisspace( *s ) ) {
                    s++;
                    break;
                }
                *option_start++ = *s++;
            }
            *option_start = '\0';
            return( s );
        }
        break;
    }
    printf( "Unknown option: %s\n", option_start );
    return( NULL );
}

static void initOptions( void )
/*****************************/
{
     optFlag.line_term = "";
     optFlag.list_sep = "";
     optFlag.sid = "";
}

static bool ProcessOptions( char *str )
/*************************************/
{
    char        name[PATH_MAX];
    char        *fstr;
    bool        rc;
    char        *p;
    targmask    mask;

    rc = 0;
    fstr = NULL;
    name[0] = '\0';
    while( *str != '\0' ) {
        SKIP_SPACES( str );
        if( *str == '@' ) {
            str = getFileName( str + 1, name );
            str = getenv( name );
            if( str == NULL ) {
                str = fstr = ReadIndirectFile( name );
            }
        }
        if( *str == '\0' ) {
            continue;
        }
        if( *str == '-' ) {
            str = ProcessOption( str + 1, str );
            if( str == NULL ) {
                rc = true;
                break;
            }
        } else {  /* collect file name */
            switch( fno++ ) {
            case 0:
                str = getFileName( str, name );
                gfp = initFILE( name, "r" );
                break;
            case 1:
                str = getFileName( str, name );
                ofp = initFILE( name, "w+" );
                break;
            case 2:
                str = getFileName( str, name );
                pfp = initFILE( name, "w+" );
                break;
            case 3:
                str = getFileName( str, name );
                ufp = initFILE( name, "w+" );
                p = "any";
                if( (targetAnyMask = findTarget( p )) == 0 ) {
                    fail( "invalid target name '%s'\n", p );
                }
                p = "dbg";
                if( (targetDbgMask = findTarget( p )) == 0 ) {
                    fail( "invalid target name '%s'\n", p );
                }
                p = "unused";
                if( (targetUnusedMask = findTarget( p )) == 0 ) {
                    fail( "invalid target name '%s'\n", p );
                }
                targetMask |= targetAnyMask;
                break;
            case 4:
                str = getFileName( str, name );
                ofpg = initFILE( name, "w+" );
                break;
            default:
                p = name;
                while( *str != '\0' ) {
                    if( myisspace( *str ) )
                        break;
                    *p++ = *str++;
                }
                *p = '\0';
                if( *name != '\0' ) {
                    if( (mask = findTarget( name )) == 0 ) {
                        fail( "invalid target name '%s'\n", name );
                    }
                    targetMask |= mask;
                }
                break;
            }
        }
    }
    free( fstr );
    return( rc );
}

#define NUM_FILES   5

int main( int argc, char **argv )
{
    bool    ok;
    int     i;

    setlocale( LC_ALL, "C" );
    ok = true;
    initTargets();
    initOptions();
    for( i = 1; i < argc; i++ ) {
        if( ProcessOptions( argv[i] ) ) {
            ok = false;
            break;
        }
    }
    if( !ok
      || fno < NUM_FILES ) {
        ok = false;
        dumpUsage();
    } else {
        initUTF8();
        initUsageGroup();
        readInputFile();
        assignCodeChainToOptions();
        assignUsageChainToOptions();
        checkForMissingUsages();
        stripUselessOptions();
        initOptionFields();

        if( errcount > 0 ) {
            ok = false;
        } else {
            outputInit();
            startParserH();
            outputFN_PROCESS();
            if( !optFlag.parser_only ) {
                outputFN_INIT();
                outputFN_FINI();
            }
            finishParserH();
            outputUsageH();
            dumpInternational();
            outputFini();
        }
    }
    closeFiles();
    finiTargets();
    if( ok )
        return( EXIT_SUCCESS );
    return( EXIT_FAILURE );
}
