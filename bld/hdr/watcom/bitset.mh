///////////////////////////////////////////////////////////////////////////
// FILE: bitset (Container for N bits)
//
:keep CPP_HDR
:include crwatcnt.sp
//
// Description: This header is part of the C++ standard library. It defines
//              a template that provides a container for bits. The usual
//              bit manipulation operators are provided.
///////////////////////////////////////////////////////////////////////////
#ifndef _BITSET_INCLUDED
#define _BITSET_INCLUDED

:include readonly.sp

:include cpponly.sp

#ifndef _CSTDDEF_INCLUDED
 #include <cstddef>
#endif

#ifndef _STRING_INCLUDED
 #include <string>
#endif

#ifndef _STDEXCEPT_INCLUDED
 #include <stdexcep>
#endif

#ifndef _IOSFWD_INCLUDED
 #include <iosfwd>
#endif

namespace std {

    template< size_t N > class bitset {
    public:
        class reference {
            friend class bitset;

            reference( unsigned long *data, unsigned int bitpos );
        public:
           ~reference( );
            reference& operator=( bool x );
            reference& operator=( const reference& x );
            bool operator~( ) const;
            operator bool( ) const;
            reference& flip( );

        private:
            unsigned long *data;
            unsigned int bitpos;
        };

        // Constructors
        bitset( );
        bitset( unsigned long val );

#if _NEVER
        template< class Ch, class Tr, class A >
        explicit bitset( const basic_string< Ch, Tr, A > &str,
                         typename basic_string< Ch, Tr, A >::size_type pos = 0,
                         typename basic_string< Ch, Tr, A >::size_type n = basic_string< Ch, Tr, A >::npos);
#endif

        // Bitset operations
        bool operator[] ( size_t pos ) const;
        reference operator[] ( size_t pos );

        bitset< N >& operator&=( const bitset< N >& s );
        bitset< N >& operator|=( const bitset< N >& s );
        bitset< N >& operator^=( const bitset< N >& s );

        bitset< N >& operator<<=( size_t s );
        bitset< N >& operator>>=( size_t s );

        bitset< N >& set( );
        bitset< N >& set( size_t pos, int val = 1 );

        bitset< N >& reset( );
        bitset< N >& reset( size_t pos );

        bitset< N >& flip( );
        bitset< N >& flip( size_t pos );

        bitset< N > operator~( ) const
          { return bitset< N >( *this ).flip( ); }
        bitset< N > operator<<( size_t n ) const
          { return bitset< N >( *this ) <<= n; }
        bitset< N > operator>>( size_t n ) const
          { return bitset< N >( *this ) >>= n; }

        unsigned long to_ulong( ) const;

#if _NEVER
        template< class Ch, class Tr, class A > basic_string< Ch, Tr, A > to_string( ) const;
#endif
        size_t count( ) const;
        size_t size( ) const { return N; }

        bool operator==( const bitset< N >& s ) const;
        bool operator!=( const bitset< N >& s ) const;
        bool test( size_t pos ) const;
        bool any( ) const;
        bool none( ) const;

    private:
        unsigned long data[ ( N + ( ( sizeof ( unsigned long ) * 8 ) - 1 ) ) / ( sizeof ( unsigned long ) * 8 ) ];
        unsigned int datasize;
    };

    // *********************************
    // Members of bitset< N >::reference
    // *********************************

    template< size_t N >
    inline bitset< N >::reference::reference( unsigned long *data, unsigned int bitpos ) : data( data ), bitpos( bitpos )
      { }

    template< size_t N >
    inline bitset< N >::reference::~reference( )
      { }

    template< size_t N >
    inline bitset< N >::reference &bitset< N >::reference::operator=( bool x )
    {
        if( x ) {
            data[ bitpos / ( sizeof ( unsigned long ) * 8 ) ] |= 1 << ( bitpos % ( sizeof ( unsigned long ) * 8 ) );
        } else {
            data[ bitpos / ( sizeof ( unsigned long ) * 8 ) ] &= ~ ( 1 << ( bitpos % ( sizeof ( unsigned long ) * 8 ) ) );
        }

        return *this;
    }

    template< size_t N >
    inline
    bitset< N >::reference &
      bitset< N >::reference::operator=( const reference& x )
    {
        *this = x;
        return *this;
    }

    template< size_t N >
    inline bool bitset< N >::reference::operator~( ) const
    {
        return ~ ( bool )( *this );
    }

    template< size_t N >
    inline bitset< N >::reference::operator bool( ) const
    {
        return ( data[bitpos / ( sizeof ( unsigned long ) * 8 ) ] & ( 1 << ( bitpos % ( sizeof ( unsigned long ) * 8 ) ) ) ) != 0;
    }

    template< size_t N >
    inline bitset< N >::reference &bitset< N >::reference::flip( )
    {
        *this = ! *this;
        return *this;
    }

    // **********************
    // Members of bitset< N >
    // **********************

    template< size_t N >
    bitset< N >::bitset( ) : datasize( ( N + ( ( sizeof ( unsigned long ) * 8 ) - 1 ) ) / ( sizeof ( unsigned long ) * 8 ) )
    {
        for( int i = 0; i < datasize; i++ ) {
            data[ i ] = 0;
        }
    }

    template< size_t N >
    bitset< N >::bitset( unsigned long val ) : datasize( ( N + ( ( sizeof ( unsigned long ) * 8 ) - 1 ) ) / ( sizeof ( unsigned long ) * 8 ) )
    {
        data[0] = val;

        for( int i = 1; i < datasize; i++ ) {
            data[ i ] = 0;
        }
    }

#if _NEVER
    template< size_t N >
    template< class Ch, class Tr, class A >
    bitset< N >::bitset( const basic_string< Ch, Tr, A >& str,
                                  typename basic_string< Ch, Tr, A >::size_type pos = 0,
                                  typename basic_string< Ch, Tr, A >::size_type n = basic_string< Ch, Tr, A >::npos )
    {
        // TODO: implement me.
    }
#endif
    template< size_t N >
    bool bitset< N >::operator[] ( size_t pos ) const
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::operator []" );

        return ( data[ pos / ( sizeof ( unsigned long ) * 8 ) ] & ( 1 << ( pos % ( sizeof ( unsigned long ) * 8 ) ) ) ) != 0;
    }


    template< size_t N >
    bitset< N >::reference bitset< N >::operator [] ( size_t pos )
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::operator []" );
        return bitset< N >::reference( data, pos );
    }

    template< size_t N >
    bitset< N > &bitset< N >::operator&=( const bitset< N >& s )
    {
        for( int i = 0; i < datasize; i++ ) {
            data[ i ] &= s.data[ i ];
        }
        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::operator|=( const bitset< N >& s )
    {
        // it is assumed here, that "overflowed" bits are not set
        for( int i = 0; i < datasize; i++ ) {
            data[ i ] |= s.data[ i ];
        }
        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::operator^=( const bitset< N >& s )
    {
        // it is assumed here, that "overflowed" bits are not set
        for( int i = 0; i < datasize; i++ ) {
            data[ i ] ^= s.data[ i ];
        }
        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::operator<<=( size_t s )
    {
        if( s == 0 ) return *this;
        if( s > N ) s = N;

        for( int i = N-1; i >= s; i-- ) {
            (*this)[ i ] = (bool)((*this)[i - s]);
        }

        for( int i = 0; i < s; i++ ) {
            (*this)[ i ] = false;
        }

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::operator>>=( size_t s )
    {
        if( s == 0 ) return *this;
        if( s > N ) s = N;

        for( int i = 0; i < N-s; i++ ) {
            (*this)[ i ] = (bool)((*this)[i + s]);
        }

        for( int i = N-s; i < N; i++ ) {
            (*this)[ i ] = false;
        }

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::set( )
    {
        for( int i = 0; i < N; i++ ) {
            (*this)[ i ] = 1;
        }

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::set( size_t pos, int val )
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::set" );

        (*this)[pos] = (val != 0);

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::reset( )
    {
        for( int i = 0; i < datasize; i++ ) {
            data[ i ] = 0;
        }

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::reset( size_t pos )
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::reset" );

        (*this)[pos] = false;

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::flip( )
    {
        for( int i = 0; i < N; i++ ) {
            (*this)[ i ] = ! (*this)[ i ];
        }

        return *this;
    }

    template< size_t N >
    bitset< N > &bitset< N >::flip( size_t pos )
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::flip" );

        (*this)[pos].flip( );

        return *this;
    }

    template< size_t N >
    unsigned long bitset< N >::to_ulong( ) const
    {
#if _NEVER
        if( ( sizeof ( unsigned long ) * 8 ) < N )
            throw std::overflow_error( "bitset::to_ulong" );
#endif
        return data[0];
    }

#if _NEVER
    template< size_t N >
    template< class Ch, class Tr, class A > basic_string< Ch, Tr, A > bitset< N >::to_string( ) const
    {
        // TODO: implement me.
    }
#endif

    template< size_t N >
    size_t bitset< N >::count( ) const
    {
        int cnt = 0;

        for( int i = 0; i < N; i++ ) {
            if( (*this)[ i ] == true )
                cnt++;
        }

        return cnt;
    }

    template< size_t N >
    bool bitset< N >::operator==( const bitset< N >& s ) const
    {
        for( int i = 0; i < datasize; i++ ) {
            if( data[ i ] != s.data[ i ] )
                return false;
        }

        return true;
    }

    template< size_t N >
    bool bitset< N >::operator!=( const bitset< N >& s ) const
    {
        for( int i = 0; i < datasize; i++ ) {
            if( data[ i ] != s.data[ i ] )
                return true;
        }

        return false;
    }

    template< size_t N >
    bool bitset< N >::test( size_t pos ) const
    {
        if( pos >= N )
            throw std::out_of_range( "bitset::test" );

        return (*this)[pos];
    }

    template< size_t N >
    bool bitset< N >::any( ) const
    {
        for( int i = 0; i < datasize; i++ ) {
            if( data[ i ] != 0 )
                return true;
        }

        return false;
    }

    template< size_t N >
    bool bitset< N >::none( ) const
    {
        return !any( );
    }

#if _NEVER
    template< size_t N >
    bitset< N > operator&( const bitset< N >& s1, const bitset< N >& s2 )
    {
        bitset< N > tmp = s1;
        tmp &= s2;
        return tmp;
    }

    template< size_t N >
    bitset< N > operator|( const bitset< N >& s1, const bitset< N >& s2 )
    {
        bitset< N > tmp = s1;
        tmp |= s2;
        return tmp;
    }

    template< size_t N >
    bitset< N > operator^( const bitset< N >& s1, const bitset< N >& s2 )
    {
        bitset< N > tmp = s1;
        tmp ^= s2;
        return tmp;
    }
#endif

#if _NEVER
    template< class Ch, class Tr, size_t N >
    basic_istream< Ch, Tr > &operator<< ( basic_ostream< Ch, Tr >& os, const bitset< N >& x )
    {
        // TODO: implement me.
    }

    template< class Ch, class Tr, size_t N >
    basic_istream< Ch, Tr > &operator>> ( basic_ostream< Ch, Tr >& os, const bitset< N >& x )
    {
        // TODO: implement me.
    }
#endif

} // namespace std

#endif
