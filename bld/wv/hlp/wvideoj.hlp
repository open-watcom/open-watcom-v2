All help topics must be stored in order of the ASCII collating sequence.
Each topic is identified by a header consisting of a string of 4 colons
followed by the topic name.  Any alphabetic characters must be entered in
upper-case.
::::AUTOCAD
AutoCADアプリケーションのデバッグ
---------------------------------

VIDEOを使用して、AutoCAD開発システム（ADS）アプリケーションおよびAutoCADデバ
イスインタフェース（ADI）アプリケーションをデバッグすることができます。VIDEO
を動作する前に、以下のような行を"ACAD.ADS"ファイルに追加してください。この行
は"ADSHELP.EXP"ファイルに対するパスを指定するものです。

        C:＼WATCOM＼BIN＼ADSHELP.EXP

"ACAD.ADS"ファイルには、AutoCADが起動するときにAutoCADによってロードされるAu
toCADアプリケーションのリストが入っています。"ADSHELP.EXP"は、VIDEOがAutoCAD
アプリケーションをデバッグするのに必要なAutoCADアプリケーションです。

ADSアプリケーションをデバッグするには、特殊なトラップファイル"ADS.TRP"も使用
しなければなりません。

+------------------------------------------------------------------------+
|　WVIDEO/TRap=ADS                                                       |
+------------------------------------------------------------------------+

２台のモニタを設定していない場合には、"swap"オプションも指定しなければなりま
せん。

+------------------------------------------------------------------------+
|　WVIDEO/TRap=ADS/Swap                                                  |
+------------------------------------------------------------------------+

AutoCAD実行可能ファイルを指定しなかったことに注意してください。これは、トラ
ップファイル"ADS.TRP"がAutoCADを自動的にロードするからです。これでVIDEOに入
ったはずです。ここで、以下に示すデバッガコマンドを入力して、AutoCADアプリケ
ーションに対するシンボリックデバッグ情報が入ったファイル名を指定します。WATC
OMストリップユーティリティを使用した場合には、これは実行可能ファイルまたはシ
ンボリックデバッグ情報ファイルです。

+------------------------------------------------------------------------+
|　DBG>ads file_spec                                                     |
+------------------------------------------------------------------------+

これでAutoCADに入ったはずです。AutoLISPからAutoCADアプリケーションをロードす
ると、デバッガに入り、プログラムのソースがソースウィンドウに表示されるはずで
す。"ADS.DBG"ファイルには、AutoCADを起動し、指定した実行可能ファイルからデバ
ッグ情報をロードし、アプリケーションに対するコードおよびデータセレクタ値に基
づいてアドレス情報を再配置するデバッガコマンド・シーケンスが入っています。こ
れでAutoCADアプリケーションをデバッグする準備ができました。
AutoCADアプリケーションが大きい場合には、"ADS"デバッガコマンドファイルを呼び
出すときに、メモリの制約のためにデバッガが実行可能ファイルからデバッグ情報を
ロードできなかったことを示すエラーが表示されることがあります。"no memory for
 debugging information"または"no memory for debugging information - increase
 dynamic memory"というエラーメッセージが表示された場合には、デバッガの"dynam
ic"オプションを使用して動的メモリ容量を増やしてください（デフォルトは40Kです
）。下に動的メモリ容量を60Kに増やす例を示します。

例：
        C>wvideo /trap=ads /swap /dynamic=60k
::::BREAK
+------------------------------------------------------------------------+
|　Break                                                                 |
|　  /Activate "*"|index_expr|"/"addr_expr　　                           |
|    /Deactivate "*"|index_expr|"/"addr_expr　                           |
|　  [/Set]    addr_expr [cmd]_list]                                     |
|　  /Clear    "*"|index_expr|"/"addr_expr                               |
+------------------------------------------------------------------------+

「ブレークポイント」は、現在の環境を調べるために実行を中断させたいアプリケー
ション中の場所を定義します。ブレークポイントを定義するには/Set修飾子を、削除
するには/Clear修飾子を、イネーブルするには/Activate修飾子を、そしてディスエ
ーブルするには/Deactivate修飾子をそれぞれ使用します。/Set修飾子を使って、最
大７個のブレークポイントを設定できます。修飾子が指定されていない場合には、/S
et修飾子が指定されたものと見なされます。

例：
        DBG>break/set main_
        DBG>break main_

上の例では、２つの等価なコマンドが示されています。グローバルシンボルmain_で
定義されたメモリ位置にブレークポイントが定義され、自動的に使用可能になります
。メモリ内の特定の位置にはブレークポイントを１つしか定義できません。「設定さ
れた」ブレークポイントは、SourceウィンドウおよびAssemblyウィンドウにおいて左
向き矢印（←）で示されます。

ブレークポイントはモジュール名と行番号で定義することもできます。

例：
        DBG>break calendar@36

このコマンドを入力すると、ブレークポイントを示す矢印（←）がその行の先頭に現
れます。

Sourceウィンドウでは行番号が表示されます。ソース行番号を表示するためには、ソ
ース行情報が使用可能でなければなりません。

        1.　モジュールをコンパイルしたときに、コンパイラオプション"d1"または
        　　"d2"を指定しておかなければなりません。
        2.　アプリケーションをリンクするときに、そのモジュールが入っているオ
        　　ブジェクトファイルの名前の前に"debug lines"または"debug all"リン
        　　カオプションを指定しておかなければなりません。

モジュールが検査中の現在のモジュールの場合には、モジュール名を指定する必要は
ありません。

例：
        DBG>break @36

ブレークポイントはモジュール名およびシンボル名で定義できます。

例：
        DBG>break calendar@Box

行番号の場合と同様に、モジュールが検査中の現在のモジュールなら、モジュール名
を指定する必要はありません。

例：
        DBG>break Box

シンボル名だけを指定する場合には、"@"は必要ありません。"@"は行番号と定数を区
別するためのものなので、行番号には常に必要です（たとえば、"break 36"は"break
 cs:36"と等価です）。

マウスを使ってブレークポイントを設定またはクリアすることもできます。設定する
場合は、希望のソース行またはアセンブラ行をマウスでダブルクリックします。もう
１度同じ行をダブルクリックすると、ブレークポイントがクリアされます。

実行スレッドがアクティブなブレークポイントに出会うと、アプリケーションの実行
が中断され、デバッガに入ります。ブレークポイントを定義したときに１つまたは複
数のデバッガコマンドを指定した場合には、最初にそれらのデバッガコマンドが実行
されます。Break/Setコマンドでアドレス式の後にあるコマンド並びは、次のように
定義されます。

        cmd_list ::= "{"[cmd]{";"[cmd]}"}"

これは、単にVIDEOコマンド行を中括弧の中に入れただけです。

注：

        1.　有効なアドレス式の詳細については、「VIDEO式の処理」の章を参照し
        　　てください。

        2.　コマンドの中にGoコマンドがある場合には、アプリケーションの実行を
        　　再開することができます。そうでない場合には、デバッガはユーザに新
        　　しいコマンドの入力を促します。

                例：
                        DBG>do look_count = 0
                        DBG>break/set lookup { do look_count++; go/keep }

        　　"lookup"ルーチンに入るたびに、デバッガはユーザ定義の変数look_cou
        　　ntをインクリメントして、実行を再開します（ユーザ定義の一時ブレー
        　　クポイントは保持されます）。アプリケーションの実行が終了したら、
        　　Printコマンドを用いてlook_countの現在値を調べて、"lookup"ルーチ
        　　ンの実行回数を判定することができます。

        3.　Breakコマンドに対して引数を指定していない場合には、現在定義され
        　　ているブレークポイントが表示されます。最初に表示されるのはブレー
        　　クポイント番号１、２番目に表示されるのはブレークポイント番号２と
        　　いうように表示されます。これらはブレークポイント・インデックスと
        　　呼ばれます。アクティブなブレークポイントは"active"属性で、アクテ
        　　ィブでないブレークポイントは"plain"属性で表示されます。属性につ
        　　いては、Paintコマンドの説明を参照してください。

        4.　ブレークポイントを使用可能、使用不可、またはクリアする場合は、ブ
        　　レークポイント・インデックスまたはブレークポイント・アドレスを指
        　　定しなければなりません。ブレークポイント・インデックスとして"*"
        　　を指定した場合には、全ブレークポイントが影響を受けます。

                例：
                        DBG>break/set main_; break/deactivate 1
                        DBG>break/set main_; break/deactivate /main_

        　　どちらの例とも、ブレークポイントを設定してから、使用不可にします
        　　。最初の例では、"main_"に設定されるブレークポイント以外にブレー
        　　クポイントが設定されていない場合だけ（これがブレークポイント番号
        　　１となるので）、このブレークポイントが使用不可になります。２番目
        　　の例は、どのような状況でも"main_"のブレークポイントを使用不可に
        　　する方法を示しています。

                例：
                        DBG>break/activate 2; break/deactivate 1

        　　ブレークポイント番号２が使用可能となり、ブレークポイント番号１が
        　　使用不可となります。

        5.　指定するアドレスは、シンボル名またはモジュール名と行番号にする必
        　　要はありません。

                例：
                        DBG>break es:di

        　　ES:DIレジスタ対の内容で指定される場所にブレークポイントが設定さ
        　　れます。

                例：
                        DBG>break/deactivate /bx

        　　アドレスがCS:BXレジスタ対の内容で指定されるブレークポイントを使
        　　用不可にします。

        6.　最も近い時点で調べたソースコードの行またはアセンブラコードの行に
        　　対応するアドレスを"."で指定できます。次の画面は、現在ハイライト
        　　表示されているソース／アセンブラ行にブレークポイントを設定する例
        　　を示しています。
::::C++_OPERATORS
C++文法のVIDEOサポートには、「C文法の演算子」のセクションで説明されている
Cの演算子がすべて含まれています。これに加えて、C++プログラミング言語
マニュアルで説明されているいろいろなC++の演算子をサポートしています。

おそらく、VIDEOのC++文法のサポートで、追加された機能を説明する最前の方法は、
例を示すことだと思います。以下のC++プログラムは、デバッグの例として、C++の
いろいろな機能を含んでいます。

例:
  // DBG_EXAM.C: C++ デバッグの例のプログラム

  struct BASE {
      int a;
      BASE() : a(0) {}
      ~BASE(){}
      BASE & operator =( BASE const &s )
      {
          a = s.a;
          return *this;
      }
      virtual void foo()
      {
          a = 1;
      }
  };

  struct DERIVED : BASE {
      int b;
      DERIVED() : b(0) {}
      ~DERIVED() {}
      DERIVED & operator =( DERIVED const &s )
      {
          a = s.a;
          b = s.b;
          return *this;
      }
      virtual void foo()
      {
          a = 2;
          b = 3;
      }
      virtual void foo( int )
      {
      }
  };

  void use( BASE *p )
  {
      p->foo();
  }

  void main()
  {
      DERIVED x;
      DERIVED y;

      use( &x );
      y = x;
  }

このプログラムをコンパイル・リンクすると、ほとんどの包括的なデバッグ情報が
実行可能ファイルに含まれます。


C++文法の式のサポート
---------------------
main関数の中のuse( &s )関数の呼び出しまで、一度に１文ずつトレースすると、
C++サポートのいくつかを見ることができます。PRINTコマンドを使って、変数 x を
表示できます。

例:
  DBG>print x
  {__ctor_DERIVED=0x01D8:0x0046FC18,
   __vfptr=0x01D8:0x0046E448,
   b=0,
   __ctor_DERIVED=0x01D0:0x0046B1C1,
   __dtor_DERIVED=0x01D0:0x0046B14A,
   __operator_EQUAL=0x01D0:0x0046B106,
   foo=0x01D0:0x0046B0CF,
   foo=0x01D0:0x0046B0AA,
   a=0,
   __operator_EQUAL=0x01D8:0x0046FC18,
   __ctor_BASE=0x01D8:0x0046FC18,
   __vfptr=0x01D8:0x0046E448,
   __ctor_BASE=0x01D0:0x0046B29B,
   __dtor_BASE=0x01D0:0x0046B23A,
   foo=0x01D0:0x0046B0CF
  }

教示されるフィールドの多くは、派生クラス DERIVEDに含まれるコンストラクタ、
デストラクタ、仮想関数演算子関数に関連するポインタです。(ここの出力は、
32ビットC++コンパイラのものです。)DERIVEDクラスは、C++コンパイラによって、
「生成された」多くの名前を含んでいます。

xのフィールドを表示することもできます。

例:
  DBG>print x.a

aの値は、下のC++のコンストラクタの文の結果、0であるはずです。

      BASE() : a(0) {}

PRINT /WINDOWコマンドを使って、ウィンドウの中に変数 x の構造体を表示する
こともできます。

例:
  DBG>print/win x

これは、驚くほどのことではなく、Cのアプリケーションをデバッグするとき、
同じ操作が可能です。


C++文法の中での曖昧性の解決
---------------------------
前のセクションの例を続行して、use関数の呼び出しの中にステップ実行で入って
いって、p->foo()関数呼び出しまで、実行します。そして、次のようにコマンドを
入力します。

例:
  DBG>examine/source foo

この時点では、foo関数は、どのfoo関数であるかが曖昧であるので、foo関数の
一覧表を表示するウィンドウが現れ、foo関数を選択できるようになっています。
見たいfoo関数を１つ、選んでください。

このとき、pが本当はDERIVED型である変数 x へのポインタであることに気づかれ
たかもしれません。xのすべてのフィールドを表示するためには、以下のように
型をキャストする事ができます。

例:
  DBG>print/win *(DERIVED *)p


C++文法の"this"演算子
---------------------
前のセクションの例を続行して、ステップ実行でp->fooの中に入っていって、
b=3の文のところまで実行します。以下の例で示すように"this"演算子を使用
できます。

例:
  DBG>print this->a
  DBG>print/win *this


C++文法の"operator" 関数
------------------------
前のセクションの例を続行して、下のようなコマンドを使用して、C++演算子の
ソースコードを調べることができます。

例:
  DBG>ex/s operator =

上の例のようにすると、DERIVEDクラスのoperator =関数のソースコードを調べら
れます。

      DERIVED & operator =( DERIVED const &s )
      {
          a = s.a;
          b = s.b;
          return *this;
      }


C++文法のスコープ演算子"::"
---------------------------
スコープ演算子"::"を使用して、調べたいオブジェクトを特定することができます。
前のセクションの例を続行して、次のようにコマンドを入力します。

例:
  DBG>ex/s base::foo

ある場合には、これは、曖昧性を解決する手助けにもなります。上の例では、
クラスBASEの関数fooのソースコードを調べることができます。

      virtual void foo()
      {
          a = 1;
      }

ここにいくつかの興味深い例を挙げます。

例:
  DBG>ex/s derived::foo
  DBG>ex/s derived::operator =

この２つの例の内の最初の方は、曖昧な参照が残るので、曖昧さを解決するために、
プロンプト・ウィンドｗが表示されます。


C++文法のコンストラクタ／デストラクタ
-------------------------------------
オブジェクトあるいはクラスのコンストラクタ／デストラクタを調べることも
できます。前のセクションの例を続行して、次のコマンドを入力します。

例:
  DBG>ex/s base::base
  DBG>ex/s base::~base

上の例では、クラスBASEのコンストラクタとデストラクタのソースコードを
調べることができます。
::::CALL
+------------------------------------------------------------------------+
|　Call[/Far|/Interrupt|/Near                                            |
|　     start_addr_expr["("[arg_list]")"["/"|print_list]]                |
+------------------------------------------------------------------------+

Callコマンドを使用して、システム中の任意のルーチンを呼び出すことができます。
ユーザは呼び出すルーチンの開始アドレス式を指定します。式は、呼び出すルーチン
のセグメントとオフセットに評価されなければなりません。ルーチンには以下の３種
類があります。

        /Far start_addr_expr["("[arg_list]")"["/"|print_list]]

                "far"ルーチンは、"far return"命令（RETF）を使用して、最終的
                に呼出し側に戻るルーチンです。16ビットモードでは、32ビットの
                リターンアドレス（セグメントおよびオフセット）がデバッガによ
                ってスタック上に置かれるので、ルーチンはデバッガに戻ります。
                32ビットモードでは、64ビットのリターンアドレス（セグメントお
                よびオフセット）がデバッガによってスタック上に置かれるので、
                ルーチンはデバッガに戻ります。"far"コールおよびリターンメカ
                ニズムはビッグコードモデル（ミディアム、ラージ、およびヒュー
                ジ）で使用されます。

        /Interrupt start_addr_expr["("[arg_list]")"["/"|print_list]]

                "interrupt"ルーチンは、割込みリターン命令（IRET、IRETD）を使
                用して、最終的に呼出し側に戻るルーチンです。16ビットモードで
                は、32ビットのリターンアドレス（セグメントおよびオフセット）
                とフラグレジスタの現在の内容がデバッガによってスタック上に置
                かれるので、割込みルーチンはデバッガに戻ります。32ビットモー
                ドでは、64ビットのリターンアドレス（セグメントおよびオフセッ
                ト）とフラグレジスタの現在の内容がデバッガによってスタック上
                に置かれるので、割込みルーチンはデバッガに戻ります。なお、割
                込みルーチンは割込み番号ではなく、アドレスで呼び出されること
                に注意してください。

        /Near start_addr_expr["("[arg_list]")"["/"|print_list]]

                "near"ルーチンは、"near return"命令（RET）を使用して、最終的
                に呼出し側に戻るルーチンです。16ビットモードでは、16ビットの
                リターンアドレス（オフセット）がデバッガによってスタック上に
                置かれるので、ルーチンはデバッガに戻ります。32ビットモードで
                は、32ビットのリターンアドレス（オフセット）がデバッガによっ
                てスタック上に置かれるので、ルーチンはデバッガに戻ります。
                "near"コールおよびリターンメカニズムはスモールコードモデル（
                スモール、コンパクト、およびフラット）で使用されます。

Ｃａｌｌ引数並び
----------------

呼び出すルーチンに対して引数並びを指定できます。指定する場合には、以下の形式
を使います。

        arg_list ::= [arg_expr{","arg_expr}]

        arg_expr ::= ["/"reg_name|"/"reg aggregate|"//"]expr

例：
        DBG>call rtn0( )
        DBG>call rtn1( arg1 )
        DBG>call rtn5( arg1, arg2, arg3, arg4, arg5 )

これらの例は引数の指定方法を示しています。引数は、デフォルトの場合には、標準
引数受渡し規則を使ってルーチンに渡されます。16ビットモードにおける16ビット数
量の標準引数受渡し規則は次のとおりです。

引数１  レジスタAXに渡たされる
引数２  レジスタDXに渡される
引数３  レジスタBXに渡される
引数４　レジスタCXに渡される
引数Ｎ　スタック上に渡される（N>=5）

32ビットモードにおける32ビット数量の標準引数受渡し規則は次のとおりです。

引数１　レジスタEAXに渡される
引数２　レジスタEDXに渡される
引数３　レジスタEBXに渡される
引数４　レジスタECXに渡される
引数Ｎ　スタック上に渡される（N>=5）

これらのデフォルトは、Set Callコマンドを使って変更することができます。または
、別の引数受渡し規則を指定したい場合には、"/reg_name"（レジスタ）修飾子、"/r
eg_aggregate"（レジスタグループ）修飾子、または"//"（スタック）修飾子を使用
できます。

例：
        DBG>call stdrtn(/ax p1,/dx p2,/bx p3,/cx p4,// p5)
                または
        DBG>call stdrtn(/eax p1,/edx p2,/ebx p3,/ecx p4,// p5)

上の２例は実際には、16ビットモードと32ビットモードの標準引数受渡し規則によっ
てレジスタ内またはスタック上に引数を配置する方法を示しています。

例：
        DBG>call longtostr( /[dx ax] long_arg )

この16ビットモードの例は、32ビットの引数をレジスタ集合体に渡すことができるこ
とを示しています。レジスタ集合体については、「VIDEO式の処理」の章で説明して
あります。

例：
        DBG>call printf( //arg1, //arg2, //arg3 )

この例は、すべての引数をスタックに渡す方法を示しています。引数はスタック上に
右から左の順にプッシュされます。そのため、（実際の呼出しの前に）"arg1"がスタ
ックの一番上に、"arg2"がその次、という順で置かれます。

引数に式を使うことができます。すべての式を評価した後に、引数はレジスタに割り
当てられたり、スタック上に置かれます。

例：
        DBG>call rtn( /ax dx+1, /bx ax-cx, /cx 123)

式"dx+1"、"ax-cx"、および"123"が評価されます。これらの式の結果はレジスタAX、
BX、CXにそれぞれ割り当てられます。もし式"ax-cx"を評価する前に123をCXレジスタ
に割り当てたなら、まったく違った結果になります。

すべてのレジスタ内容はデバッガによって保存されます。したがって、引数受渡し規
則の選択や被呼出しルーチンによってレジスタ内容が永久に変更されることはありま
せん。しかし、被呼出しルーチンは、メモリ位置を変更する、入出力を実行するなど
の副作用を与えることがあります。

戻り値の処置
------------
被呼出しルーチンがデバッガに戻った後に、以下の３つの処理のどれかを行うことが
できます。

        1.　デフォルトでは、ルーチンが返すAXレジスタ（16ビットモード）または
        　　EAXレジスタ（32ビットモード）の内容はDialogueウィンドウに表示さ
        　　れます。Set Callコマンドを使ってこのデフォルトを変更することがで
        　　きます。

        2.　"/"を使って、ルーチンが値を返さないように指示することができま
        　　す。この場合には何も表示されません。

        3.　フォーマット文字列と式の並びを指定できます。print_listの構文はPr
        　　intコマンドの構文に類似しています。式が評価され、その結果はDialo
        　　gueウィンドウに表示されます。

例：
        DBG>Call test1() /
        DBG>Call test2( s, t ) ax, bx, cx
        DBG>Call test3( a,b,c ){Results were %i,%i,%u}dx,ax,tag

一行目の例では、ルーチンがAXレジスタの有用な情報を返さないので、このレジスタ
の表示を抑制しています。２行目の例では、AXレジスタ、BXレジスタ、およびCXレジ
スタの内容はデフォルトフォーマットで表示されます。３行目の例では、指定したフ
ォーマット文字列を使用して、DXレジスタおよびAXレジスタの内容と変数"tag"が表
示されます。フォーマット文字列の詳細については、Printコマンドの説明を参照し
てください。

現在のレジスタセットの一部を、呼び出すルーチンの戻り値で更新してみましょう。

例：
        DBG>Call/far test() _ax=ax, _bx=bx;/ax=_ax;/bx=_bx

この例では、"far"コールを使って"test"ルーチンを呼び出します。レジスタ内容は
ルーチンの呼出しによる影響を受けないので、AXレジスタおよびBXレジスタに返さ
れた値を変数_axと_bxに割り当てます。その後のデバッガコマンドは、保存されたこ
れらの値を現在のレジスタセットのAXレジスタおよびBXレジスタに割り当てます。VI
DEOを使用すると、一意な名前を指定して、それに値を割り当てるだけで新しい変数
を定義することができます。

次の例では、16ビット「リアルモード」でBIOSルーチンを呼び出す方法を示します。

例：
        DBG>c/int %0: (4*0x10) (/ah 3, /bh 0) {ct=%x,rc=%x}cx,dx

この例では、IBMのBIOS"Video I/O"割込みルーチン（INT 0x10）を呼び出して、ビデ
オページ０（BH=0）に対する現在のカーソルの種類と位置を取得します。％演算子
は、0:40から0:43の位置に格納されたセグメント：オフセット対を生成します。カー
ソルの種類は"CX"レジスタに返され、カーソルの行とカラムは"DX"レジスタに返され
ます。そのため、この２つのレジスタの内容を16進フォーマットで表示するようデバ
ッガに指示しています。
::::COMMAND_FILES
VIDEOに添付されているコマンドファイルについて以下の項で説明します。

DOSまたはOS/2システムでは、WATCOMコンパイラパッケージの"BINB"ディレクトリが
PATH環境変数に入っているか確認してください。このディレクトリにはVIDEOに添付
されたコマンドファイルが入っています。VIDEOはPATH環境変数を使用して、コマン
ドファイルを見つけます。

        1.      カレントディレクトリ
        2.      PATH環境変数にリストされたパス

INvokeまたは<コマンドを使用して、コマンドファイル内のコマンドを実行します。
Set Implicitコマンドを使用して、コマンドファイルの自動呼出しを「オン」または
「オフ」にすることができます。「オン」になっている場合には、入力されたコマン
ドがVIDEOのコマンドセットのどれとも一致しなければ、VIDEOはコマンドファイルを
呼び出そうとします。コマンドファイル処理の詳細については、「VIDEOコマンド」
の章のINvokeコマンドの説明を参照してください。


AutoCAD ADS(またはADI)アプリケーション用のセットアップ (ads.dbg)
----------------------------------------------------------------
構文：　[Invoke | <] ads <symbol_file_name>

要約：　このコマンドファイルは、AutoCAD ADS（またはADI）アプリケーションに対
        するデバッグセッションをセットアップします。シンボリック情報は"symbo
        l_file_name"に格納されます。

        ADSアプリケーションの作成に関する詳細については、"AutoCAD Developmen
        t System - Programmer's Reference"を参照してください。また、"WATCOM
        C/386 User's Guide"または"WATCOM FORTRAN 77/386 User's Guide"の「Aut
        oCADアプリケーションの作成」の章も参照してください。詳細は、"WATCOM
        VIDEO User's Guide"の「AutoCADアプリケーションのデバッグ」の章を参照
        してください。

大きなＡｓｓｅｍｂｌｙウィンドウの作成（ａｓｍ．ｄｂｇ）
-------------------------------------------------------
構文：　[Invoke | <] asm

要約：　このコマンドファイルは画面の大部分を使用するAssemblyウィンドウを作成
        します。Registerウィンドウは画面の右側に置かれます。Stackウィンドウ
        は定義されますが、画面上には置かれません。小さなSourceウィンドウおよ
        びDialogueウィンドウも作成されます。デバッグレベルは"assembly"に設定
        されます。


カウント後のブレーク（ｂｃｎｔ．ｄｂｇ）
---------------------------------------
構文：　[INvoke | <] bcnt <count> <address>

要約：　このコマンドファイルは、指定した"address"を"count"回繰り返した後、実
        行をブレークするのに使用されます。ブレーク後、ブレークポイントはクリ
        アされます。

例：    bcnt 1000 StageD

        ルーチン"StageD"を1000回呼び出した後、実行は停止されます。


条件によるブレーク（ｂｉｆ．ｄｂｇ）
-----------------------------------
構文：　[INvoke | <] bif <expr> <address>

要約：　このコマンドファイルは、"expr"が真（結果が0以外の値）の場合に指定さ
        れた"address"で実行をブレークするのに使用されます。

例：　  bif{ax==0} malloc

        bif{eax==0} malloc

        0バイトのメモリを要求する"malloc"ルーチンが呼び出されると、常に実行
        は停止されます。引数は16ビットモードではレジスタAXに、または32ビット
        モードではレジスタEAXに渡されることに注意してください。

カウントブレーク（ｃｎｔｂｒｋｓ．ｄｂｇ）
-----------------------------------------
構文：　[INvoke | <] cntbrks <address>

要約：　<address>の実行回数をカウントします。

例：    cntbrks StageD

        反復回数を数えるための変数名が画面に表示されます。この変数は、VIDEO
        のPrintコマンドを使って、いつでも照会することができます。プログラム
        をGoコマンドによって起動すると、ブレークするたびにプログラム画面上に
        "cnt$xxxx=n"のメッセージが表示されます。


ウィンドウカラーのセットアップ（ｃｏｌｏｕｒｓ．ｄｂｇ）
-------------------------------------------------------
構文：　[INvoke | <] colours

要約：　このコマンドファイルは、いろいろなデバッガウィンドウのカラーを設定し
        ます。ユーザの必要に合わせてカラーを選択することができます。デバッガ
        がカラーモニタ上で動作している場合には、いつでもスタートアップ"profi
        le.dbg"コマンドファイルによってこのコマンドファイルは呼び出されます。

参照：　grays.dbg


メモリの設定（ｆｉｌｌ．ｄｂｇ）
-------------------------------
構文：　[INvoke | <] fill <address> <value> <length>

要約：　このコマンドファイルは、あるメモリ領域に特定の値を設定するのに使用さ
        れます。開始アドレスは<address>で指定し、設定するバイト値は<value>で
        指定します。そして、メモリ領域の大きさのバイト数は<length>で指定しま
        す。

例：    fill es:0 ff 100

        アドレスES:0から始まる256バイトのメモリ領域にバイト値0xFFを設定しま
        す。この例では、基数は16と見なしています。

ＦｏｘＰｒｏ外部ルーチン用のセットアップ（ｆｏｘ．ｄｂｇ）
---------------------------------------------------------
構文：　[INvoke | <] fox <symbol_file_name>

要約：　このコマンドファイルは、FoxPro外部ルーチンに対するデバッグセッション
        をセットアップします。シンボリック情報は"symbol_file_name"に格納され
        ます。

        BreakPoint()の呼出しをユーザの外部ルーチンにコーディングしてあるか確
        認してください。この呼出しは最初のセグメントになければなりません。

例：    外部ルーチンを起動します（たとえば、? hello()）。BreakPoint()の呼出
        しによってデバッガに入ります。シンボリックデバッグを開始するには、次
        のようなコマンドを入力してください。

        例：
                DBG>fox hello.plb

        FoxPro外部ルーチンの作成に関する詳細については、FoxPro External Rout
        ine APIドキュメントを参照してください。


グレイスケールモニタに対するウィンドウカラーのセットアップ
----------------------------------------------------------
構文：　[INvoke | <] grays

要約：　このコマンドファイルは、グレイスケールモニタ上のいろいろなデバッガウ
        ィンドウのカラーを設定します。ユーザの必要に合わせて選択することがで
        きます。グレイスケールモニタを持っている場合には、このコマンドファイ
        ルを呼び出さなければなりません。

参照：　colours.dbg


ＡｓｓｅｍｂｌｙおよびＳｏｕｒｃｅウィンドウの作成（ｍｉｘ．ｄｂｇ）
-------------------------------------------------------------------
構文：　[INvoke | <] mix

要約：　このコマンドファイルは、画面の大部分を使用するSourceウィンドウとAsse
        mblyウィンドウを同じ大きさで作成します。Registerウィンドウは画面の右
        側に置かれます。Stackウィンドウは定義されますが、画面上には置かれま
        せん。小さなDialogueウィンドウも作成されます。デバッグレベルは"mix"
        に設定されます。

ＶＩＤＥＯ初期設定ファイル（ｐｒｏｆｉｌｅ．ｄｂｇ）
---------------------------------------------------
構文：　[INvoke | <] profile

要約：  これはVIDEO初期設定ファイルです。ユーザの必要に合わせてカスタマイズ
        できます。出荷時のファイルは以下のような初期設定を行います。

        　　1. メニューバーをオンにします。
        　　2.　デバッグレベルはできるだけ、ソースレベルデバッグの"mix"に設
                定し、ソース行情報が使用できないときにはアセンブラレベルデバ
                ッグに設定します。
        　　3.　シンボル名一致パターンは"*"、"*_"、および"_*"に設定します。
        　　4.　自動コマンドファイル呼出しをイネーブルにします。デバッガは識
                別不能なコマンドが入力されると、同じ名前で、拡張子"DBG"の付
                いたコマンドファイルを実行しようとします。
        　　5.　10進数（0n）、16進数（0x）および８進数（0）に対する基数指定
                子を定義します。
        　　6.　いろいろなウィンドウのデフォルトカラーを設定します。
        　　7.　Commandウィンドウ、Registerウィンドウ、Stackウィンドウ、Fpu
                ウィンドウ、Dialogueウィンドウ、Memoryウィンドウ、およびThre
                adウィンドウのサイズを定義します。ウィンドウサイズは画面上で
                使用可能な画面行数に基づいて定義されます。"SRC"コマンドファ
                イルを呼び出して、SourceウィンドウとDialogueウィンドウを画面
                上に置きます。
        　　8.　"View"、"src"、"mix"、"asm"、"flip"コマンドをユーザ定義可能
                な"User"ポップダウンメニューに追加します。なお、"src"、"mix"
                、および"asm"はVIDEOコマンドファイルの名前です。さらに、FORT
                RANアプリケーションの場合には、"new;gofmain"もメニューに追加
                されます。Ｃアプリケーションの場合には、"new;gomain"もメニュ
                ーに追加されます。
        　　9.　ファンクションキー"F1"を押すと、「ヘルプ」システムが呼び出さ
                れるように定義します。
                ファンクションキー"F4"を押すたびに、FPUウィンドウが画面に追
                加または画面から削除されるよう定義します。
                ファンクションキー"F5"を押すと、"register -1"コマンドが発行
                されるように設定します。
                ファンクションキー"F6"を押すと、"register +1"コマンドが発行
                されるように設定します。
                ファンクションキー"F7"を押すと、"WIND"コマンドファイルが呼び
                出されるよう定義します。このキーは、"SRC"、"MIX"、および"ASM
                "コマンドファイルを使用して、SourceウィンドウおよびAssembly
                ウィンドウを異なるサイズで順に変更します。
                ファンクションキー"F8"を押すたびに、メニューバーをオンまたは
                オフにするよう定義します。
                ファンクションキー"F10"押すと、Altキーを押して離したときと同
                じようにメニュー選択を活動化させるように定義します。
                ファンクションキー"Alt/F9"を押すと、カーソルがSourceウィンド
                ウへ移動するように定義します。
                ファンクションキー"Alt/F10"を押すと、カーソルがAssemblyウィ
                ンドウへ移動するように定義します。
        　　10. Assemblyウィンドウに対してマクロホットキーを定義します。定義さ
                れるキーは次のとおりです。
                'G'     {g}　実行再開
                'g'     {g dbg$code}　現在のハイライト表示行まで実行を継続
                'i'     {ｔ/a/i}　シングルショット・トレース"into"
                'n'     {ｔ/a/i}　シングルショット・トレース"next"
                ' '     {ｔ/a/o}　シングルショット・トレース"over"
                'b'     {b dbg$code}　現在のハイライト表示行にブレークポイン
                        ト設定
                'c'     {b/c/dbg$code}　現在のハイライト表示行のブレークポイ
                        ントを削除
        　　11. Sourceウィンドウに対してマクロホットキーを定義します。定義さ
                れるキーは次のとおりです。
                'v'     {view}　現在のモジュールのソースコードの検査
                'G'     {g}　実行再開始
                'g'     {g dbg$code}　現在のハイライト表示行まで実行を継続
                'i'     {ｔ/s/i}シングルショット・トレース"into"
                'n'     {ｔ/s/i}シングルショット・トレース"next"
                ' '     {ｔ/s/i}シングルショット・トレース"over"
                'b'     {b dbg$code}　現在のハイライト表示行にブレークポイン
                        トを設定
                'c'     {b/c/dbg$code}　現在のハイライト表示行のブレークポイ
                        ントを削除
        　　12. FPUウィンドウに対してマクロホットキーを定義します。定義され
                るキーは次のとおりです。
                'b'     {set fpu binary}　表示モードを16進数に設定
                'd'     {set fpu decimal}　表示モードを10進数に設定
        　　13. MS Windowsアプリケーションの場合には、WinMainまたはFWinMain
                のエントリポイントの１つが定義されていると、VIDEOは"go WinMa
                in"（Ｃ）コマンドまたは"go FWinMain"（FORTRAN）コマンドを発
                行します。
        　　14. FORTRANアプリケーションの場合には、VIDEOは"go fmain"コマンド
                を発行します。それ以外の場合には、"main"エントリポイントが定
                義されていると、VIDEOは"go main"コマンドを発行します。

ＤＯＳメモリコントロールブロックの設定（ｒｅｓｉｚｅ．ｄｂｇ）
-------------------------------------------------------------
構文：　[INvoke | <] resize <new_size>

要約：　（DOSのみ）このコマンドファイルは、PSPが入ったDOSメモリコントロール
        ブロックを新しいサイズに設定します。PSP値はデバッガ変数_dbg@dbg$psp
        に記録されています。DOSは、アプリケーションが起動する前に、残ってい
        る全メモリをアプリケーションに与えます。通常、アプリケーションは使用
        しないメモリをDOSに返さなければなりません。アプリケーションが未使用
        のメモリをDOSに返さず、ユーザがVIDEOのSYSTEMコマンドを使ってサブプロ
        セスを起動したい場合に、このコマンドファイルを使用できます。この場合
        には、サブプロセスを起動する前にメモリをDOSに返さなければなりません。

例：    resize 0x1000

        現在のPSPが入っているメモリコントロールブロックを64Kバイトにリセット
        します。

+------------------------------------------------------------------------+
|　警告！　不正または不適当なサイズを指定すると、コンピュータシステム    |
|　が停止することがあります。あまり小さな値を指定すると、誤動作を起こ    |
|　します。                                                              |
+------------------------------------------------------------------------+

現在のルーチンからのリターン（ｒｅｔｕｒｎ．ｄｂｇ）
---------------------------------------------------
構文：　[INvoke | <] return

要約：　このコマンドファイルを使用して、現在のルーチンから戻ることができます
        。アプリケーションの実行は、RETURN命令に達するまで続けられます。呼出
        し側ルーチンに戻るには、RETURN命令を追加して実行を進めます。


スローモーションコード・アニメーション（ｓｌｏｗ．ｄｂｇ）
---------------------------------------------------------
構文：　[INvoke | <] slow <delay>

要約：　このコマンドファイルを使用して、プログラムの実行をスローモーションで
        行うことができます。<delay>値は必ず指定しなければなりません。<delay>
        の値を大きくすればするほど、プログラムの実行速度は遅くなります。

現在のセットアップの保存（ｓａｖｅ．ｄｂｇ）
-------------------------------------------
構文：　[INvoke | <] save

要約：　現在のデバッガコンフィギュレーションを作成し直すのに必要なデバッガコ
        マンドの入った、setup.dbgという名前のファイルを作成します。

大きなＳｏｕｒｃｅウィンドウの作成（ｓｒｃ．ｄｂｇ）
---------------------------------------------------
構文：　[INvoke | <] src

要約：　このコマンドファイルは画面の大部分を使用するSourceウィンドウを作成し
        ます。小さなDialogueウインドウも作成されます。Registerウィンドウまた
        はStackウィンドウは画面から取り除かれます。AssemblyウィンドウはDialo
        gueウィンドウの下に隠されます。デバッグレベルは"source"に設定されま
        す。このコマンドファイルはスタートアップ"profile.dbg"コマンドファイ
        ルによって呼び出されます。

ファンクションキートグルの定義（ｔｏｇｇｌｅ．ｄｂｇ）
-----------------------------------------------------
構文：　[INvoke | <] toggle <pfkey_number> <command_string_1>
        <command_string_2>

要約：　このコマンドファイルは、２つのコマンドを切り替えるようにPFキーを設定
        します。

例：    toggle 10 {set menu on}{set menu off}

        メニューバーのオンとオフを切り替えるようにファンクションキー"F10"を
        定義します。

ＣＡＬＬコマンドからの出力の検査（ｖｃ．ｄｂｇ）
-----------------------------------------------
構文：　[INvoke | <] vc <call_address_and_arguments>

要約：　このコマンドファイルはViewコマンドを使用して、Callコマンドによって呼
        び出されたルーチンからの標準出力を調べます。ファイル"stdout.tmp"が作
        成されます。

例：    vc DumpTree(HeadNode)

ルーチンのソースコードの調査（ｖｒ．ｄｂｇ）
-------------------------------------------
構文：　[INvoke | <] vr <routine_name>

要約：　このコマンドファイルはViewコマンドを使用して、指定されたルーチンのソ
        ースコードを調べます。

例：    vr main

ウィンドウ管理ユーティリティ関数（ｗｉｎｄ．ｄｂｇ）
---------------------------------------------------
構文：　[INvoke | <] wind

要約：　このコマンドファイルは、_dbg@dbg$wind_split変数の状態により"SRC"、"A
        SM"、または"MIX"コマンドファイルのどれかを呼び出します。これは主に、
        他のコマンドファイルまたはファンクションキーによって呼び出されるユー
        ティリティ・コマンドファイルです。
::::C_OPERATORS
VIDEOはＣ言語のほとんどの演算子をサポートし、便利なように追加の演算子のセッ
トを含んでいます。"WATCOM C Language Reference"に、これらの多くの演算子につ
いて説明しています。

VIDEO式の構文はＣ言語の構文と似ています。演算子は、優先順位の低いものから高
いものへ順に示されています。同じ行にある演算子は同じ優先順位を持っています。

                                                        優先順位が低い
    代入演算子
        =   +=  -=  *=  /=  %=  &=  |=  ^=  <<= >>=
    論理演算子
        ||
        &&
    ビット演算子
        |
        ^
        &
    関係演算子
        ==      !=
        <   <=  <  >=
    シフト演算子
        <<  >>
        算術演算子
        +   -
        *   /   %
        単項演算子
        +   -   〜  !   ++  --  &   *   %
        sizeof unary_expr
        sizeof(type_name)
        (type_name) unary_expr
        [type_name] unary_expr
        ?
    バイナリアドレス演算子
        :
                                                        優先順位が高い

括弧を使用して、式の評価を順序付けることができます。

以上の演算子の他に、いくつかの一次式演算子もサポートされています。以下の演算
子は、演算が行われるオブジェクトを識別するために使用されます。

[]      添字、部分文字列
()      関数呼出し
.       フィールド選択
->      ポインタを使用したフィールド選択

以降の項では、上記の演算子について説明します。

Ｃ文法の代入演算子
-----------------
=       代入：右側の値を左側のオブジェクトに代入します。
+=      加算代入：左側のオブジェクトの値に右側の値を加えます。
-=      減算代入：左側のオブジェクトの値から右側の値を引きます。
*=      乗算代入：左側のオブジェクトの値に右側の値を掛けます。
/=      除算代入：左側のオブジェクトの値を右側の値で割ります。
%=      剰余代入：左側のオブジェクトをMOD（左、右）で更新します。結果は、左
        側のオブジェクトの値を右側の値で割ったときの剰余になります。
&=      ビット論理積：左側のオブジェクトのビットと右側の値のビットの論理積を
        とります。
|=      ビット論理和：左側のオブジェクトのビットと右側の値のビットの論理和を
        とります。
^=      ビット排他的論理和：左側のオブジェクトのビットと右側の値のビットの排
        他的論理和をとります。
<<=     左シフト：左側のオブジェクトのビットを右側の値の分だけ左へシフトしま
        す。
>>=     右シフト：左側のオブジェクトのビットを右側の値の分だけ右へシフトしま
        す。左側のオブジェクトが符号なしとして記述されている場合には、空いた
        上位ビットはゼロで埋められます。左側のオブジェクトが符号付きとして記
        述されている場合には、符号ビットで空いた上位ビットを埋めます。VIDEO
        では、レジスタを符号なし項目として扱います。

Ｃ文法の論理演算子
------------------
&&      論理積：左の値と右の値の論理積をとります。左右どちらか一方の値が０の
        場合には、結果は０になります。そうでない場合には、結果は１です。
||      論理和：左の値と右の値の論理和をとります。左右どちらか一方の値が０で
        ない場合には、結果は１になります。そうでない場合には、結果は０です。
        左の値が０でない場合には、右の式は評価されません（短絡式評価）。

Ｃ文法のビット演算子
--------------------
&       ビット論理積：左の値のビットと右の値のビットの論理積をとります。
|       ビット論理和：左の値のビット右の値のビットの論理和をとります。
^       ビット排他的論理和：左の値のビットと右の値のビットの排他的論理和をと
        ります。

Ｃ文法の関係演算子
------------------
==      等しい：左側の値が右側の値に等しい場合には、結果は１になります。そう
        でない場合には、結果は０です。
!=      等しくない：左側の値が右側の値に等しくない場合には、結果は１になりま
        す。そうでない場合には、結果は０です。
<       より小さい：左側の値が右側の値よりも小さい場合には、結果は１になりま
        す。そうでない場合には、結果は０です。
<=      等しいか、より小さい：左側の値が右側の値に等しいか、より小さい場合に
        は、結果は１になります。そうでない場合には、結果は０です。
>       より大きい：左側の値が右側の値よりも大きい場合には、結果は１になりま
        す。そうでない場合には、結果は０です。
>=      等しいか、より大きい：左側の値が右側の値に等しいか、より大きい場合に
        は、結果は１になります。そうでない場合には、結果は０です。

Ｃ文法の算術／論理シフト演算子
------------------------------
<<      左シフト：左側の値のビットを右側の値が示す分だけ左へシフトします。
>>      右シフト：左側の値のビットを右側の値が示す分だけ右へシフトします。左
        側のオブジェクトが符号なしとして記述されている場合には、空いた上位ビ
        ットはゼロで埋めます。左側のオブジェクトが符号付きとして記述されてい
        る場合には、符号ビットで空いた上位ビットを埋めます。VIDEOでは、レジ
        スタを符号なし項目として扱います。

Ｃ文法の２項算術演算子
----------------------
+       加算：右側の値を左側の値に加えます。
-       減算：左側の値から右側の値を引きます。
*       乗算：左側の値に右側の値を掛けます。
/       除算：左側の値を右側の値で割ります。
%       剰余：右側の値に対する左側の値の剰余を生成します。結果は、左側の値を
        右側の値で割ったときの剰余になります。

Ｃ文法の単項算術演算子
----------------------
+       正符号：結果は右側の値です。
-       負符号：結果は右側の値の符号反転です。
~       ビット補数：結果は右側の値のビット補数です。
!       論理補数：右側の値が０の場合には、結果は１になります。そうでない場合
        には結果は０です。
++      インクリメント：前置演算子と後置演算子の両方がサポートされています。
        （++xのように）オブジェクトが右側にある場合には、そのオブジェクトが
        参照される前に１つインクリメントされます。（x++のように）オブジェク
        トが左側にある場合には、そのオブジェクトが参照された後に１つインクリ
        メントされます。
--      デクリメント：前置演算子と後置演算子の両方がサポートされています。
        （--xのように）オブジェクトが右側にある場合には、そのオブジェクトが
        参照される前に１つデクリメントされます。（x--のように）オブジェクト
        が左側にある場合には、そのオブジェクトが参照された後に１つデクリメン
        トされます。
&       アドレス：結果は、右側のオブジェクトのアドレス（セグメント：オフセッ
        ト）です（例：&main）。
*       間接参照：結果は、右側の値でアドレス指定した位置に格納されている値で
        す（例：*(ds:100)、*string.loc）。入力情報がない場合には、nearポイン
        タを生成します。オペランドにセグメントが指定されていない場合には、ス
        タックセグメントと見なされます。

    (SS:00FE) = FFFF
var:(SS:0100) = 0152
    (SS:0102) = 1240
    (SS:0104) = EEEE

以下の例では、16ビットモードの場合にはDS:152から、32ビットモードの場合にはDS:
12400152からメモリ位置がそれぞれ表示されます。

例：
        DBG>examine/byte *100

%       アドレスの値：結果は、右側の値でアドレス指定した位置に格納されている
        値です（例：%(ds:100)、%string.loc）。入力情報がない場合には、farポ
        インタを生成します。オペランドにセグメントが指定されていない場合には
        、スタックセグメントと見なされます。

    (SS:00FE) = FFFF
var:(SS:0100) = 0152
    (SS:0102) = 1240
    (SS:0104) = EEEE

以下の例では、16ビットモードの場合には1240:0152から、32ビットモードの場合に
はEEEE:12400152からメモリ位置がそれぞれ表示されます。

例：
        DBG>examine/byte %100

この演算子はＣ言語にはないので注意してください。

Ｃ文法の特殊な単項演算子
------------------------
sizeof unary_expression

        例：
            DBG>print sizeof tyme
            2（32ビットモードでは４）
            DBG>print sizeof *tyme
            18

sizeof(type_name)

        例：
            DBG>print sizeof( struct tm )
            18

(type_name) unary_expression　型変換演算子（type_name）は、項目の型を別の型
へ変換するために使用します。"type_name"の構文は次のとおりです。

            type_name ::= type_spec {["near"|"far"|"huge"]"*"}
            type_spec ::= typedef_name
                     | "struct" structure_tag
                     | "union" union_tag
                     | "enum" enum_tag
                     | scalar_type { scalar_type }
            scalar_type ::= "char"|"int"|"float"|"double"
                     | "short"|"long"|"signed"|"unsigned"

        例：
            DBG>print (float) 4
            4.
            DBG>print (int) 3.1415926
            3

[type_name] unary_expression　強制型変換演算子を使用すると、強制的にVIDEOが
メモリ参照を特定の型の値として扱うようにすることができます。型指定は、上記の
例のように括弧で囲みます。基本型には、char（文字型、８ビット）、short（短整
数型、16ビット）、long（長整数型、32ビット）、float（単精度浮動小数点型、32
ビット）、およびdouble（倍精度浮動小数点型、64ビット）があります。キーワード
のshortまたはlongで修飾されていない場合には、int型は、16ビットアプリケーショ
ンでは16ビットに、32ビットアプリケーションでは32ビットになります（386システ
ムおよび486システム）。文字型、短整数型、および長整数型は、符号付き項目また
は符号なし項目として扱うことができます。文字型のデフォルトは、符号なしです。
整数型のデフォルトは、符号付きです。

        例：
            [char]                  （デフォルトは符号なし）
            [signed char]
            [unsigned char]
            [int]                   （デフォルトは符号付き）
            [short]                 （デフォルトは符号付き）
            [short int]             （デフォルトは符号付き）
            [signed short int]
            [long]                  （デフォルトは符号付き）
            [long int]              （デフォルトは符号付き）
            [signed long]
            [unsigned long int]
            [float]
            [double]

        shortまたはlongが指定されている場合には、intキーワードを指定する必要
        がないことに注意してください。

?       存在検証："?"単項演算子を使用して、シンボルが存在するかどうかを検証
        することができます。

        例：
            DBG>print ?id

        "id"がVIDEOにとって既知のシンボルである場合には、この式の結果は１に
        なります。そうでない場合には、結果は０です。このシンボルが現在のスコ
        ープにない場合には、そのモジュール名で修飾しなければなりません。自動
        シンボルが存在するのは、現在の関数だけです。

Ｃ文法の２項アドレス演算子
--------------------------
:       メモリ位置を参照するには、":"２項演算子とともに、定数、レジスタ名、
        およびシンボル名を組み合わせたものを使用します。Intel 80x86アーキテ
        クチャでは、メモリ参照には、セグメントとオフセットの指定が必要です。
        ":"演算子を使用したメモリ参照の形式は次のとおりです。

            segment:offset

        要素のsegmentとoffsetは、式にすることができます。

        例：
            (ES):(DI+100)
            (SS):(SP-20)

Ｃ文法の一次式演算子
--------------------
[]      添字式を使用して、配列の要素を識別することができます。次の"C"言語で
        定義されている３次元配列を考えてみましょう。

        例：
            char *ProcessorType[2][4][2] =
                { { { "Intel 8086",   "Intel 8088"      },
                    { "Intel 80186",  "Intel 80188"     },
                    { "Intel 80286",  "unknown" },
                    { "Intel 80386",  "unknown" } },

                  {   { "NEC V30",        "NEC V20" },
                    { "unknown",          "unknown" },
                    { "unknown",          "unknown" },
                    { "unknown",          "unknown" } } };

        この配列は、４列 x ２カラムの矩形マトリックスの２つの層と見なすこと
        ができます。この配列の要素はすべて文字列値へのポインタです。

        添字式を使用すると、配列の特定の断面を表示できます。最初の層の値だけ
        を表示する場合には、以下のコマンドが発行できます。

        例：
            DBG>print processortype[0]
            {[0]={[0]=0x0024, [1]=0x002F},
             [1]={[0]=0x003A, [1]=0x0046},
             [2]={[0]=0x0052, [1]=0x005E},
             [3]={[0]=0x0066, [1]=0x005E}}

        ここに表示されている値は、文字列値のアドレスです。

        最初の層の第１列目だけを表示する場合には、以下のコマンドが発行できま
        す。
        例：
            DBG>print processortype[0][0]
            {[0]=0x0024, [1]=0x002F}

        最初の層の第２列目を表示する場合には、以下のコマンドが発行できます。

        例：
            DBG>print processortype[0][1]
            {[0]=0x003A, [1]=0x0046}

        マトリックス内の特定のエントリの値を表示する場合には、すべてのインデ
        ックスを指定できます。

        例：
            DBG>print {%s} processortype[0][0][0]
            Intel 8086
            DBG>print {%s} processortype[0][0][1]
            Intel 8088
            DBG>print {%s} processortype[0][1][0]
            Intel 80186

        この例では、文字列値を表示するために"%s"フォーマット指定子を使用して
        います。

()      関数呼出し演算子はシンボル名の右に現れ、式で関数呼出しを識別します。
        括弧の中には引数を入れることができます。

        例：
            DBG>print ClearScreen()
            DBG>print PosCursor( 10, 20 )
            DBG>print Line( 15, 1, 30, '-', '+', '-' )

.       "."演算子は、構造体でのフィールド選択を示します。以下の例では、tyme2
        は構造体で、tm_yearはその構造体の中のフィールドです。

        例：
            DBG>print tyme2.tm_year

->      "->"演算子は、構造体に対するポインタを使用するときのフィールド選択を
        示します。以下の例では、tymeはポインタで、tm_yearはそのポインタが指
        す構造体の中のフィールドです。

        例：
            DBG>print tyme->tm_year
::::DISPLAY
+------------------------------------------------------------------------+
|　Display                                                               |
|　　Assembly [status][title][window_coord]                              |
|　　Command [status][title][window_coord][cmd_list]                     |
|　　Dialogue [status][title][window_coord]                              |
|　　Fpu [status][title][window_coord]                                   |
|　　Memory [status][title][window_coord] [mem_loc]                      |
|　　Prompt [status][title][line_number]                                 |
|　　Register [status][title][window_coord]                              |
|    SOurce [status][title][window_coord]                                |
|    STack [status][title][window_coord]                                 |
|    Thread [status][title][window_coord]                                |
+------------------------------------------------------------------------+

Displayコマンドは、デバッガが提供できるいろいろな表示用の出力ウィンドウを作
成または削除するために使用します。各ウィンドウごとにウィンドウ状態、タイトル
、ウィンドウの開始行番号、そしてサイズが変化するウィンドウの場合には最終行番
号を指定することができます。VIDEOウィンドウについては「VIDEOウィンドウ」の章
で説明してあります。

ウィンドウ名を指定しない場合には、すべてのウィンドウが更新されます。ユーザの
アプリケーションがウィンドウ表示を上書きした場合には、このDisplayコマンドを
使ってウィンドウ表示を作成し直すことができます。このコマンドをコマンド並びで
使用して、表示を更新することもできます。

ウィンドウタイトル
------------------
Displayコマンドを使ってウィンドウを作成する場合には、タイトルを付けることが
できます。タイトルは中括弧の中に文字列を入れて指定します。形式的には次のよう
に記述します。

        title ::= "{"text"}"

アスタリスク（*）を文字列の一部として指定できます。これは、現在のモジュール
名の位置ホルダーを表します。

例：
        DBG>display assembly {Assembly: *}

この例では、Assemblyウィンドウに"Assembly: *"というタイトルを付けています。
現在のモジュール名が"hello"であれば、Assemblyウィンドウの最上部に次のような
タイトルが現れます。

        ==| Assembly: hello |======================

ウィンドウからタイトルを削除するには、単に空の中括弧の対を指定します。

例：
        DBG>display assembly {}


ウィンドウの位置
----------------
出力行は、画面の最上部の行を１として順に行番号が付けられます。コラムは左から
右へ１から順に番号が付けられます。他のウィンドウにオーバラップするウィンドウ
を定義できます。このため、オーバラップされたウィンドウの一部が見えなくなるこ
とがあります。

ウィンドウの座標は最上部行、最下部行、左コラム、および右コラムで指定します。

        window_coord ::= [top][","[bottom][","[left][","right]]]

top、bottom、left、およびright項目は式で、数字に対する現在のデフォルトの基数
に関係なく、常に基数10で評価されます。

例：
        DBG>display assembly 3,20,1,80

この例では、行番号３から20まで、コラム１から80までを占めるAssemblyウィンドウ
を定義しています。

例：
        DBG>display assembly {Assembly: *} 3,20,1,80

前の例と似ていますが、ウィンドウタイトルも指定しています。

例：
        DBG>display assembly ,,8,60

この例では、Assemblyウィンドウの始めと終りのコラムをそれぞれ８と60に再定義し
ています。

ウィンドウの処置
----------------
Displayコマンドを使って作成する各ウィンドウの処置を、以下に示すstatus修飾子
の１つを使って指定することができます。

/Open   ウィンドウを作成して、画面上に置きます。

        例：
            DBG>dis assembly /open {Asm: *} 13,19,1,71

        これはウィンドウ作成時のデフォルトの処理です。したがって、この修飾子
        を指定する必要はありません。

/Close  現在画面上にあるウィンドウを、この修飾子を使って削除することができま
        す。DialogueウィンドウとPromptウィンドウは削除できませんが、画面上の
        別の場所に移動させることは可能です。

        例：
            DBG>display assembly /colse

        この例では、Assemblyウィンドウを画面上から削除します。

        ウィンドウは作成できますが、画面上に置くことはできません。

        例：
            DBG>display fpu /close {FPU} 3,13,1,64

        このウィンドウは後でDisplayコマンドを使って、画面上に置くことができ
        ます。その場合、ウィンドウのタイトルまたは座標を指定し直す必要はあり
        ません。

/Zoom   ウィンドウが作成され、すぐに画面上いっぱいに表示されます。

        例：
            DBG>display source /zoom

        このウィンドウがすでに画面上にある場合には、そのとき定義されているサ
        イズは画面いっぱいのサイズに切り替えられます。


ウィンドウ属性
--------------
 ウィンドウのいろいろな項目は特殊な属性を用いて表示されます。"plain"、"activ
 e"、"standout"、"title"、および"gadget"属性については、Paintコマンドの説明
 を参照してください。

Ａｓｓｅｍｂｌｙウィンドウ
--------------------------
+------------------------------------------------------------------------+
|　Display Assembly [status][title][window_coord]                        |
+------------------------------------------------------------------------+

デバッガは、現在のコード位置に対するアセンブラ命令をこのウィンドウに表示しま
す。コードセグメントレジスタおよび命令ポインタレジスタ（CS:IP、CS:EIP）がAss
emblyウィンドウに表示されている命令を指している場合には、その命令が入ってい
る行は"active"属性で表示されます。アセンブラ命令を検査している場合には、１つ
の行が現在行として指定され、"standout"属性で表示されます。ソース情報が使用可
能な場合には、Sourceウィンドウが画面上にあれば、Assemblyウィンドウと同期しま
す。

Ｃｏｍｍａｎｄウィンドウ
------------------------
+------------------------------------------------------------------------+
|　Display Command [status][title][window_coord][cmd_list]               |
+------------------------------------------------------------------------+

Commandウィンドウを使用して、制御がデバッガに戻るたびに評価したい１つまたは
複数のコマンドの結果を表示することができます。

コマンドの後のコマンド並びは次のように定義します。

        cmd_list ::= "{"[cmd]{";"[cmd]}"}"

例：
        DBG>display command 3, 8 {e es:bx,.+10,10,4; reg}

以下のようなコマンドの出力は通常別のウィンドウに表示されます。

例：
    DBG>e es:bx,.+10,10,4
    DBG>reg

Commandウィンドウを作成するときに指定するコマンド並びが実行され、結果はComma
ndウィンドウに表示されます。次の場合には、常にコマンドが再実行され、結果はCo
mmandウィンドウに表示されます。

        1. デバッガに入った、
        2. DisplayコマンドまたはDisplay Commandコマンドが発行された、または
        3. （マウスまたはタブキーを使って）Commandウィンドウが選択された場合

この機能は、１つまたは複数の変数の値の変更を監視するためのメカニズムを備えて
います（Print/Windowコマンドも参照してください）。


Ｄｉａｌｏｇｕｅウィンドウ
--------------------------
+------------------------------------------------------------------------+
|　Display Dialogue [status][title][window_coord]                        |
+------------------------------------------------------------------------+

デフォルトでは、デバッガはコマンドへの応答をこのウィンドウに表示します。通常
、出力を表示する他のウィンドウが画面にない場合には、その出力はDialogueウィン
ドウに表示されます。

ＦＰＵウィンドウ
----------------
+------------------------------------------------------------------------+
|　Display Fpu [status][title][window_coord]                             |
+------------------------------------------------------------------------+

80x87数値データプロセッサ（数値演算コプロセッサ）レジスタと状態フラグの内容
が、このウィンドウに表示されます。デバッガに最後に入ったときからレジスタの内
容が変更された場合には、"standout"属性で表示されます。

Ｍｅｍｏｒｙウィンドウ
----------------------
+------------------------------------------------------------------------+
|　Display Memory [status][title][window_coord][mem_loc]                 |
+------------------------------------------------------------------------+

メモリの一部がこのウィンドウに表示されます。Memoryウィンドウがアクティブな場
合には、現在選択されたメモリ位置は"active"属性で表示されます。Memoryウィンド
ウの「ホットスポット」（たとえば、BYTE）は"standout"属性で表示されます。その
他の項目はすべて"plain"属性で表示されます。

例：
    DBG>display memory /open {Low Mem} 3,9,,,ds:36

この例では、位置DS:36から始まるメモリを行番号３から９、コラム１から80にある
Memoryウィンドウに表示します。

例：
    DBG>display memory /close

この例では、Memoryウィンドウを画面から削除します。

Ｐｒｏｍｐｔウィンドウ
----------------------
+------------------------------------------------------------------------+
|　Display Prompt [status][title][line_number]                           |
+------------------------------------------------------------------------+

デバッガコマンド入力プロンプト"DBG>"が、高さ１行のウィンドウに表示されます。
Promptウィンドウを使用して、コマンド行を入力します。

複数実行スレッドアプリケーションでは、"DBG>"プロンプトの代わりに現在のスレッ
ドを示すプロンプトが表示されます。プロンプトの形式は"ddddd>"で、ここで"ddddd
"はスレッド識別番号です。

例：
    00002>

Ｒｅｇｉｓｔｅｒウィンドウ
--------------------------
+------------------------------------------------------------------------+
|　Display Register [status][title][window_coord]                        |
+------------------------------------------------------------------------+

80x86レジスタの現在の内容がこのウィンドウに表示されます。デバッガに最後に入
力してからレジスタの内容が変更された場合には、"standout"属性で表示されます。
ただし、命令ポインタ（IP、EIP）レジスタだけは、分岐命令や呼出し命令が実行さ
れた場合だけ"standout"属性で表示されます。

レジスタセット０以外のレジスタセットが表示される場合には、レジスタセット番号
は"active"属性を用いて大括弧に入れて（たとえば、[1]）表示されます（Register
コマンドの説明を参照してください）。

Ｓｏｕｒｃｅウィンドウ
----------------------
+------------------------------------------------------------------------+
|　Display SOurce [status][title][window_coord]                          |
+------------------------------------------------------------------------+

現在のコード位置に対するプログラムソースコード情報が利用できる場合には、その
情報はこのウィンドウに表示されます。コードセグメントレジスタおよび命令ポイン
タレジスタ（CS:IP、CS:EIP）がSourceウィンドウに表示されている命令を指してい
る場合には、その行は"active"属性で表示されます。ソースコードを検査している場
合には、１つの行が現在行として指定され、"standout"属性で表示されます。Assemb
lyウィンドウがある場合には、AssemblyウィンドウはSourceウィンドウと同期します。

Ｓｔａｃｋウィンドウ
--------------------
+------------------------------------------------------------------------+
|　Display STack [status][title][window_coord]                           |
+------------------------------------------------------------------------+

実行スタックの一部がこのウィンドウに表示されます。ベースポインタ（BP、EBP）
レジスタが、スタック上の表示されているバイト、ワード、またはダブルワードを指
している場合には、そのバイト、ワード、またはダブルワードは"standout"属性で表
示されます。その他のワードはすべて"plain"属性で表示されます。

Ｔｈｒｅａｄウィンドウ
----------------------
+------------------------------------------------------------------------+
|　Display Thread [status][title][window_coord]                          |
+------------------------------------------------------------------------+

Threadウィンドウを使用して、すべてのプログラム実行スレッドの識別番号、状態、
および名前を表示します。デバッガに入ると、現在実行中のスレッドは常に"active"
属性で表示されます。現在選択されているスレッドは"standout"属性で表示されま
す。その他の項目はすべて"plain"属性で表示されます。

Threadウィンドウには３つのエントリがあります。最初のエントリはスレッド識別番
号またはスレッドIDです。２番目のエントリは、"runnable"または"frozen"のスレッ
ド状態です。３番目のエントリは、はNetWare 386サーバタスクにだけに使用可能な
スレッド名です。

DOS、MS Windowsの下では、実行スレッドは１つしかないので、Threadウィンドウに
はエントリは１つしかありません。OS/2とNetWare 386の下では、実行スレッドが複
数になることがあるので、Threadウィンドウに複数のエントリがある場合があります。

例：
        DBG>display thread /open {Threads} 14,19,20,50

この例では、実行スレッド情報を、行番号14から19、コラム20から50にあるThreadウ
ィンドウに表示します。

例：
        DBG>display thread /close

この例では、Threadウィンドウを画面から削除します。
::::DO
+------------------------------------------------------------------------+
|　Do expr                                                               |
|  /                                                                     |
+------------------------------------------------------------------------+

DOまたは／コマンドは式を評価して、その結果を廃棄します。これは新しい値をレジ
スタや変数に割り当てるのに便利です。式exprにはレジスタ、アプリケーションの変
数、そしてユーザ定義変数を指定できます。ＣおよびFORTRAN 77プログラミング言語
で使用できる演算をまねることができます。式は「VIDEO式の処理」の章で詳しく説
明してあります。

例：
        DBG>do ax=1
        DBG>/ax=1

上の例は、AXレジスタの内容に１を設定するための２通りの方法を示しています。

例：
        DBG>/myvar=di-bx+1

変数myvarは、DIレジスタの内容からBXレジスタの内容を減算してから１を加わえて
得られた値で定義されます。

例：
        DBG>/oldsi=si++

変数oldsiはSIレジスタの現在の内容で定義されます。その後、SIレジスタの現在の
内容を１だけインクリメントします（Ｃライクの"++"演算子は変数の値をインクリメ
ントします）。oldsiのような変数はアプリケーション内で定義する必要はありませ
ん。これはVIDEOでは、デバッグセッション中だけ存在する新しい変数を動的に作成
できるからです。上記の例で示すように、これらのユーザ定義変数を使用して情報を
保持することができます。
::::DOS_EXTENDER
３２ビットＤＯＳエクステンダアプリケーションのデバッグ
------------------------------------------------------

はじめに
--------
本章を読む前に、４章の「DOSでのデバッグ」の内容をよく理解しておいてください
。４章では、DOSエクステンダシステムの一般的なコマンド行フォーマットおよびオ
プションについて説明してあります。

VIDEOは、WATCOM C/386、WATCOM FORTRAN 77/386、およびアセンブラ言語によって開
発された32ビットアプリケーションのデバッグをサポートしています。アプリケーシ
ョンを動作するにはDOSエクステンダを使用しなければなりません。サポートされて
いるDOSエクステンダは次のとおりです。

DOS/4G          Rational Systems,Inc.のDOSエクステンダです。
386|DOS-Extender
                （バージョン2.2dまたはそれ以降）Phar Lap Software,Inc.のDOS
                エクステンダです。

ＤＯＳエクステンダに対するＶＩＤＥＯコマンド行フォーマット
----------------------------------------------------------
VIDEOとオペレーティングシステム/DOSエクステンダとのインタフェースは特殊な
「トラップ」ファイルに入っています。"TRAP"オプションを使用して、VIDEOに対し
てトラップファイルを指定します。

+------------------------------------------------------------------------+
|　WVIDEO /TRap=trap_file[;trap_parm][:sym_file]file_spec[cmd_line]      |
+------------------------------------------------------------------------+

32ビットDOSエクステンダを必要とするアプリケーションをデバッグする場合には、
TRapオプションを指定しなければなりません。便宜上、WVIDEO環境変数を使ってこの
オプションを指定することができます。

+------------------------------------------------------------------------+
|　SET WVIDEO=/TRap#trap_file[;trap_parm]                                |
+------------------------------------------------------------------------+

trap_parmを指定し、その中に空白文字が入っている場合には、パラメータ全体を中
括弧で囲まなければなりません（例：/trap=pls;{-minr 128}）。

VIDEOが提供するDOSエクステンダ「トラップ」ファイルのどれか１つの名前を指定し
なければなりません。デフォルトのファイル拡張子は".TRP"です。

RSI.TRP     このインタフェースモジュールは、Rational Systemsの"DOS/4G" DOSエ
            クステンダが動作しているローカルコンピュータシステム上でのデバッ
            グをサポートしています。任意指定の"trap_parm"は無視されます。
PLS.TRP     このインタフェースモジュールは、Phar Lap Software,Inc.の386|DOS-
            Extenderが動作しているローカルコンピュータシステム上でのデバッグ
            をサポートしています。任意指定の"trap_parm"は、コマンド行スイッ
            チとしてDOSエクステンダ"RUN386"に渡されます。

+------------------------------------------------------------------------+
|　注：　トラップファイルを指定しない場合には、デフォルトのトラップファイ|
|　ル"STD.TRP"がロードされます。このインタフェースモジュールはDOSが起動  |
|　するローカルコンピュータシステム上でのデバッグをサポートしています。  |
|　32ビットDOSエクステンダアプリケーションのデバッグはできません。       |
+------------------------------------------------------------------------+

次の図は、32ビットDOSエクステンダのアプリケーションのデバッグ時にメモリがど
のように構成されるかを示しています。

            |                      |
            +----------------------+
            |       32ビット       |
            |   アプリケーション　 |
    109C4   +----------------------+
            |                      |
            |                      |
    7E6E    +----------------------+
            |   トラップハンドラ   |
            |       ECS.TRP<-------|--+
    7B27    +---------|------------+  |
            |         |            |  |
            |       WVIDEO         |  |
            |                      |  |
    47A4    +----------------------+  |
            |                      |  |
            |   　　OS/386　　     |  |
            |   DOSエクステンダ<---|--+
            |                      |
    262C    +----------------------+
            |                      |
            |                      |
            |                      |
    0000    +----------------------+


Ｒａｔｉｏｎａｌ　Ｓｙｓｔｅｍｓ　３２ビット　ＤＯＳエクステンダの使用法
------------------------------------------------------------------------
Rational Systems DOSエクステンダを使用する場合には、DOSのPATH環境変数にリス
トされたディレクトリの１つに"DOS4G.EXE"ファイルが入っていなければなりません。

+------------------------------------------------------------------------+
|　C>WVIDEO/TRap=RSI[:sym_file]file_spec[cmd_line]                       |
+------------------------------------------------------------------------+

"DOS/4G" DOSエクステンダの下で動作するアプリケーションをデバッグする場合には
、/TRap=RSIオプションを指定しなければなりません。"RSI.TRP"ファイルは通常、WA
TCOMコンパイラパッケージの"BIN"ディレクトリに格納されています。この"BIN"ディ
レクトリがDOSのPATH環境変数に含まれているか確認してください。含まれていない
場合には、トラップファイルのフルパス名を指定しなければなりません。

ヘルプファイル"RSIHELP.EXP"も、DOSのPATH環境変数にリストされたディレクトリの
１つに入っていなければなりません。このファイルは通常、WATCOMコンパイラパッケ
ージの"BIN"ディレクトリに格納されています。

例：
    C>wvideo /trap=rsi hello
        または
    C>set wvideo=/trap#rsi
    C>wvideo hello

Ｐｈａｒ　Ｌａｐ　３２ビット　ＤＯＳエクステンダの使用法
--------------------------------------------------------
Phar Lap Software,Inc DOSエクステンダを使用する場合には、"RUN386.EXE"ファイ
ル、"DBGLIB.REX"ファイル、および"PLSHELP.EXP"ファイルがDOS PATH環境変数にリ
ストされたディレクトリの１つに入っていなければなりません。

+------------------------------------------------------------------------+
|　C>WVIDEO/TRap=PLS[;trap_parm][:sym_file]file_spec[cmd_line]           |
+------------------------------------------------------------------------+

Phar Lap DOSエクステンダの下で動作するアプリケーションをデバッグする場合に
は、/TRap=PLSオプションを指定しなければなりません。"PLS.TRP"ファイルおよび
"PLSHELP.EXP"ファイルは通常、WATCOMコンパイラパッケージの"BIN"ディレクトリに
格納されています。この"BIN"ディレクトリがDOSのPATH環境変数に含まれているか確
認してください。含まれていない場合には、トラップファイルのフルパス名を指定し
なければなりません。

任意指定の"trap_parm"は、コマンド行スイッチとしてDOSエクステンダ"RUN386"に渡
されます。trap_parmが指定され、その中に空白文字が入っている場合には、パラメ
ータ全体を中括弧で囲まなければなりません（例：/trap=pls;{-minr 128}）。

例：
    C>wvideo /trap=pls;{-maxreal 512} hello
        または
    C>set wvideo=/trap#pls;{-maxreal 512}
    C>wvideo hello
::::DOS_GRAPHICS_APPLICATIONS
グラフィックスアプリケーションをデバッグする場合には、ユーザの状況によって多
くのVIDEOオプションを指定できます。

    1.　VIDEOを開始するマシンと同じマシン上でグラフィックスアプリケーション
        をデバッグし、かつシステムにモニタが１つしか接続されていない場合に
        は、"Swap"オプションを使用しなければなりません。"Swap"オプションは、
        １つのページを使用して、アプリケーションの画面メモリとデバッガの画面
        メモリが交互にスワップするよう指定します。
    2.　VIDEOを開始するマシンと同じマシン上でグラフィックスアプリケーション
        をデバッグし、かつシステムに２台のモニタが接続されている場合には、
        "Two"と"Monochrome"オプションを使用しなければなりません。"Two"オプシ
        ョンは、２台目のモニタがシステムに接続されていることを指定します。
        なお、モニタの種類（Monochrome、Color、Colour、Ega43、Vga50）を指定
        しない場合には、、現在使用されていないモニタがデバッガの画面に選ばれ
        ます。"Monochrome"を指定すると、モノクロモニタがデバッガの画面に使わ
        れます。
    3.　２台目のパーソナルコンピュータとVIDEOのリモートデバッグ機能を使って
        グラフィックスアプリケーションをデバッグしている場合には、VIDEOに対
        してディスプレイとオペレーションモードを選択するのは、必ずしも適切で
        はありません。一方のシステムにグラフィックスディスプレイがあり、もう
        一方のシステムにモノクロディスプレイがある場合には、ユーザは間違いな
        くモノクロディスプレイのあるシステムを使用して、VIDEOを動作させるは
        ずです。
::::DOS_INTERRUPTING_A_PROGRAM
プログラムをVIDEOによってロードすると、Goコマンドによって実行を開始すること
ができます（Goコマンドは「VIDEOコマンド」の章で説明してあります）。

例：
    C>wvideo myapp
    .
    .
    .
    DBG>go

開発段階ではよくあることですが、プログラムの実行が際限なく続くことがありま
す。

DOSの下では、Print Screen（PrtSc）キーまたはSystem Request（SysRq）キー（PC-
9801ではCOPYキー）を押してプログラムの実行を中断することができます。キーボー
ドによっては、Print Screenファンクション機能を得るためにシフトキーも押さなけ
ればならない場合があります。

VIDEOは、"Dialogue"ウィンドウにプログラムの実行が中断したことを示すメッセー
ジを表示します。Goコマンドを使って、実行を再開することができます。

Ctrl/Breakキーの組合せを使用して、VIDEOコマンドの実行を中断することができま
す。

以下に示す条件を満たす場合には、この組合せキーを使用して実行中のプログラムを
中断することもできます。

    1.　プログラムがCtrl/Break割込み自体をハンドリングしていない事
    2.　プログラムの実行中にDOSファンクションリクエスト（割込み0x21）を発行
        している事

リモートデバッグ機能の使用中に実行中のプログラムを中断する方法については、
「リモートデバッグ」の章を参照してください。
::::DOS_REMOTE_DEBUGGING
+------------------------------------------------------------------------+
|　WVIDEO /TRap=trap_file[;trap_parm][:sym_file]file_spec[cmd_line]      |
+------------------------------------------------------------------------+

２台目のコンピュータシステムを使用してアプリケーションをデバッグする場合に
は、VIDEO TRapオプションを指定しなければなりません。file_specのフォーマット
は、DOS、OS/2、NetWare 386など、ターゲットマシンのオペレーティングシステムに
よって異なります。

例：
        C>wvideo /trap=par /reg=4 \users\fred\fdapp

trap_parmを指定し、それに空白文字が入っている場合には、そのパラメータ全体を
中括弧で囲まなければなりません（例：　/trap=dqv;{WATCOM Server}）。

１台目のコンピュータシステム（「タスクマシン」）上で起動されたデバッグサーバ
に対応する"trap"ファイルの名前を指定しなければなりません。これらのファイル
は、アプリケーションのリモートデバッグに必要なマシン対マシンの通信を処理しま
す。サーバについては、「リモートデバッグ」および「MS Windowsアプリケーション
のリモートデバッグ」の章で説明します。

DOSでは、デフォルトのファイル拡張子は".TRP"となります。DOSのPATH環境変数には
トラップファイルのパスが入っていなければなりません。トラップファイルは通常、
VIDEOがインストールされているディレクトリの"BIN"サブディレクトリにあります。

STD.TRP     DOSの下では、トラップファイルを指定しない場合には、デフォルトの
            トラップファイル"STD.TRP"がロードされます。このインタフェースモ
            ジュールは、DOSが動作しているローカルコンピュータ上でのデバッグ
            をサポートします。リモートデバッグはできません。トラップファイ
            ルパラメータ"d"を指定して、デバッグレジスタの使用を禁止すること
            ができます。

SER.TRP     この通信ドライバファイルは、２台のマシンのシリアルポートを使用し
            た、別のコンピュータシステムで動作するアプリケーションのデバッグ
            をサポートします。このファイルは"SERSERV"デバッグサーバと通信し
            ます。デバッガマシンのシリアルポートはタスクマシンのシリアルポー
            トと接続されます。"trap_parm"値は、使用するポート番号と任意指定
            の最大BAUDレート（ポート番号とピリオドで区切られています）を指定
            します。ポート番号は１、２、３、または４（デフォルトは１）です。
            これらの数字は、シリアルデバイス"COMx"（"COM1"、"COM2"など）を指
            定するときに使われるデバイス番号に対応します。

            DOSの下では、最大BAUDレートを以下のうちのどれかにすることができ
            ます。

                115200
                 57600
                 38400
                 19200
                  9600
                  4800
                  2400
                  1200
                     0　（特別な場合）

            デフォルトの最大BAUDレートはPC/AT上では115,200です。

            特別なBAUDレート０を除いて、希望する最大BAUDレートを識別するには
            少なくとも最初の２桁を指定しなければなりません。最大BAUDレートに
            ついては、「リモートデバッグ」の章の「シリアルポートを介したリモ
            ートデバッグ」の項で説明します。以下の例では、ポート２と最大BAUD
            レート19,200が指定されています。

            例：
                /trap=ser;2.19

PAR.TRP（PC/AT用のみ）　この通信ドライバファイルは、２台のマシンのパラレルポ
            ートを使用した、別のコンピュータシステムで動作しているアプリケー
            ションのデバッグをサポートします。このファイルは"PARSERV"または
            "PARSERVW"（Microsoft Windows）デバッグサーバと通信します。デバ
            ッグマシンのパラレルポートはタスクマシンのパラレルポートと接続さ
            れます。使用するポート番号は"trap_parm"で指定します。ポート番号
            は１、２、または３（デフォルトは１）です。これらの数字はプリンタ
            デバイス"LPTx"（"LPT1"、"LPT2"など）を指定するときに使われるデバ
            イス番号に対応します。

NOV.TRP     この通信ドライバファイルは、Novellの"NetWare"ネットワーク（NetWa
            reとNovellはNovell,Inc.の登録商標）に接続された別のコンピュータ
            システムで動作するアプリケーションのデバッグをサポートします。こ
            のファイルは"NOVSERV"デバッグサーバと通信します。バージョン2.0ま
            たはそれ以降のNetWareを使用しなければなりません。使用するサーバ
            名は"trap_parm"で指定します。サーバ名は、サーバを「タスク」マシ
            ン上で起動したときに指定した名前と一致していなければなりません。
            デフォルトの"server_name"は
            "NovLink"です。サーバ名は47字以下でなければなりません。

NET.TRP     この通信ドライバファイルは、NetBIOSネットワークプログラミングイ
            ンタフェースを使用した、別のコンピュータシステムで動作しているア
            プリケーションのデバッグをサポートします。このファイルは"NETSERV
            "または"NETSERVW"（Microsoft Windows）デバッグサーバと通信しま
            す。使用するサーバ名は"trap_parm"で指定します。サーバ名は、サー
            バを「タスク」マシン上で起動したときに指定した名前と一致していな
            ければなりません。デフォルトの"server_name"は"NetLink"です。サー
            バ名は最大15字までの英数字です。

DQV.TRP     この通信ドライバファイルは、DOSのDESQviewの下で動作するアプリケ
            ーションのデバッグをサポートします。このファイルは"DQVSERV"デバ
            ッグサーバと通信します。使用するサーバ名は"trap_parm"で指定しま
            す。サーバ名は、サーバをDESQviewウィンドウで起動したときに指定し
            た名前と一致していなければなりません。デフォルトの"server_name"
            は"WATCOM Server"です。

            +------------------------------------------------------------+
            |　注：　Print Screen（PrtSc）キーまたはSystem Request（Sys  |
            |　Rq）キーを使用してアプリケーションの実行を中断するには、  |
            |　DESQviewは2.26またはそれ以降のバージョンでなければなりま  |
            |　せん。それ以前のバージョンのDESQviewでは、これらのキーを  |
            |　押すと現在のCS:IPはDESQviewコードを指すことになります。   |
            +------------------------------------------------------------+

WIN.TR     この通信ドライバファイルは、Microsoft Windows DOSボックスで動作す
           るアプリケーションのデバッグをサポートします。このファイルは"WINS
           ERV"デバッグサーバと通信します。使用するサーバ名は"trap_parm"で指
           定します。サーバ名は、サーバをMicrosoft Windows DOSボックスで起動
           したときに指定した名前と一致していなければなりません。デフォルト
           の"server_name"は"WinLink"です。

            Microsoft Windowsはエンハンスドモードで起動しなければなりませ
            ん。32ビットアプリケーションをデバッグする場合には、以下に示す
            "device"指定をWindowsの"SYSTEM.INI"ファイルの[386Enh]セクション
            に入れなければなりません。

                DEVICE=[d:]＼WATCOM＼BINW＼WDEBUG.386

            このデバイスドライバは16ビットアプリケーションのデバッグにも使用でき                        ます。
::::DOS_STARTUP
+------------------------------------------------------------------------+
|　WVIDEO [options][:sym_file]file_spec[cmd_line]                        |
+------------------------------------------------------------------------+

角括弧[]は任意指定の項目であることを表します。

WVIDEO      VIDEOのプログラム名です。

options     有効なVIDEOオプションのリストです。各オプションの前にはダッシュ
            （"-"）またはスラッシュ（"/"）を付けます。オプションの指定順は任
            意です。

sym_file    任意指定のシンボリックデバック情報ファイル指定です。前にコロン
            （":"）を付けなければなりません。DOSのsym_fileの構文は次のとおり
            です。

            [d:][path]filename[.ext]

            シンボルファイルのデフォルトファイル拡張子は".SYM"です。

            シンボリック情報ファイルは、WATCOMリンカWLINKまたはWATCOMストリ
            ップユーティリティWSTRIPによって作成することができます。

file_spec   メモリにロードされるファイルの名前です。DOSのfile_specの構文は次
            のとおりです。

            [d:][path]filename[.ext]

            d:          "A:"、"B:"などの、任意指定のドライブ指定です。指定し
                        ない場合には、デフォルトドライブと見なされます。

            path        "＼UTILS＼BIN＼"のような任意指定のパス指定です。

            filename    メモリにロードされるファイルの名前です。

            ext         メモリにロードされるファイルの拡張子です。拡張子を入
                        力せず、ピリオド"."だけを入力して、NULLファイル拡張
                        子を指定できます。ファイル拡張子を指定しない（すなわ
                        ち、ピリオドと拡張子を省略した）場合には、VIDEOは以
                        下に示す拡張子を連続して使って、実行可能イメージファ
                        イルをロードしようとします。

                        DOSの場合の検索順：.COM、.EXE

                        Phar Lap DOSエクステンダの場合の検索順：.EXP、.EXE

                        Rational DOSエクステンダの場合の検索順：.EXE

                        NetWare 386の場合の検索順：.NLM、.DSK、.LAN

cmd_line    アプリケーションに渡される任意指定のコマンド行です。

ドライブとパスの両方を省略すると、VIDEOは最初にデフォルトドライブのカレント
ディレクトリでファイルを見つけようとします。ここでファイルが見つからない場合
には、PATH環境文字列にリストされた各パスでファイルを検索します。

コマンド行オプション
--------------------
+------------------------------------------------------------------------+
|　/Monochrome|/Color|/Colour|/Ega43|/Vga50                              |
|　/Overwrite|/Page|/Swap|/Two　                                         |
|　/Checksize=space                                                      |
|　/Dynamic=space                                                        |
|　/NOFpu                                                                |
|　/Invoke=file_spec                                                     |
|　/NOInvoke                                                             |
|　/NOMouse                                                              |
|　/Registers=number                                                     |
|　/REMotefiles                                                          |
|　/SIze=space                                                           |
|　/NOSNow                                                               |
|　/NOSymbols                                                            |
|　/TRap=trap_file[;trap_parm]                                           |
+------------------------------------------------------------------------+

オプションの指定順は任意です。省略形を使って指定してもかまいません。上記の大
文字で書かれた部分が省略形です。"space"の後に"K"の文字が付いている場合には、
"space"は1Kバイト（1024バイト）の倍数を表します。"B"の文字が付いている場合に
は、"space"はバイト数を表します。後に何も付いていなくて、"space"が1000より小
さい数字の場合には、"space"は1Kバイト（1024バイト）の倍数を表すものと見なさ
れます。それ以外の場合にはバイト数を表します。

ディスプレイの選択

/Monochrome     システムに２つのディスプレイ装置がある場合、このオプション
                は、モノクロディスプレイをデバッガの出力装置として使用するこ
                とを意味します。このオプションは後で説明するTwoオプションと
                共に使用されます。

/Color、/Colour システムに２つのディスプレイ装置がある場合、このオプション
                は、カラーディスプレイをデバッガの出力装置として使用すること
                を意味します。このオプションは後で説明するTwoオプションと共
                に使用されます。

/Ega43          拡張グラフィックスアダプタ（EGA）がある場合、43行の出力が表
                示されます。

/Vga50          ビデオグラフィックスアレイ（VGA）がある場合、50行の出力が表
                示されます。

表示オペレーションモード

/Overwrite      デバッガの出力がプログラムの出力を上書きできるよう指定しま
                す。このモードでは、アプリケーションとデバッガは強制的に同じ
                表示領域を共有します。

                このオプションを使うと、VIDEOを動作するのに必要なメモリ容量
                を節約することができます。画面指向のアプリケーション（たとえ
                ば、グラフィックスアプリケーション）を同じマシン上でデバッグ
                する場合には、このオプションは使用できません。「グラフィック
                スアプリケーションのデバッグ」の項を参照してください。

/Page           画面メモリのページ０をアプリケーションの画面に使用し、ページ
                １をデバッガの画面に使用するよう指定します。このオプション
                は、CGA、EGA、またはVGAなどのグラフィックスアダプタを使用す
                る場合に選択できます。Pageオプションを使うとアプリケーション
                画面とデバッガ画面間の切替えが速くなり、アダプタは余分な画面
                メモリを利用できるようになります。

                グラフィックスアプリケーションを同じマシン上でデバッグする場
                合には、このオプションは使用できません。「グラフィックスアプ
                リケーションのデバッグ」の項を参照してください。

/Swap           １つのページを使用して、アプリケーションの画面メモリとデバッ
                ガの画面メモリを交互にスワップするよう指定します。デバッガ
                は、アクティブになっていない画面に対して自分のデータスペース
                の領域を割り当てます。これによりアプリケーションが使用できる
                領域が削減されます。また、アプリケーション画面とデバッガ画面
                の切替えにかかる時間も長くなります。

                グラフィックスアプリケーションを同一マシン上でデバッグし、か
                つ２番目のモニタが使用できない場合には、必ずこのオプションを
                使ってください。「グラフィックスアプリケーションのデバッグ」
                の項を参照してください。

/Two            ２番目のモニタがシステムに接続されていることを指定します。モ
                ニタの種類（Monochrome、Color、Colour、Ega43、Vga50）を指定
                しない場合には、現在使用されていないモニタがデバッガの画面に
                選択されます。モニタの種類を指定した場合には、それに対応する
                モニタがデバッガの画面に選択されます。

                グラフィックスアプリケーションを同一マシン上でデバッグし、
                かつ２番目のモニタが使用できる場合には、必ずこのオプションを
                使ってください。「グラフィックスアプリケーションのデバッグ」
                の項を参照してください。

デフォルトの表示オペレーションは次のとおりです。

    1.　２つの表示システムがある場合には、VIDEOは両方の表示システムを使いま
        す。アクティブになっているモニタにはプログラム出力を、またもう一方の
        モニタにはデバッガ出力を表示します。すなわち、デフォルトとしてTwoオ
        プションが選択されます。
    2.　ユーザのシステムにCGA、EGA、VGAのグラフィックスアダプタのどれか１つ
        がインストールされている場合には、VIDEOはデフォルトとしてPageオプシ
        ョンを選択します。
    3.　その他の条件の下では、VIDEOはデフォルトとしてSwapオプションを選択し
    ます。

/Checksize=space　デバッガのSYstemコマンド（このコマンドは「VIDEOコマンド」
                の章で説明してあります）を用いてプログラムを実行させるために
                VIDEOがDOSに与える最小記憶域容量をキロバイト単位で指定しま
                す。このオプションは、デバッグされているアプリケーションが、
                使用可能なメモリのほとんどまたは全部を使用しているため、２次
                プログラムを生成するのに十分なメモリが残っていない場合に便利
                です。デバッガは要求された量の空きメモリをDOSに与えるため
                に、必要なだけアプリケーションにチェックポイントを設定します。

                チェックポイントの設定には、メモリに常駐しているアプリケー
                ションの一部が一時的にディスクに退避して、空いたメモリを生成
                されたプログラムに再利用させることが含まれます。生成されたプ
                ログラムが終了すると、アプリケーションの、チェックポイントの
                設定された部分はメモリに戻されます。

                デフォルトの量は0Kバイトです。この場合、生成されたプログラム
                は、DOSがそのプログラムを実行するためにどのくらいの空きメモ
                リを使用できるかによって実行されたり、実行されなかったりします。
         +------------------------------------------------------+
         |  警告：　デバッグされるアプリケーションが１つまたは  |
         |　複数の割込みハンドラをインストールする場合には、こ  |
         |　のオプションを使うとシステムがハングすることがあり  |
         |　ます。デバッガが、割込みハンドラの入っているアプリ  |
         |　ケーションのコード部分にチェックポイントを設定する  |
         |　場合には、システムはロックされることがあります。    |
         +------------------------------------------------------+

/Dynamic=space  VIDEOがウィンドウやユーザ定義シンボルなどの項目用に確保する
                動的メモリ容量を指定します。確保されるデフォルトの容量は409
                60バイト（40Kバイト）です。64Kバイトを超えるメモリ容量を指定
                することができます。この容量を多くすればするほど、デバッグさ
                れるアプリケーションに使用できるメモリは少なくなります。リモ
                ートデバッグ機能を使用している場合には、VIDEOは必要なだけ、
                使用可能メモリを利用します。

/NOFpu          数値演算コプロセッサの存在を無視するようデバッガに要求します
                。これにより、デバッガは80x87数値データコプロセッサのコンテ
                キストを保存するためのメモリを割り当てません。アプリケーショ
                ンが数値演算コプロセッサを使用せず、またデバッガが必要とする
                メモリを削減したい場合には、このオプションを使ってください。

/Invoke=file_spec　スタートアップ時に自動的に呼び出されるデバッガのコマンド
                ファイルの代替名を指定するのに使用します。デフォルトのファイ
                ル名は"PROFILE.DBG"です。VIDEOコマンドファイルはカレントディ
                レクトリまたはDOSのPATH環境文字列にリストされたディレクトリ
                の１つにあります。

/NOInvoke       デフォルトのデバッガコマンドファイルを呼び出さないよう指定し
                ます。

/NOMouse        接続されているマウスを無視するようデバッガに要求します。デバ
                ッグされるプログラムもマウスを使用し、システムにインストール
                されているマウスドライバが、２つのアプリケーションが同時にマ
                ウスを共用するのをサポートしていない場合には、これを指定する
                必要があります。マウスドライバがこの機能をサポートしているか
                どうかは、プログラム"CHKMOUSE.COM"によって分かります。ユーザ
                のマウスドライバの機能を判定する場合には、DOSコマンドプロン
                プトでこのCHKMOUSEプログラムを実行してください。

                例：
                    C>chkmouse

                プログラムは、マウスドライバがマウスを共用するアプリケーショ
                ンをサポートしているかどうかや、マウスドライバがインストール
                されていなければ、それを示す１行を表示します。このプログラム
                はVIDEOに添付されています。

                マウスを使用するには、Mouse Driverプログラムをインストールし
                なければなりません。

/Registers=number　レジスタ内容を記録するために確保するレジスタセットの数を
                指定します。デフォルトのレジスタセット数は２です。詳細はReg
                isterコマンドの説明を参照してください（このコマンドは「VIDEO
                コマンド」の章で説明してあります）。

/REMotefiles    デバッガのリモートデバッグ機能の指定と一緒に指定します。リモ
                ートデバッグには２台のパーソナルコンピュータを使用します。１
                台は「タスクマシン」と呼ばれ、アプリケーションの実行に使用
                し、もう１台は「デバッガマシン」と呼ばれ、デバッガの実行に使
                用されます。REMotefilesを指定すると、すべてのデバッガファイ
                ル（"trap"ファイルは除きます）とアプリケーションソースファイ
                ルは、デバッガマシン上ではなく、タスクマシン上でオープンされ
                ます（ローカルデバッグを行っている場合には、これら２台のマシ
                ンは実際には同一です）。"trap"ファイルは、タスクマシン上のフ
                ァイルをオープンするコードを含んでいるので、デバッガマシンの
                方になければなりません。

                タスクマシンのPATH環境変数は常に実行可能イメージファイルを見
                つけ出すのに使用されることに注意してください。REMotefilesを
                指定すると、デバッガは、デバッガのコマンドファイルを見つけ出
                すのにも、タスクマシンのPATH環境変数を使用します。

/SIze=space     VIDEOがオーバレイ領域として使用できる追加のオーバレイスペー
                ス容量を指定します。この領域を（ある量まで）大きくすればする
                ほどVIDEOの性能は良くなりますが、アプリケーションが使用でき
                るメモリは少なくなります。確保されるデフォルトの容量は70Kバ
                イトです。

/NOSNow         VIDEOがビデオメモリに直接書き込むときに、CGAアダプタに対する
                垂直帰線遅延を省略するよう要求します。この遅延を省略すると出
                力の表示速度が速くなります。

/NOSymbols      実行可能イメージをロードするときにすべてのデバッグ情報を省略
                するようVIDEOに要求します。この要求により、グローバルシンボ
                ル名とローカルシンボル名、データ型、および行番号に関する情報
                は処理されません。

/TRap=trap_file[;trap_parm]
                アプリケーションをリモートマシンでデバッグする場合、または32
                ビットDOSエクステンダの下で動作するアプリケーションをデバッ
                グする場合には、このオプションを指定しなければなりません。ま
                た、386/486デバッグレジスタの使用を禁止する場合にも使用でき
                ます。VIDEOに添付された"trap"ファイルの１つの名前を指定しな
                ければなりません。DOSの下では、デフォルトのファイル拡張子は
                ".TRP"です。"BIN"ディレクトリには、VIDEOに添付されているトラ
                ップファイルが入っています。

                DOSの下では、TRapオプションを指定しない場合には、デフォルト
                のトラップファイル"STD.TRP"がロードされます。このインタフェ
                ースモジュールは、DOSで動作するローカルコンピュータシステム
                上でのデバッグをサポートします。

                例：
                    C>wvideo calendar

                もちろん、VIDEOが使用する「標準」トラップファイルを明示的に
                指定することもできます。

                例：
                    C>wvideo /trap=std calendar

                TRapオプションの詳細については、後にある「386/486デバッグレ
                ジスタの使用禁止」および「リモートデバッグ」の章を参照してく
                ださい。
::::DOS_WVIDEO_ENVIRONMENT_VARIABLE
WVIDEO環境変数を使用して、よく使用するVIDEOオプションを指定することができま
す。あるオプションの指定に"="文字を使う場合には、その代わりに"#"文字を使用で
きます（これは"SET"コマンドの構文のために必要となります）。これらのオプショ
ンは、コマンド行で指定したオプションの前に処理されます。

例：
    C>set wvideo=/swap/vga50/reg#4

この例は、デバッガのデフォルトオプションの定義方法を示しています。

WVIDEO環境変数を定義すると、リストされたこれらのオプションはVIDEOを起動する
たびにデフォルトとなります。
::::ERROR
+------------------------------------------------------------------------+
|　ERror text_string|"{"text_string"}"                                   |
+------------------------------------------------------------------------+

Errorコマンドを使用して、肯定応答を必要とするエラーメッセージを画面上に表示
することができます。このコマンドはVIDEOコマンドファイルで最も効果的に使用で
きます。
ERrorコマンドが発行されると、現在実行中のコマンドファイルは終了します。

例：
    DBG>if ~ dbg$fpu {error No 80x87 processor/emulator!}

メッセージテキストがErrorウィンドウに表示されます。
::::EXAMINE
+------------------------------------------------------------------------+
|　Examine                                                               |
|    [/Byte]    exam_data                                                |
|    /Word      exam_data                                                |
|    /Dword     exam_data                                                |
|    /Pointer   exam_data                                                |
|    /Assembly  addr_data                                                |
|    /Source    addr_data                                                |
|    /IOByte    port_data                                                |
|    /IOWord    port_data                                                |
|    /IODword   port_data                                                |
+------------------------------------------------------------------------+

Examineコマンドを使用して、幾つかの方法の１つを使ってメモリ内容およびI/Oポー
トを表示します。

メモリをデータとして検査
------------------------
/Byte exam_data　この修飾子を使うと、Examineコマンドの出力はDialogueウィンド
            ウに書き込まれます。出力は16進（基数16）表記法を用いて８ビット値
            （バイト）にフォーマットされます。デフォルトの修飾子は/Byteです。

/Word exam_data　この修飾子を使うと、Examineコマンドの出力はDialogueウィンド
            ウに書き込まれます。出力は16進（基数16）表記法を用いて16ビット値
            （ワード）にフォーマットされます。各ワードの最上位バイトが最初に
            表示されます。

/Dword exam_data　この修飾子を使うと、Examineコマンドの出力はDialogueウィン
            ドウに書き込まれます。出力は16進（基数16）表記法を用いて32ビット
            値（ダブルワード）にフォーマットされます。各ダブルワードの最上位
            バイトが最初に表示されます。

/Pointer exam_data　この修飾子を使うと、Examineコマンドの出力はDialogueウィ
            ンドウに書き込まれます。出力は16進（基数16）表記法を用いてセグメ
            ント／オフセット対（セグメント：オフセット）にフォーマットされます。
        exam_data ::= [start_addr_expr]
                          [","[next_addr_expr]
                          [","[len_expr]
                          [","rpt_expr]]]

開始アドレスstart_addr_exprは、表示するメモリのセグメントとオフセットを定義
する式です。その次のアドレスnext_addr_exprは、表示するメモリの次のセグメント
とオフセットを定義する式です。長さ値len_exprは、表示するメモリ容量を定義する
式です。繰返しカウントrpt_exprは、コマンドを繰り返す回数を定義する式です。

有効な式の詳細については、「VIDEO式の処理」の章を参照してください。

例：
        DBG>examine ds:0x0000
        DBG>examine ds:0x0000,.+0x10,0x10

上の２つの例は等価です。メモリは、DSレジスタの内容によって定義されたセグメン
トとオフセット０から始まる一連のバイトとして表示されます。

デフォルトのnext_addr_exprは、現在の開始アドレス（"."）に16（10進数）を加え
たものとして定義されます。デフォルトのlen_exprは16（10進数）です。

Examineコマンドの１つの特徴は、リンクされたリストを追うことができることです。
これは、Ｃプログラミング言語の例を使って示すことができます。次のような構造体
が定義されたと仮定します。

    typedef struct list_entry
      {
        int                 entry_number;
        struct list_entry   *next;
        int                 flags;
        char                *buff_addr;
      } LIST;

    extern LIST *listhead;        /* start of linked list */

構造体定義は、各エントリの２番目の項目がリンクされたリストの次のエントリを指
していることを示しています。リンクされたリストのエントリを（16ビットモードで
）調べるには、次のコマンドを発行します。

    DBG>ex/word *listhead,*(.+2),list_entry
    2134:0100  0001  013C  0774  8B55
    2134:013C  0002  011E  0770  8B97
    2134:011E  0003  0142  0074  8B34
    2134:0142  0004  0000  0070  8B55

ポインタ演算子*を使用して、メモリ間接参照を示しています。最初の行が表示され
た後、現在のメモリ位置"."は"2134:0100"と定義されます。すると、".+2"は"2134:
0102"で、"*(2134:0102)"は"013C"となります。したがって、表示される次のメモリ
位置は2134:013Cです。スペースバーを押すたびに、次のメモリ位置が表示され、"."
の値が更新されます。

    1.　上記の例で、list_entryを参照する場合に型情報を使っています。このよう
        な型名を指定するには、モジュールをコンパイルするときにコンパイラオプ
        ション"d1"または"d2"を指定しておかなければなりません。
    2.　さらに、アプリケーションをリンクするときに、そのモジュールが入ってい
        るオブジェクトファイル名の前に"debug types"または"debug all"リンカオ
        プションを指定しておかなければなりません。

メモリを命令として検査
----------------------
/Assembly addr_data　この修飾子を使用すると、Assemblyウィンドウが画面上にあ
            る場合には、Examineコマンドの出力はそのウィンドウに書き込まれま
            す。ない場合には、出力Dialogueウィンドウに書き込まれます。出力は
            Intel形式のニーモニックにフォーマットされます。数値は16進（基数
            16）表記法で表示されます。"<symbol_name>+offset"として表示される
            位置の場合には、"offset"の値は現在の基数で表示されます。

/Source addr_data　この修飾子を使用すると、Sourceウィンドウが画面上にある場
            合には、Examineコマンドの出力はそのウィンドウに書き込まれます。
            ない場合には、出力はDialogueウィンドウに書き込まれます。行番号情
            報とソースファイルの両方が使用可能な場合には、ソース行が表示され
            ます。行番号情報のだけが使用可能な場合には、行番号だけが表示され
            ます。両方とも使用不可能な場合には、Sourceウィンドウに行は表示さ
            れません。

            行番号情報が実行可能イメージファイルにあれば、そこから抽出されま
            す。ソースファイルを見つけることができたならば、ソース行はそのフ
            ァイルから抽出されます。詳細については、Set Sourceコマンドの説明
            を参照してください。

    addr_data ::= [start_addr_expr][","rpt_expr]

開始アドレスstart_addr_exprは、アセンブラ命令とソース行という書式で表示され
るメモリのセグメントとオフセットを定義する式です。繰返しカウントrpt_exprは、
コマンドを繰り返す数を定義する式です。正の繰返しカウントは、スペースバー
（next）を同じ回数押すのと同じです。負の繰返しカウントは、"P"キー（previous
）を同じ回数押すのと同じです。

例：
    DBG>examine/source main_
    DBG>e/s main_

上の例は２つの等価なコマンドを示しています。２番目の例は、単に１番目のコマン
ドの省略形にすぎません。アプリケーションのエントリポイントmain_に対応するソ
ース行が表示されます。

開始アドレスは、モジュール名と行番号で指定することもできます。

例：
    DBG>ex/source calendar@36

モジュールが検査中の現在のモジュールの場合には、モジュール名を指定する必要は
ありません。

例：
    DBG>ex/source @159

Sourceウィンドウに行番号が表示されています。ソース行番号を表示するためには、
ソース行情報が使用可能でなければなりません。

    1.　モジュールをコンパイルしたときに、コンパイラオプション"d1"または"d2"
        を指定しておかなければなりません。
    2.　アプリケーションをリンクするときに、そのモジュールが入っているオブジ
        ェクトファイルの名前の前に"debug lines"または"debug all"リンカオプシ
        ョンを指定しておかなければなりません。

Ｉ／Ｏポートの検査
------------------
/IOByte port_data　この修飾子を使用すると、指定したポートが読み出され、Exami
            neコマンドの出力はDialogueウィンドウに書き込まれます。出力は16進
            （基数16）表記法を使って８ビット値（バイト）にフォーマットされます。
/IOWord port_data　この修飾子を使用すると、指定したポートが読み出され、Exami
            neコマンドの出力はDialogueウィンドウに書き込まれます。出力は16進
            （基数16）表記法を使って16ビット値（ワード）にフォーマットされま
            す。各ワードの最上位バイトが最初に表示されます。

/IODword port_data　IODword修飾子は386システムまたはそれより上位のシステムで
            サポートされています。この修飾子を使用すると、指定したポートが読
            み出され、Examineの出力はDialogueウィンドウに書き込まれます。出
            力は16進（基数16）表記法を使って32ビット値（ダブルワード）にフォ
            ーマットされます。各ダブルワードの最上位バイトが最初に表示されま
            す。

    port_data ::= [start_addr_expr]["," rpt_expr]

開始アドレスstart_addr_exprは、データの読出しを開始するI/Oポートを定義する式
です。繰返しカウントrpt_exprは、コマンドを繰り返す回数を定義する式です。正の
繰返しカウントはスペースバー（next）を同じ回数押すのと同じです。
::::F77_OPERATORS
VIDEOはFORTRAN 77のほとんどの演算子をサポートし、便利なように追加の演算子の
セットを含んでいます。追加の演算子は、Ｃ言語で使用可能な演算子をまねて作られ
ています。

VIDEOがサポートする文法は、FORTRAN 77の文法に近いものですが、曖昧さをなくす
ために空白文字を使用しなければならない場合がいくつかあります。

    l.eq.x

たとえば、上の式では、VIDEOは文字列"eq.x"をそのまま残して"l."から浮動小数点
定数を作成するため、エラーが発生します。"l"の後に空白文字を１つ入力すれば、
この問題は解決します。

    l .eq.x

FORTRANと異なり、VIDEOのパーサーは、空白を意味のある文字として扱います。した
がって、シンボル名、定数、.EQ.や//などの複数の文字からなる演算子の中に空白を
入れないでください。

演算子は、優先順位の低いものから高いものへ順に示されています。同じ行にある演
算子は同じ優先順位を持っています。

                                                            優先順位が低い
    代入演算子
        =   +=  -=  *=  /=  %=  &=  |=  ^=  <<= >>=
    論理演算子
        .EQV.   .NEQV.
        .OR.
        .AND.
        .NOT.
    ビット演算子
        |
        ^
        &
    関係演算子
                .EQ.    .NE.    .LT.    .LE.    .GT.    .GE.
    シフト演算子および連結演算子
        <<  >>  //
    算術演算子
        +   -
        *   /   %
        **（サポートされていません）
    単項演算子
        +   -
        〜  ++  --  &   *   %
        [type_name] unary_expr
        ?
    ２項アドレス演算子
        :
                                                            優先順位が高い

括弧を使用して、式の評価を順序付けることができます。

以上の演算子の他に、いくつかの一次式演算子もサポートされています。以下の演算
子は、演算が行われるオブジェクトを識別するために使用されます。

()          添字、部分文字列、または関数呼出し

.           フィールド選択

->          ポインタを使用したフィールド選択

以下の組込み関数を使用して、指定した引数を特定の型に変換することができます。

        INT( )      整数型への変換
        REAL( )     実数型への変換
        DBLE( )     倍精度への変換
        CMPLX( )    複素数型への変換
        DCMPLX( )   倍精度複素数型への変換

以降の項では、上記の演算子について説明します。

ＦＯＲＴＲＡＮ文法の代入演算子
------------------------------
=       代入：右側の値を左側のオブジェクトに代入します。
+=      加算代入：左側のオブジェクトに右側の値を加えます。
-=      減算代入：左側のオブジェクトから右側の値を引きます。
*=      乗算代入：左側のオブジェクトに右側の値を掛けます。
/=      除算代入：左側のオブジェクトを右側の値で割ります。
%=      剰余代入：左側のオブジェクトをMOD（左、右）で更新します。結果は、左
        側のオブジェクトの値を右側の値で割ったときの剰余になります。
&=      ビット論理積：左側のオブジェクトのビットと右側の値のビットの論理積を
        とります。
|=      ビット論理和：左側のオブジェクトのビットと右側の値のビットの論理和を
        とります。
^=      ビット排他的論理和：左側のオブジェクトのビットと右側の値のビットの排
        他的論理和をとります。
<<=     左シフト：左側のオブジェクトのビットを右側の値の分だけ左へシフトします。>>=     右シフト：左側のオブジェクトのビットを右側の値の分だけ右へシフトしま
        す。左側のオブジェクトが符号なしとして記述されている場合には、空いた
        上位ビットはゼロで埋められます。左側のオブジェクトが符号付きとして記
        述されている場合には、符号ビットで空いた上位ビットを埋めます。VIDEO
        では、レジスタを符号なし項目として扱います。

ＦＯＲＴＲＡＮ文法の論理演算子
------------------------------
.EQV.   論理等価：左の値と右の値の論理等価をとります。
.NEQV.  論理不等価：左の値と右の値の論理不等価をとります。
.OR.    包含的論理和：左の値と右の値の論理和をとります。
.AND.   論理積：左の値と右の値の論理積をとります。
.NOT.   否定：右側の値の論理補数をとります。

ＦＯＲＴＲＡＮ文法のビット演算子
--------------------------------
|       ビット論理和：左の値のビットと右の値のビットの論理和をとります。
^       ビット排他的論理和：左の値のビットと右の値のビットの排他的論理和をと
        ります。
&       ビット論理積：左の値のビットと右の値のビットの論理積をとります。

ＦＯＲＴＲＡＮ文法の関係演算子
------------------------------
.EQ.    等しい：左側の値が右側の値に等しい場合には、結果は１になります。そう
        でない場合には、結果は０です。
.NE.    等しくない：左側の値が右側の値に等しくない場合には、結果は１になりま
        す。そうでない場合には、結果は０です。
.LT.    より小さい：左側の値が右側の値よりも小さい場合には、結果は１になりま
        す。そうでない場合には、結果は０です。
.LE.    等しいか、より小さい：左側の値が右側の値に等しいか、より小さい場合に
        は、結果は１になります。そうでない場合には、結果は０です。
.GT.    より大きい：左側の値が右側の値よりも大きい場合には、結果は１になります。                そうでない場合には、結果は０です。
.GE.    等しいか、より大きい：左側の値が右側の値に等しいか、より大きい場合に
        は、結果は１になります。そうでない場合には、結果は０です。

ＦＯＲＴＲＡＮ文法の算術／論理シフト演算子
------------------------------------------
<<      左シフト：左側の値のビットを右側の値が示す分だけ左へシフトします。
>>      右シフト：左側の値のビットを右側の値が示す分だけ右へシフトします。左
        側のオブジェクトが符号なしとして記述されている場合には、空いた上位ビ
        ットはゼロで埋められます。左側のオブジェクトが符号付きとして記述され
        ている場合には、符号ビットで空いた上位ビットを埋めます。VIDEOでは、
        レジスタを符号なし項目として扱います。

ＦＯＲＴＲＡＮ文法の連結演算子
------------------------------
//      文字列連結：左の文字列の値と右の文字列の値を連結します。

ＦＯＲＴＲＡＮ文法の２項算術演算子
----------------------------------
+       加算：右側の値を左側の値に加えます。
-       減算：左側の値から右側の値を引きます。
*       乗算：左側の値に右側の値を掛けます。
/       除算：左側の値を右側の値で割ります。
%       剰余：右側の値に対する左側の値の剰余を生成します。結果は、左側の値を
        右側の値で割ったときの剰余になります。
**      累乗：この演算は、VIDEOではサポートされていません。

ＦＯＲＴＲＡＮ文法の単項算術演算子
----------------------------------
+       正符号：結果は右側の値です。
-       負符号：結果は右側の値の符号反転です。
~       ビット補数：結果は右側の値のビット補数です。
++      インクリメント：前置演算子と後置演算子の両方がサポートされています。
        （++xのように）オブジェクトが右側にある場合には、そのオブジェクトが
        参照される前に１つインクリメントされます。（x++のように）オブジェク
        トが左側にある場合には、そのオブジェクトが参照された後に１つインクリ
        メントされます。
--      デクリメント：前置演算子と後置演算子の両方がサポートされています。
        （--xのように）オブジェクトが右側にある場合には、そのオブジェクトが
        参照される前に１つデクリメントされます。（x--のように）オブジェクト
        が左側にある場合には、そのオブジェクトが参照された後に１つデクリメン
        トされます。
&       アドレス：結果は、右側のオブジェクトのアドレス（セグメント：オフセッ
        ト）です（例：&main）。
*       間接参照：結果は、右側の値でアドレス指定した位置に格納されている値で
        す（例：*(ds:100)、*string.loc）。入力情報がない場合には、右側の値は
        スタックセグメントへのポインタとして扱われ、nearポインタが生成されます。
    (SS:00FE) = FFFF
var:(SS:0100) = 0152
    (SS:0102) = 1240
    (SS:0104) = EEEE

以下の例では、16ビットモードの場合にはDS:152から、32ビットモードの場合には
DS:12400152からメモリ位置がそれぞれ表示されます。

例：
    DBG>examine/byte *100

%       アドレスの値：結果は、右側の値でアドレス指定した位置に格納されている
        値です（例：%(ds:100)、%string.loc）。入力情報がない場合には、右側の
        値はスタックセグメントへのポインタとして扱われ、farポインタが生成さ
        れます。

    (SS:00FE) = FFFF
var:(SS:0100) = 0152
    (SS:0102) = 1240
    (SS:0104) = EEEE

以下の例では、16ビットモードの場合には1240:0152から、32ビットモードの場合に
はEEEE:12400152からメモリ位置がそれぞれ表示されます。

例：
    DBG>examine/byte %100

この演算子はFORTRAN 77言語にはないので注意してください。

ＦＯＲＴＲＡＮ文法の特殊な単項演算子
------------------------------------
?       存在検証："?"単項演算子を使用して、シンボルが存在するかどうかを検証
        することができます。

        例：
            DBG>print ?id

        "id"がVIDEOにとって既知のシンボルである場合には、この式の結果は１に
        なります。そうでない場合には、結果は０です。このシンボルが現在のスコ
        ープにない場合には、そのモジュール名で修飾しなければなりません。自動
        シンボルが存在するのは、現在のサブプログラムだけです。

ＦＯＲＴＲＡＮ文法の２項アドレス演算子
--------------------------------------
:       メモリ位置を参照するには、":"２項演算子とともに、定数、レジスタ名、
        およびシンボル名を組み合わせたものを使用します。Intel 80x86アーキテ
        クチャでは、メモリ参照には、セグメントとオフセットの指定が必要です。
        ":"演算子を使用したメモリ参照の形式は次のとおりです。

            segment:offset

        要素のsegmentとoffsetは、式にすることができます。

        例：
            (ES):(DI+100)
            (SS):(SP-20)

ＦＯＲＴＲＡＮ文法の一次式演算子
--------------------------------
()      添字式を使用して、配列の要素を識別できます。
.       "."演算子は、構造体でのフィールド選択を示します。この演算子は、アプ
        リケーションの一部がＣ言語で書かれている、２つの言語を併用したアプリ
        ケーションで役立ちます。以下の例では、tyme2は構造体で、tm_yearはその
        構造体の中のフィールドです。

        例：
            DBG>print tyme2.tm_year

->      "->"演算子は、構造体に対するポインタを使用するときのフィールド選択を
        示します。この演算子は、アプリケーションの一部がＣ言語で書かれてい
        る、２つの言語を併用したアプリケーションで役立ちます。以下の例では、
        tymeはポインタで、tm_yearはそのポインタが指す構造体の中のフィールド
        です。

        例：
            DBG>print tyme->tm_year
::::FLIP
+------------------------------------------------------------------------+
|　Flip [ON|OFf|expr]                                                    |
+------------------------------------------------------------------------+

Flipコマンドはアプリケーションの画面を表示するために使用します。DOSの下で
は、デバッガを起動するときに"Page"または"Swap"オプションを指定しておかなけれ
ばなりません。VIDEOの表示画面に戻るには、任意のキーを押すか、または左マウス
ボタンをクリックします。これらのどのオプションも指定していない場合には、この
コマンドを使っても効果はありません。

"on"および"off"オプションを使用して、画面を「オン」または「オフ」に切り替え
ます。デフォルトでは、リモートデバッグ機能を使用していなければ、VIDEOはアプ
リケーションの画面とデバッガの画面を切り替えます（flip on）。フリップを「オ
フ」にして、VIDEOがこの画面の切替えをしないようにすることができます。

式を指定すると、指定した秒数後にVIDEOは自動的にデバッガ画面に戻ります。この
時間間隔が経過する前に任意のキーを押すと、VIDEOはデバッガ画面に戻ります。式
を指定しないと、VIDEOはキーが押されるのをいつまでも待ちます。
::::GO
+------------------------------------------------------------------------+
|　Go      [start_addr_expr","][tmp_brk_addr_expr]                       |
|　Go [/Keep][start_addr_expr","]                                        |
+------------------------------------------------------------------------+

Goコマンドは、プログラムの実行を開始または続行するために使用します。指定した
開始アドレスstart_addr_exprから実行が再開されます。開始アドレスがない場合に
は、CS:IPレジスタ対またはCS:EIPレジスタ対の現在の内容によって定義される位置
から再開されます。

開始アドレスを指定する場合には、後にカンマを付けなければなりません。次の例
は、"rtn1"から実行を再開するようVIDEOに命令しています。

例：
    DBG>go rtn1,

下の例は、"rtn1"から実行を再開し、"rtn1+73"で命令を実行する前にその実行を停
止させるために、"rtnl+73"に一時的ブレークポイントを設定するようVIDEOに命令し
ています。

例：
    DBG>go rtn1,rtn1+73

一時的ブレークポイントは、開始アドレスなしで指定できます。一時的ブレークポイ
ントは普通のブレークポイントと似ていますが、１つしか使用できない点が異なりま
す。/Keepサブコマンドを指定しない場合には、Goコマンドを新たに発行するたび
に、前の一時的ブレークポイントがあれば、廃棄されます。前の一時的ブレークポイ
ントを保持したい場合には、（１つしか使用できないので）新しい一時的ブレークポ
イントは指定できません。

例：
    DBG>go rtn1
    DBG>go rtn2

この例では、rtn1の一時的ブレークポイントは、２番目のGoコマンドを発行したとき
にrtn2の一時的ブレークポイントによって置き換えられます。

例：
    DBG>go rtn1
    DBG>go

この例では、"rtn1"の一時的ブレークポイントは、２番目のGoコマンドを発行したと
きに削除されます。

例：
    DBG>go rtn1
    DBG>go/keep

この例では、"rtn1"の一時的ブレークポイントは、２番目のGoコマンドを発行しても
そのまま保持されます。

ブレークポイントの詳細については、Breakコマンドの説明を参照してください。

+------------------------------------------------------------------------+
|　注：　プログラムの実行を中断して、制御をデバッガに戻すことができます。|
|　プログラム実行を中断する方法については、各オペレーティングシステムにお|
|　けるVIDEOの使用法について解説した前にある章の「実行中のプログラムの中 |
|　断」の項を参照してください。リモートデバッグ機能を使用中のプログラム実|
|　行の中断方法は、「リモートデバッグ」の章で説明してあります。          |
+------------------------------------------------------------------------+
::::HELP
+------------------------------------------------------------------------+
|　Help [topic]                                                          |
+------------------------------------------------------------------------+

Helpコマンドを使用して、特定のトピックに関するヘルプを取得することができま
す。トピックを指定しない場合には、デフォルトのトピックが表示されます。デフォ
ルトのトピックには、ヘルプを使用できるトピックの一覧が入っています。

希望するトピックに対して一意な省略形を指定できます。

例：
    DBG>help go

この例は、VIDEOのGoコマンドに関するヘルプを要求しています。

ヘルプ情報はViewウィンドウに表示されます。ウィンドウ内のワード上にテキスト
カーソルを置いて、Enterキーを押すか、マウスでダブルクリックすると、VIDEOはそ
の名前でトピックを検索します。キーまたはマウスを用いたこのウィンドウの操作方
法については、「VIDEOウィンドウ」の章を参照してください。
::::IF
+------------------------------------------------------------------------+
|　IF expr if_cmd_list [else_cmd_list]                                   |
+------------------------------------------------------------------------+

指定した式を評価して、その結果が0以外の値である場合には、if_cmd_listに入って
いるデバッガコマンド並びが実行されます。そうでない場合には、else_cmd_listに
入っているコマンド並びが実行されます。２つのコマンド並びは中括弧（{}）を使っ
て区切られます。

例：
    DBG>break/set gorun { if x>100 {print{done}}{go/keep} }

この例では、"gorun"ルーチンに入るたびにブレークポイントが発生します。デバッ
ガはIFコマンドを評価して、その結果が「真」（すなわち、0以外の値）の場合に
は、メッセージ"done"がDialogueウィンドウに表示され、デバッガは別のコマンドの
入力を促します。「真」でない場合には、実行が再開されます（指定されている一時
的ブレークポイントは保持されます）。

次に示すコマンドは、アプリケーションで問題を見つけ出す場合に非常に便利です。
ここで、どのルーチンが"gorun"ルーチンを呼び出すと、"gorun"ルーチンを実行した
後、変数"x"が0値を持つようになるかを調べるものと仮定します。この例では、16
ビットアプリケーションと見なします。

例：
    DBG>br gorun {br %sp {if x==0 {} {br/c1 /.;go/k}}; go/k}

この例では、"gorun"ルーチンに入るたびに以下のコマンドが実行されます。

    br %sp {if x==0 {} {br/c1 /.;go/k}}
    go/k

最初のコマンドは、呼出し側ルーチンのリターンアドレスにブレークポイントを定義
します。"gorun"ルーチンは"far"コールによって呼び出されたものと仮定します。
すると、スタックの最上部には16ビットアプリケーションの32ビットセグメント：オ
フセットリータンアドレスが入っていることになります。２番目のコマンドはアプリ
ケーションの実行を再開します。呼出し側ルーチンに戻るたびに以下のコマンドが実
行されます。

    if x==0 {} {br/c1 /.;go/k}

"x"の値が0の場合には、コマンドは実行されず、デバッガに入ります（これが、探し
ているエラーのケースかもしれません）。0でない場合には、この位置に設定されて
いたブレークポイントは削除され、実行が再開されます（指定されていた一時的ブ
レークポイントは保持されます）。
::::INVOKE
+------------------------------------------------------------------------+
|　INvoke cmd_file{parm|"{"parm"}"}                                      |
|  <                                                                     |
+------------------------------------------------------------------------+

INvokeまたは＜コマンドは、多数のVIDEOコマンドが入ったファイルを呼び出すため
に使用します。ファイル指定cmd_fileのフォーマットはオペレーティングシステムに
よって異なります。DOS、MS Windows、およびOS/2のフォーマットは次のとおりです。

    [d:][path]filename[.ext]

ファイル接尾語またはファイル拡張子を指定しない（すなわち、ピリオドと拡張子の
両方を省略する）場合には、デフォルトの".dbg"をとります。

DOS、MS Windows、またはOS/2におけるコマンドファイルの検索順序は次のとおりで
す。

    1.　filenameまたはfilename.extだけを指定した場合には、VIDEOは最初にカレ
        ントディレクトリでファイルに見つけようとします。
    2.　VIDEOは次にPATH環境変数にリストされたパスを検索します。WATCOMコンパ
        イラパッケージの"BINB"ディレクトリがPATH環境変数に入っているか確認し
        てください。このディレクトリにはVIDEOと共に提供されているコマンド
        ファイルが入っています。

パラメータをコマンドファイルに渡すことができます。パラメータでセミコロン
（";"）またはスペースを使用する必要がある場合には、"{"および"}"を使用してく
ださい。これは、VIDEOがセミコロンをコマンド分離記号として、スペースをパラメ
ータ分離記号として解釈するためです。

パラメータはコマンドファイル中の<#>のシーケンスと突き合わせられます。ここで、
#は１から９の数字です。<1>が現れるたびに最初のパラメータと置き換えられ、<2>
が現れるたびに２番目のパラメータと置き換えられる、というようにそれぞれ置換え
が行われます。<0>が現れた場合には、ファイルを呼び出すたびにデバッガによって
与えられる一意の整数値と置き換えられます。この機能により、コマンドファイルが
呼び出されるたびに固有の変数を作成することができます。

VIDEOには多くのコマンドファイルが添付されています。これらのコマンドファイル
を使用してみると、コマンドファイルの優れた能力と柔軟性がわかります。

次の例では、ファイル"count.dbg"に以下の２行が入っていると仮定します。

    /cnt_<1>=0
    break/set <1> {/cnt_<1>++; go/keep}

以下のコマンドの１つを入力すると、

    invoke count printf
    <count printf

"<1>"が現れるたびに"printf"で置き換えられ、その結果生じるコマンドが実行され
ます。

例：
    DBG>/cnt_printf=0
    DBG>break/set printf {/cnt_printf++; go/keep}

"printf"ルーチンに入るたびに、デバッガはユーザ定義変数cnt_printfをインクリメ
ントして実行を再開します（指定した一時的ブレークポイントは保持されます）。ア
プリケーションの実行が終了すると、Printコマンドを使用してcnt_printfの現在値
を調べ、"printf"ルーチンが実行された回数を判定することができます。

例：
    set pf <1> {
        if !?_dbg@pf_<1> {/_dbg@pf_<1>=0};
        if (++_dbg@pf_<1>)&1 {<2> {<3>}
    }

この例は、"toggle.dbg"から取ったもので、３つのパラメータをコマンドファイルに
指定しています。

上の例に示したように、１つのVIDEOコマンド行を数行に分けてコマンドファイルの
行にすることができます。左大括弧（"{"）のところで行を分割できます。VIDEOはコ
マンド行を作成するため、対応する右大括弧（"}"）を見つけるまで入力行を読み込
み続けます。

コマンドファイルについてさらに知りたい場合には、Set Implicitコマンドの説明を
参照してください。
::::LOG
+----------------------------------------------------------------------------+
|　                                                                          |
|　Log  [/Start|/Append|>]file_name                                          |
|  >                                                                         |
+----------------------------------------------------------------------------+

Logまたは＞コマンドを使用して、Dialogueウィンドウの出力を指定ファイルにログ
採集することができます。

/Start file_name　
                この修飾子は指定したファイルへのログ採集を開始するために使用
                します。

                例：
                        DBG>log/start dbg.log
                        DBG>>/start dbg.log

                ファイルの前の内容は失われます（上書きされます）。file_name
                を指定して修飾子を指定しない場合には、/Startと見なされます。

                例：
                        DBG>log dbg.log

                修飾子もファイル名も指定しない場合には、現在オープンされてい
                るログファイルはクローズされます。

                例：
                        DBG>log

/Append file_name
                この修飾子は、ログ採集を開始して指定ファイルの終わりにログ記録
                を追加するために使用します。

                例：
                        DBG>log/append dbg.log
                        DBG>>/app dbg.log

>file_name      この演算子は"/append"と同義語です。したがって、/Append修飾子
                とまったく同じ働きをします。

                例：
                        DBG>log > dbg.log
                        DBG>>> dbg.log

ログファイルが現在オープンしている場合には、別のファイルにログ採集を開始する
前にログファイルをクローズしなければなりません。修飾子もファイル名も指定しな
いでLogコマンドを入力すると、現在のログファイルはクローズされます。デバッガ
が終了すると、ログファイルは自動的にクローズされます（Quitコマンドの説明を
参照してください）。

例：
        DBG>log/start debug.log

Dialogueウィンドウへの出力もファイル"debug.log"に書き込まれます。

例：
        DBG>log/append debug.log
        DBG>log> debug.log
        DBG>>> debug.log
        DBG>>/append debug.log

これらの例はすべて等価なLog/Appendコマンドの形式です。
::::MENUS
VIDEOメニュー
-------------
Set menu onコマンドを使用すると、画面の最上部にメニューバーが表示されます。
メニューは、いくつかの、より一般的なVIDEOコマンドに代わるものとして提供され
ています。以下の項ではメニューの使用法と各メニューの概要について説明します。

メニュー選択
------------
DOSおよびMS Windowsの下では、Altキーを押して離すことによってメニュー選択を活
動化することができます。以下のように、最初のメニュー項目名またはタイトルがハ
イライト表示されます。

その他のシステムでは（DOSおよびWindowsと同様に）メニューを選択するには、Alt
キーと選択するメニュー名の最初の１文字を押します（たとえば、ControlならAtl/C
を押します）。

Cursor LeftキーおよびCursor Rightキーを使用して、特定のメニュー項目をハイラ
イト表示することができます。ハイライト表示されたメニュー項目は、Enterキーを
使って選択できます。

場合によっては、メニュー項目が開いて、選択肢を表示します。それ以外の場合に
は、メニュー項目はすぐに処理を実行します。処理メニュー項目は"!"によって識別
され、メニュータイトルに付加されています（たとえば、Go!）。メニューのエント
リリストが表示されている場合には、Escapeキーを押すとクローズできます。もう１
度Escapeキーを押すとPromptウィンドウに戻ります。

または、Altキーとメニュー名またはメニュータイトルの最初の１文字を押してメ
ニュー項目を直接選択することもできます。たとえば、"Alt"キーと"C"キーを押す
と、"Control"メニューを活動化することができます（"C"キーを押す前に"Alt"キー
を押し下げておかなければなりません）。マウスがある場合には、メニューバーのメ
ニュー項目の１つにマウスカーソルを移動し左マウスボタンを押し下げて、同じ操作
を行うことができます。このボタンを離すと、現在選択されている項目が実行されます。
Cursor LeftキーまたはCursor Rightキーを使って、現在のメニューの左右にあるメ
ニューを選択することができます。左または右に移動すると、１つのメニューだけが
活動化されます。マウスを用いて、メニューバーのいろいろなメニュー項目でマウス
をドラッグして、同じ操作を行うことができます。

メニューが開く場合には、選択肢の１つがハイライト表示されます。これは、そのメ
ニューの現在の選択肢を示します。Cursor UpキーおよびCursor Downキーを使用し
て、他の選択肢を選択することができます。マウスを使うと、希望する項目にマウス
をドラッグして他の選択肢を選ぶことができます。項目がすでにハイライトされてい
る場合には、"Enter"キーを使って選択できます。マウスを使っている場合には、左
マウスボタンを離してください。

メニューを終了するには"Esc"キーを使います。マウスを使ってメニューを終了する
には、次の２の方法があります。

    1.　メニューの外側で左ボタンを離す。
    2.　メニューの外側をクリックする。

どちらを選ぶかは、表示されているメニューの種類によって異なります。

選択すると、さらに他のメニューが表示される場合があります。選択の方法は同じ
です。表示させる左右のメニューへ移動するには、Cursor LeftキーまたはCursor
Rightキーを使用します。各メニュー中で項目を選択するにはCursor UpキーとCursor
Downキーを使用します。選択したことを知らせるには、"Enter"キーを押してくださ
い。マウスを使って選択する場合には、ドラッグとクリックを行ってください。

Ｃｏｎｔｒｏｌメニュー
----------------------
Help    VIDEOの"Help"システムを呼び出すのに使用します。

System  システムのコマンドインタプリタまたは「シェル」を起動するのに使用しま
        す。たとえば、DOSを使っている場合には、"COMMAND.COM"プログラムが実行
        されます。特定の条件が満たされていないとシェルは動作できません。これ
        らの条件については、Systemコマンドの説明に示されています。

Restart 現在のアプリケーションを再起動するのに使用します。アプリケーションは
        メモリに再ロードされ、プログラムのエントリポイントで実行は中断されま
        す。ここで、"go main"などのVIDEOコマンドを入力できます。詳細は
        New/restartコマンドの説明を参照してください。

View    見たいファイルを選択するのに使用します。詳細はViewコマンドの説明を参
        照してください。

Log     ファイルへのVIDEOコマンドと応答のログ採集を開始するのに使用します。
        詳細はLogコマンドの説明を参照してください。

Quit    デバッガを終了するのに使用します。これによって現在のアプリケーション
        を終了します。詳細はQuitコマンドの説明を参照してください。

Ｕｓｅｒメニュー
----------------
これはユーザが定義できるメニュー項目のリストです。各エントリはSet menu addコ
マンドを使って作成されます。１つのエントリは、１つまたは複数のVIDEOコマンド
のリストになっています。新しい各エントリにはアルファベット１字のラベルが付け
られます。このため、Altキーと希望するエントリに対応する文字を押して、特定の
エントリを素早く選択することができます。マウスを使用してエントリを選択するこ
ともできます。

"User"メニューには最大20項目まで追加できます。

Ｄｉｓｐｌａｙメニュー
----------------------
このメニューを使って、テキストカーソルを直接特定のウィンドウに移動できます。
テキストカーソルを移動させたいウィンドウを選択してください。詳細はDisplayコ
マンドの説明を参照してください。

Ｐａｉｎｔメニュー
------------------
メニューを使って、全ウィンドウまたは特定のウィンドウのカラーを選択できます。

マウスを使用している場合、"Sample"ウィンドウをクリックするのは、Enterキーを
押すのと同じです。

詳細はPaintコマンドの説明を参照してください。

Ｂｒｅａｋ！メニュー
--------------------
"Break!"を選択すると、ブレークポイントを「設定」、「クリア」、「活動化」、ま
たは「非活動化」することができます。２つのウィンドウが表示されます。１つには
命令のセットが入っていて、もう１つには現在設定されているブレークポイントのリ
ストが入っています。

"S"、"C"、"A"、または"D"のキーを押して、希望する処理を選択できます。上向きお
よびCursor Downキーを使用して、個々のブレークポイントをハイライト表示するこ
とができます。

リスト上でマウスの通常の操作、すなわちクリックまたはドラッグを行って、ブレー
クポイントを選択することができます。命令ボックス内でクリックすると、該当する
キーを押したときと同一の処理が実行されます。たとえば、"s=set"が入っている象
現をクリックすると、"S"キーを押したときと同じ処理が実行されます。詳細はBreak
キーの説明を参照してください。

Ｗａｔｃｈ！メニュー
--------------------
"Watch!"を選択すると、ウォッチポイントを「設定」、「クリア」、「活動化」、ま
たは「非活動化」することができます。２つのウィンドウが表示されます。１つには
命令のセットが入っていて、もう１つには現在設定されているウォッチポイントのリ
ストが入っています。"S"、"C"、"A"、または"D"のキーを押して、希望する処理を選
択できます。Cursor UpキーおよびCursor Downキーを使用して、個々のウォッチポイ
ントをハイライト表示することができます。

リスト上でマウスの通常の操作、すなわちクリックまたはドラッグを行って、ウォッ
チポイントを選択することができます。命令ボックス内でクリックすると、該当する
キーを押したときと同じ処理が実行されます。たとえば、"s=set"が入っている象現
をクリックすると、"S"キーを押したときと同じ処理が実行されます。詳細はWatch
キーの説明を参照してください。

Ｔｒａｃｅ！メニュー
"Trace!"メニューを選択すると、Traceコマンド（デフォルトの引数を付けて）が実
行されます。プロンプトウィンドウにトレースプロンプトが現れます。トレースプロ
ンプトが表示されたなら、マウスカーソルが"Trace!"メニュー項目を指したままにし
て、左マウスボタンを押して"trace/over"を、右マウスボタンを押して"trace/into"
を選択することができます。

マウスがある場合には、キーを押す代わりにこのウィンドウの"hot-spots"をクリッ
クすることができます。たとえば、トレースの"into"オプションを選択する場合、
"<i>"ホットスポットをクリックするのは"I"キーを押すのと同じです。詳細はTrace
コマンドの説明を参照してください。

Ｇｏ！メニュー
--------------
"Go!"メニューを選択するとGoコマンドが実行されます。プログラムの実行は現在の
CS:IP（16ビットモード）またはCS:EIP（32ビットモード）位置から再開されます。
詳細はGoコマンドの説明を参照してください。
::::MODIFY
+------------------------------------------------------------------------+
|　Modify                                                                |
|　　[/Byte]  [addr_expr][","expr_list]                                  |
|　　/Word    [addr_expr][","expr_list]                                  |
|　　/Dword   [addr_expr][","expr_list]                                  |
|　　/Pointer [addr_expr][","expr_list]                                  |
|　　/IOByte  [port_expr][","expr_list]                                  |
|　　/IOWord  [port_expr][","expr_list]                                  |
|　　/IODword [port_expr][","expr_list]                                  |
+------------------------------------------------------------------------+

Modifyコマンドは、以下のいずれかの方法でメモリ内容を変更するために使用しま
す。

/Byte[addr_expr][","expr_list]　開始アドレスaddr_exprは８ビット値（バイト）
            シーケンスの始まりを識別します。指定した各値は256（0x100）を法と
            して格納されます。
/Word[addr_expr][","expr_list]　開始アドレスaddr_exprは16ビット値（ワード）
            シーケンスの始まりを識別します。指定した各値は65,536（0x10000）
            を法として格納されます。
/Dword[addr_expr][","expr_list]　開始アドレスaddr_exprは32ビット値（ダブル
            ワード）シーケンスの始まりを識別します。指定した各値は4,294,967,
            296（0x100000000）を法として格納されます。
/Pointer[addr_expr][","expr_list]　開始アドレスaddr_exprはセグメント／オフ
            セット対（セグメント：オフセット）シーケンスの始まりを識別しま
            す。16ビットモードでは、指定した対の各値は65,536（0x10000）を法
            として格納されます。32ビットモードでは、指定した対の各値は4,294,
            967,296（0x100000000）を法として格納されます。セグメント値を指定
            しない場合には、DSレジスタの現在の内容が使用されます。
/IOByte[port_expr][","expr_list]　開始ポートアドレスport_exprは８ビットポー
            ト（バイト）シーケンスの始まりを識別します。指定した各値は256
            （0x100）を法としてポートに書き込まれます。
/IOWord[port_expr][","expr_list]　開始ポートアドレスport_exprは16ビットポー
            ト（ワード）シーケンスの始まりを識別します。指定した各値は65,536
            （0x10000）を法としてポートに書き込まれます。
/IODword[port_expr][","expr_list]　　　IODword修飾子は386のシステムまたはそ
            れより上位のシステムでサポートされています。開始ポートアドレス
            addr_exprは32ビットポート（ダブルワード）シーケンスの始まりを識
            別します。指定した各値は4,294,967,296（0x100000000）を法として
            ポートに書き込まれます。

修飾子を指定しない場合には、デフォルトの/Byteをとります。値の並びを指定しな
い場合には、VIDEOは空の行が入力されるまで値の入力を促し続けます。ある位置を
変更したくないが、VIDEOが入力を促し続けるようにしたい場合には、スラッシュ
（"/"）を入力して現在値を保持するよう指示することができます。値の並びを指定
する場合、値を省略すれば（すなわち、カンマを２つ続けて入力すれば）その位置を
飛ばすことができます。

例：
    DBG>modify 0x200,1,2,3
    DBG>modify/byte 0x200,1,2,3

上の２つの例は等価で、メモリ位置DS:200、DS:201、およびDS:202が値１、２、およ
び３に変更されます。

例：
    DBG>modify 0x200,1,,3

この例では、メモリ位置DS:200とDS:202は値１と３に変更されます。

例：
    DBG>modify/word 304
    2335:0304= 0001 :- 0x100
    2335:0306= 1323 :- 0x101
    2335:0308= 8730 :- 0x102
    2335:030A= 0020 :-

この例では、VIDEOはメモリ位置DS:0304、DS:0306、DS:O3O8、およびDS:030Aを置き
換える新しいワード値の入力を促します。メモリ位置DS:030Aは変更しないので、プ
ロンプトに対してEntryキーを押しているだけです。

例：
    DBG>modify/word 0X304
    2335:0304= 0001 :- 0x100
    2335:0306= 1323 :- /
    2335:0308= 8730 :- 0x102
    2335:030A= 0020 :-

この例では、VIDEOはメモリ位置DS:0304、DS:0306、DS:O3O8、およびDS:030Aを置き
換える新しいワード値の入力を促します。メモリ位置DS:0306は変更しないので、プ
ロンプトに対して"/"を入力しているだけです。

例：
    DBG>modify/pointer _jmptable
    _jmptable= 2223:0602 :- &test1
    _jmptable+04 = 2223:06BE :- &test2
    _jmptable+08 = 2223:0743 :- &test3
    _jmptable+0A = 2223:07B7 :- &test4
    _CMAIN_ = 5756:5153:-

この16ビットの例では、VIDEOはラベル_jmptableで識別される連続したメモリ位置を
置き換える新しいセグメント：オフセットの入力を促します。ここでは４つのルーチ
ンのアドレス値を与えています（＆演算子は指定した位置のセグメント／オフセト値
を生成します）。_CMAIN_で識別されるメモリ位置は変更しないので、プロンプトに
対してEntryキーを押しているだけです。

例：
    DBG>modify/iobyte 0x3F9,0x0D,0x01,0x03,0x0B

この例では、ポート3F9、3FA、3FB、および3FCが16進数値0D、01、03、および0Bの値
に変更されます。

例：
    DBG>modify/ioword 0x2f8
    02F8= 000D :- 0X000E
    02FA= 0301 :- 0X0302
    02FC= 630B :- 0X630A
    02FE= 0000 :-

この例では、VIDEOはポート2F8、2FA、2FC、および2FEに格納する新しいワード値の
入力を促します。ポート2FEは変更しないので、プロンプトに対してEntryキーを押し
ているだけです。
::::NEW
+------------------------------------------------------------------------+
|　NEW                                                                   |
|　　[/Restart]  [prog_parms]                                            |
|　　/Program    [:sym_file]program_name[prog_parms]                     |
|　　/STDIn      [file_name]                                             |
|　　/STDOut     [file_name]                                             |
|　　/SYmbol     sym_file[expr_list]                                     |
+------------------------------------------------------------------------+

NEWコマンドはいろいろな項目を初期設定するために使用します。

/Restart [prog_parms]　この修飾子を使用して、現在のアプリケーションを再ロー
            ドし、実行を再び開始できる初期状態にします。アプリケーションは部
            分的または完全に実行されていてもかまいません。希望するなら、アプ
            リケーションに対して新しいコマンド行を指定することができます。

                prog_parms ::= prog_cmd_line|"{"prog_cmd_line"}"

            VIDEOはセミコロン（";"）をコマンド分離記号として使うので、コマン
            ド行にセミコロンを入れる場合には"{"と"}"を使わなければなりません。

            例：
                DBG>new {Today is Tuesday}

            修飾子を指定しない場合には、/Restart修飾子と見なされます。

/Program[:sym_file]program_name[prog_parms]　この修飾子を使用して、新しいア
            プリケーションをロードし、実行を開始できる初期状態にします。

            プログラムのシンボリックデバッグ情報が別ファイルに入れてある場合
            には、このファイルを指定できます。指定するファイル名の前にコロン
            （":"）を付けなければなりません。シンボルファイルのデフォルトの
            ファイル拡張子または接尾語は".sym"です。シンボリック情報ファイル
            は、WATCOMリンカまたはWATCOMストリップユーティリティを用いて作成
            できます。

            希望するなら、アプリケーションに対して新しいコマンド行を指定でき
            ます。

                prog_parms::=prog_cmd_line|"{"prog_cmd_line"}"

            VIDEOは";"をコマンド分離記号として使うので、コマンド行に";"を入
            れる場合には"{"と"}"を使わなければなりません。

            例：
                DBG>new/prog echo {Today is Tuesday}

            アクティブになっているブレークポイントまたはウォッチポイントはア
            クティブでなくなります。

            program_name指定のフォーマットはVIDEOコマンド行のフォーマットと
            同じです。DOS、MS Windows、OS/2、NetWare 386システムでは、フォー
            マットは次のとおりです。

                [d:][path]filename[.ext]

            プログラムの位置検出およびロードの意味は、特定のオペレーティング
            システムにおけるVIDEOの使用法に関する前の章で説明した意味と同じ
            です。

/STDIn[file_spec]　この修飾子を使用して、標準入力ファイルハンドルを特定の
            ファイルまたはデバイスに対応付けることができます。これは、コマン
            ド行に<file_specを指定するのと同じです。file_specを省略すると、
            標準入力ファイルハンドルは元の状態にリストアされます。

            次のコマンドは予想したとおりの効果は生じません。

            例：
                DBG>new/prog testit <input.fil

            その代わり、文字列"<input.fil"はパラメータとしてプログラムに渡さ
            れます。希望どおりの効果を得るには、以下に示す２つのコマンドを発
            行しなければなりません。

            例：
                DBG>new/prog testit
                DBG>new/stdin input.fil

/STDOut[file_spec]　この修飾子を使用して、標準出力ファイルハンドルを特定の
            ファイルまたはデバイスに対応付けることができます。これは、コマン
            ド行に>file_specを指定するのと同じです。file_specを省略すると、
            標準出力ファイルハンドルは元の状態にリストアされます。

            次のコマンドは予想したとおりの効果は生じません。

            例：
                DBG>new/prog hello >output.log

            その代わり、文字列">output.log"がパラメータとしてプログラムに渡
            されます。希望どおりの効果を得るには、以下に示す２つのコマンドを
            発行しなければなりません。

            例：
                DBG>new/prog hello
                DBG>new/stdout output.log

/SYmbol sym_file[expr_list]　この修飾子を使用して、追加のシンボリックデバッ
            グ情報をロードし、リンカアドレスと実際の実行アドレス間のマッピン
            グを指定します。この機能は、DOSの下でメモリ常駐型（Terminate-and-
            Stay-Resident,TSR）プログラムをデバッグする場合、FoxPro外部ルー
            チンをデバッグする場合、AutCAD ADS/ADIプログラムをデバッグする場
            合、またはこれらに類似した状況で役立ちます。

            シンボルファイルのデフォルトのファイル拡張子または接尾語は".sym"
            です。シンボリック情報ファイルは、WATCOMリンカまたはWATCOMスト
            リップユーティリティを用いて作成できます。

            sym_fileのフォーマットはシステムによって異なります。DOS、MS
            Windows、OS/2、NetWare 386システムでは、フォーマットは次のとおり
            です。

                [d:][path]filename[.ext]

            任意指定の式並びexpr_listは、デバッグするアプリケーションの種類
            によって異なります。16ビットのリアルモードアプリケーション（たと
            えば、DOS）では以下のように指定します。

                new/symbol sym_file seg1

            seg1はプログラムのベースアドレス（セグメント：オフセット）です。

            32ビットのプロテクトモード「フラットモデル」アプリケーション（た
            とえば、DOSエクステンダ、32ビットWindows、32ビットOS/2）では以下
            のように指定します。

                new/symbol sym_file seg1, seg2

            seg1は、プログラムのロードされたコードセグメント：オフセットです。
            seg2は、ロードされたコードセグメントに対するデータ／エクストラ／
            スタックセグメント・エイリアスです（「フラット」モデルでは、セグ
            メントCS、DS、ES、SSはすべて同じリニアアドレスにマップしますが、
            異なるセレクタ値を持ちます）。

            16ビットまたは32ビットのプロテクトモードセグメント・アプリケーシ
            ョン（たとえば、16ビットWindows、16ビットOS/2）では以下のように
            指定します。

                new/symbol sym_file seg1, seg2, seg3, ...

            segNは、プログラムのＮ番目のセグメントに対するロードされたセグメ
            ント：オフセット値です。

            segNが単純整数（たとえば、５）ならば、セグメント値を表すものと見
            なされ、オフセット部分は０と見なされます。seg:offを指定すると
            （たとえば、5:100）、"seg"はロードされたセグメント値となり、
            "off"はすべてのシンボルアドレスオフセットに追加されます。

            必要な、ロードされたセグメント値をすべて指定しない場合には、
            デバッガは足りない値の入力を促し始めます。

            NEW/SYmbolコマンドの例については、VIDEOコマンドファイルのADS.DBG
            またはFOX.DBGを参照してください。

            DOSアプリケーションをローカルでデバッグする場合には、デバッグの
            起動時にVIDEOの"Dynamic"オプションを指定する必要があるかもしれま
            せん。たとえば、"no memory for symbolic information"というメッ
            セージが表示される場合があります。その場合には、このオプションを
            指定しなければなりません。
::::NOTATION
VIDEOコマンドの構文を表現するために以下の表記法を使用しています。

Abc     項目abcの省略形はａになります。たとえば、項目"COMPute"の有効な形式
        は、"comp"、"compu"、"comput"、および"compute"です。
[abc]   項目abcはオプションです。
{abc}   項目abcは０回または１回以上反復できます。
"abc"   文字abcは必須です。
a|b|c   ａ、ｂ、ｃのどれか１つを指定できます。
a ::= b 項目ａは項目ｂによって定義されます。

上記の表記法を理解できたかどうか調べるため、以下の例を考えてみてください。

        dec_digit ::= "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"

この例では、10進数字（dec_digit）を"0"から"9"の文字の中に１つ（"0"または"1"
または"2"など）として定義しています。すると、10進数は以下のように定義できます。

        decimal_number ::= dec_digit{dec_digit}

これは、「10進数は、後に０個または１個以上の10進数字を伴う10進数字と定義
する」と解釈されます。明らかに"12345"は規則に適合していますが、"12ABC"や
"Hello"は適合していません。

VIDEOコマンドの記述ではさらにいくつかの略語も使用します。

省略形      意味

addr        アドレス
arg         引数
brk         ブレーク、ブレークポイント
char        文字
cmd         コマンド
expr        式
num         数字
parm        パラメータ
prog        プログラム
reg         レジスタ
spec        指定子
tmp         一時

さらにこれらの略語をアンダースコアで連結して、新しく略語を定義しています。

例：

addr_expr   アドレス式
cmd_spec    コマンド指定子

複数のコマンドをセミコロンで区切って、１行に入力することができます。

例：
    DBG>do myvar=var*2;print myvar

この例では、最初のコマンドは変数myvarにvarの２倍の値を設定し、２番目のコマン
ドはその新しい値を表示します。

これらの表記法を使って、以下のようにコマンド行を定義します。

    cmd_line ::= [cmd]{";"[cmd]}

このような定義は非常に正確ですが、幾分わかりにくくなりがちです。定義を注意深
く分析すると、空の行もコマンドとみなせることに気づきます。以後の項では、最初
に簡潔なコマンド構文を示します。その後に、そのコマンドの構文と意味を説明しま
す。また、そのコマンドの構文の「感じ」が掴めるように多くの例も示します。
::::OS2_INTERRUPTING_A_PROGRAM
プログラムをVIDEOによってロードすると、Goコマンドによって実行を開始すること
ができます（Goコマンドは「VIDEOコマンド」の章で説明してあります）。

例：
    [C:＼]wvideo myapp
    .
    .
    .
    DBG>go

開発段階ではよくあることですが、プログラムの実行が際限なく続くことがあり
ます。

OS/2の下では、VIDEOセッション中にCtrl/Breakキーの組合せを押してアプリケー
ションの実行を中断することができます。

VIDEOは、"Dialogue"ウィンドウにプログラムの実行が中断したことを示すメッセー
ジを表示します。Goコマンドを使って、実行を再開することができます。

また、VIDEOセッション中にCtrl/Breakキーの組合せを押してVIDEOコマンドの実行を
中断することもできます。

リモートデバッグ機能の使用中に実行中のプログラムを中断する方法については、
「リモートデバッグ」の章を参照してください。
::::OS2_REMOTE_DEBUGGING
+------------------------------------------------------------------------+
|　WVIDEO /TRap=trap_file[;trap_parm][:sym_file]file_spec[cmd_line]      |
+------------------------------------------------------------------------+

２台のコンピュータを使ってデバッグする場合と、仮想DOSマシン(VDM)デバッグサー
バーを使用する場合には、VIDEOのTRapオプションを指定しなければなりません。
file_specのフォーマットは、DOS、OS/2、NetWare 386など、ターゲットマシンのオ
ペレーティングシステムによって異なります。

例：
    [C:＼]wvideo /trap=par /reg=4 \users\fred\fdapp

trap_parmを指定し、それに空白文字が入っている場合には、そのパラメータ全体を
中括弧（{}）で囲まなければなりません。

１台目のコンピュータシステム（「タスクマシン」）上で起動されたデバッグサーバ
に対応する"trap"ファイルの名前を指定しなければなりません。これらのファイル
は、アプリケーションのリモートデバッグに必要なマシン対マシンの通信を処理しま
す。サーバについては、「リモートデバッグ」および「MS Windowsアプリケーション
のリモートデバッグ」の章で説明します。

OS/2では、デフォルトのファイル拡張子は".DLL"となります。"CONFIG.SYS"でOS/2の
LIBPATHコマンドを使用して、"DLL"トラップファイルの位置を識別しなければなりま
せん。トラップファイルは通常、VIDEOがインストールされているディレクトリの
"BINP＼DLL"サブディレクトリにあります。

STD16.DLL   OS/2バージョン1.xの下では、トラップファイルを指定しない場合に
            は、デフォルトのトラップファイル"STD16.DLL"がロードされます。こ
            のインタフェースモジュールは、OS/2 1.xが動作しているローカルコン
            ピュータシステム上でのデバッグをサポートします。リモートデバッグ
            はできません。

            OS/2バージョン1.xでは、トラップファイル名"STD"を指定すると、"STD16.
            DLL"が選択されます。

STD32.DLL   OS/2バージョン2.xの下では、トラップファイルを指定しない場合には、
            デフォルトのトラップファイル"STD32.DLL"がロードされます。このイ
            ンタフェースモジュールは、OS/2 2.xが動作しているローカル
            コンピュータシステム上でのデバッグをサポートします。リモートデ
            バッグはできません。

            OS/2バージョン2.xでは、トラップファイル名"STD"を指定すると、
            "STD32.DLL"が選択されます。

SER.DLL     この通信ドライバファイルは、２台のマシンのシリアルポートを使用し
            た、別のコンピュータシステムで動作するアプリケーションのデバッグ
            をサポートします。このファイルは"SERSERV"デバッグサーバと通信し
            ます。デバッガマシンのシリアルポートはタスクマシンのシリアルポー
            トと接続されます。"trap_parm"値は、使用するポート番号と任意指定
            の最大BAUDレート（ポート番号とピリオドで区切られています）を指定
            します。ポート番号は１、２、３、または４（デフォルトは１）です。
            これらの数字は、シリアルデバイス"COMx"（"COM1"、"COM2"など）を指
            定するときに使われるデバイス番号に対応します。

            OS/2の下では、最大BAUDレートを以下のうちのどれかすることができま
            す。
                 19200
                  9600
                  4800
                  2400
                  1200
                     0　（特別な場合）

            デフォルトの最大BAUDレートは19,200です。

            特別なBAUDレート０を除いて、希望する最大BAUDレートを識別するには
            少なくとも最初の２桁を指定しなければなりません。最大BAUDレートに
            ついては、「リモートデバッグ」の章の「シリアルポートを介したリ
            モートデバッグ」の項で説明します。以下の例では、ポート２と最大
            BAUDレート19,200が指定されています。

            例：
                /trap=ser;2.19

PAR.DLL     この通信ドライバファイルは、２台のマシンのパラレルポートを使用し
            た、別のコンピュータシステムで動作しているアプリケーションのデ
            バッグをサポートします。このファイルは"PARSERV"または"PARSERVW"
            （Microsoft Windows）デバッグサーバと通信します。デバッグマシン
            のパラレルポートはタスクマシンのパラレルポートと接続されます。使
            用するポート番号は"trap_parm"で指定します。ポート番号は１、２、
            または３（デフォルトは１）です。これらの数字はプリンタデバイス
            "LPTx"（"LPT1"、"LPT2"など）を指定するときに使われるデバイス番号
            に対応します。

NOV.DLL     この通信ドライバファイルは、Novellの"NetWare"ネットワーク
            （NetWareとNovellはNovell,Inc.の登録商標）に接続された別のコン
            ピュータシステムで動作するアプリケーションのデバッグをサポートし
            ます。このファイルは"NOVSERV"デバッグサーバと通信します。バー
            ジョン2.0またはそれ以降のNetWareを使用しなければなりません。バー
            ジョン1.3またはそれ以降のNetWareリクエスタも必要で、このリクエス
            タには逆にバージョン1.2またはそれ以降のOS/2が必要です。

            使用するサーバ名は"trap_parm"で指定します。サーバ名は、サーバを
            「タスク」マシン上で起動したときに指定した名前と一致していなけれ
            ばなりません。

NET.DLL     この通信ドライバファイルは、NetBIOSネットワークプログラミングイ
            ンタフェースを使用した、別のコンピュータシステムで動作しているア
            プリケーションのデバッグをサポートします。このファイルは"NETSERV
            "または"NETSERVW"（Microsoft Windows）デバッグサーバと通信しま
            す。使用するサーバ名は"trap_parm"で指定します。サーバ名は、サー
            バを「タスク」マシン上で起動したときに指定した名前と一致していな
            ければなりません。サーバ名は最大15字までの英数字です。

VDM.DLL     この通信ドライバファイルは、OS2 DOSボックス、またはWIN-OS/2セッ
            ションで走っているアプリケーションのデバッグをサポートします。
            このトラップファイルは、"VDMSERV"(OS/2 DOSボックス)、または
            "VDMSERVW"(WIN-OS/2)デバッグサーバーのどちらかと通信を行います。
            使用するサーバー名は、"trap_parm"で指定されます。サーバー名は、
            「タスク」マシン上でサーバーを起動したとき指定された名前と一致し
            ていなければなりません。
::::OS2_STARTUP
+------------------------------------------------------------------------+
|　WVIDEO [options][:sym_file]file_spec[cmd_line]                        |
+------------------------------------------------------------------------+

角括弧[]は任意指定の項目であることを表します。

WVIDEO      VIDEOのプログラム名です。
options     有効なVIDEOオプションのリストです。各オプションの前にはダッシュ
            （"-"）またはスラッシュ（"/"）を付けます。オプションの指定順は任
            意です。
sym_file    任意指定のシンボリックデバック情報ファイル指定です。前にコロン
            （":"）を付けなければなりません。OS/2のsym_fileの構文は次のとお
            りです。

            [d:][path]filename[.ext]

            シンボルファイルのデフォルトファイル拡張子は".SYM"です。
            シンボル情報ファイルは、WATCOMリンカWLINKまたはWATCOMストリップ
            ユーティリティWSTRIPによって作成することができます。
file_spec   メモリにロードされるファイルの名前です。OS/2のfile_specの構文は
            次のとおりです。

            [d:][path]filename[.ext]

            d:          "A:"、"B:"などの、任意指定のドライブ指定です。指定し
                        ない場合には、デフォルトドライブと見なされます。
            path        "＼UTILS＼BIN＼"のような任意指定のパス指定です。
            filename    メモリにロードされるファイルの名前です。
            ext         メモリにロードされるファイルの拡張子です。拡張子を入
                        力せず、ピリオド"."だけを入力して、NULLファイル拡張
                        子を指定できます。ファイル拡張子を指定しない（すなわ
                        ち、ピリオドと拡張子を省略した）場合には、デフォルト
                        として".EXE"をとります。
cmd_line    アプリケーションに渡される任意指定のコマンド行です。

ドライブとパスの両方を省略すると、VIDEOは最初にデフォルトドライブのカレント
ディレクトリでファイルを見つけようとします。ここでファイルが見つからない場合
には、PATH環境文字列にリストされた各パスでファイルを検索します。


コマンド行オプション
--------------------
+------------------------------------------------------------------------+
|　/Dynamic=space                                                        |
|　/NOFpu                                                                |
|　/Invoke=file_spec                                                     |
|　/Lines=number                                                         |
|　/NOInvoke                                                             |
|　/NOMouse                                                              |
|　/Registers=number                                                     |
|　/REMotefiles                                                          |
|　/NOSymbols                                                            |
|　/TRap=trap_file[;trap_parm]                                           |
+------------------------------------------------------------------------+

オプションの指定順は任意です。省略形を使って指定してもかまいません。上記の大
文字で書かれた部分が省略形です。"space"の後に"K"の文字が付いている場合には、
"space"は1Kバイト（1024バイト）の倍数を表します。"B"の文字が付いている場合に
は、"space"はバイト数を表します。後に何も付いていなくて、"space"が1000より小
さい数字の場合には、"space"は1Kバイト（1024バイト）の倍数を表すものと見なさ
れます。それ以外の場合にはバイト数を表します。

/Dynamic=space  VIDEOがウィンドウやユーザ定義シンボルなどの項目用に確保する
                動的メモリの初期容量を指定します。確保されるデフォルトの容量
                は40960バイト（40Kバイト）です。メモリを追加する必要がある場
                合には、VIDEOが割り当てます。
/NOFpu          数値演算コプロセッサの存在を無視するようデバッガに要求しま
                す。これにより、デバッガは80x87数値データコプロセッサのコン
                テキストを保存するためのメモリを割り当てません。アプリケー
                ションが数値演算コプロセッサを使用せず、またデバッガが必要と
                するメモリを削減したい場合には、このオプションを使ってくだ
                さい。
/Invoke=file_spec　スタートアップ時に自動的に呼び出されるデバッガのコマンド
                ファイルの代替名を指定するのに使用します。デフォルトのファイ
                ル名は"PROFILE.DBG"です。VIDEOコマンドファイルはカレントディ
                レクトリまたはOS/2のPATH環境文字列にリストされたディレクトリ
                の１つにあります。
/Lines=number   VIDEOが使用する表示行数を指定するのに使用します。拡張グラ
                フィックスアダプタ（EGA）がある場合には、43行の出力を要求で
                きます。ビデオグラフィックスアレイ（VGA）がある場合には、28
                行または50行の出力を要求できます。
/NOInvoke       デフォルトのデバッガコマンドファイルを呼び出さないよう指定し
                ます。
/NOMouse        接続されているマウスを無視するようデバッガに要求します。
/Registers=number　レジスタ内容を記録するために確保するレジスタセットの数を
                指定します。デフォルトのレジスタセット数は２です。詳細は
                Registerコマンドの説明を参照してください（このコマンドは
                「VIDEOコマンド」の章で説明してあります）。
/REMotefiles    デバッガのリモートデバッグ機能の指定と一緒に指定します。
                リモートデバッグには２台のパーソナルコンピュータを使用しま
                す。１台は「タスクマシン」と呼ばれ、アプリケーションの実行に
                使用し、もう１台は「デバッガマシン」と呼ばれ、デバッガの実行
                に使用されます。REMotefilesを指定すると、すべてのデバッガ
                ファイル（"trap"ファイルは除きます）とアプリケーションソース
                ファイルは、デバッガマシン上ではなく、タスクマシン上でオープ
                ンされます（ローカルデバッグを行っている場合には、これら２台
                のマシンは実際には同一です）。"trap"ファイルは、タスクマシン
                上のファイルをオープンするコードを含んでいるので、デバッガマ
                シンの方になければなりません。
                タスクマシンのPATH環境変数は常に実行可能イメージファイルを見
                つけ出すのに使用されることに注意してください。REMotefilesを
                指定すると、デバッガは、デバッガのコマンドファイルを見つけ出
                すのにも、タスクマシンのPATH環境変数を使用します。
/NOSymbols      実行可能イメージをロードするときにすべてのデバッグ情報を省略
                するようVIDEOに要求します。この要求により、グローバルシンボ
                ル名とローカルシンボル名、データ型、および行番号に関する情報
                は処理されません。
/TRap=trap_file[;trap_parm]　アプリケーションをリモートマシンでデバッグする
                場合には、このオプションを指定しなければなりません。VIDEOに
                添付された"trap"ファイルの１つの名前を指定しなければなりませ
                ん。OS/2の下では、デフォルトのファイル拡張子は".DLL"です。
                "BIN＼DLL"ディレクトリには、VIDEOに添付されているダイナミッ
                クリンクライブラリ（DLL）が入っています。"CONFIG.SYS"ファイ
                ルでOS/2のLIBPATHコマンドを使用して、"DLL"トラップファイルの
                位置を識別しなければなりません。
                TRapオプションを指定しない場合には、VIDEOはアプリケーション
                が同じコンピュータ上で動作されるものと見なして、下に示すデ
                フォルトトラップファイルの１つを使用します。

                例：
                    [C:＼]wvideo calendar

                OS/2バージョン1.xでは、トラップファイルを指定しない場合に
                は、デフォルトトラップファイル"STD16.DLL"がロードされます。
                このインタフェースモジュールは、OS/2 1.xが動作しているローカ
                ルコンピュータシステム上でのデバッグをサポートします。

                OS/2バージョン2.xでは、トラップファイルを指定しない場合に
                は、デフォルトトラップファイル"STD32.DLL"がロードされます。
                このインタフェースモジュールは、OS/2 2.xが動作しているローカ
                ルコンピュータシステム上でのデバッグをサポートします。

                トラップファイル名"STD"を指定した場合には、OS/2バージョン1.x
                システムには"STD16.DLL"が選択され、OS/2バージョン2.xシステム
                には"STD32.DLL"が選択されます。

                例：
                    [C:＼]wvideo /trap=std calendar

                もちろん、VIDEOが使用する「標準」トラップファイルを明示的に
                指定することもできます。

                例：
                    [C:＼]wvideo /trap=std16 calendar

                TRapオプションの詳細については、後にある「リモートデバッグ」
                の項を参照してください。
::::OS2_WVIDEO_ENVIRONMENT_VARIABLE
WVIDEO環境変数を使用して、よく使用するVIDEOオプションを指定することができま
す。あるオプションの指定に"="文字を使う場合には、その代わりに"#"文字を使用で
きます（これは"SET"コマンドの構文のために必要となります）。これらのオプショ
ンは、コマンド行で指定したオプションの前に処理されます。

例：
    [C:＼]set wvideo=/lines#50/reg#4

この例は、デバッガのデフォルトオプションの定義方法を示しています。

WVIDEO環境変数を定義すると、リストされたこれらのオプションはVIDEOを起動する
たびにデフォルトとなります。
::::PAINT
+------------------------------------------------------------------------+
|　PAint(window_name|["*"])attr_name[fg_col[","bg_col]]                  |
+------------------------------------------------------------------------+

PAintコマンドはウィンドウのカラー構成を定義するのに使用します。有効なウィン
ドウ名は次のとおりです。

    Assembly
    Command
    Dialogue
    Fpu
    Memory
    Prompt
    Register
    SOurce
    STack
    Thread

アスタリスク（"*"）を使用すると、これらすべてのウィンドウ名を示すことができ
ます。ウィンドウ名を省略すると、"*"と見なされます。

ウィンドウの５つの属性にそれぞれ色をつけることができます。使用できる
attr_nameを以下に示します。

    Plain
    Active
    Standout
    Title
    Gadget

以下の中からフォアグランドカラー（fg_col）を選択できます。

    BLAck
    BLUe
    GREEn
    Cyan
    Red
    Magenta
    Yellow
    White

さらに、以下に示すフォアグランドカラーのバリエーションを選択できます。

    BRIght BLAck
    BRIght BLUe
    BRIght GREEn
    BRIght Cyan
    BRIght Red
    BRIght Magenta
    BRIght Yellow (FM Rのみ)
    BRIght White
    GRAy
    GREY

"GRAy"および"GREY"は"BRIght BLAck"と同じです。
以下の中からとバックグランドカラー（bg_col）を選択できます。

    Normal
    Reverse

"BLINking"キーワードをフォアグランドカラーの前に付けて、項目を表示する
ときに明滅するように指定することもできます。IBMモノクロディスプレイとプリン
タアダプタでは、カラー属性は以下に示すように働くので注意してください。

カラー          モノクロ

black           （見えない）
blue            下線付きの白色
green           白色
cyan            白色
red             白色
magenta         白色
brown           白色
white           白色
bright black    （見えない）
bright blue     明るい白色
bright green    白色
bright cyan     白色
bright red      白色
bright magenta  白色
bright yellow   白色
bright white    白色

ウィンドウの項目にカラー属性を指定する場合には、フォアグランドカラーを先に指
定して、最後にバックグランドカラーを指定します。フォアグランドカラーまたは
バックグランドカラーの１つを省略すると、それは変更されません。バックグランド
カラーを指定する場合には、必ず前にカンマを付けてください。

属性            説明

Plain           各ウィンドウは"plain"属性のテキストを表示します。このテキス
                トは通常ウィンドウの大部分を占めます。

                例：
                    DBG>paint * plain white,normal

                この例では、全ウィンドウの"plain"属性のテキストは黒色をバック
                グランドとした白い文字に設定されます。

                例：
                    DBG>paint assembly plain green,reverse

                この例では、Assemblyウィンドウの"plain"属性のテキストだけが、
                緑色をバックグランドとした黒色の文字に設定されます。

Active          ウィンドウの一部の項目は、"actvie"カラー属性と組合せてハイラ
                イト表示することができます。たとえば、実行直前のソース行また
                はアセンブラ命令は"actvie"カラー属性で表示されます。

                例：
                    DBG>paint * active bright white,reverse

                この例では、全ウィンドウの"active"属性のテキストは、青色を
                バックグランドとした黒い文字に設定されます。

                例：
                    DBG>paint source active cyan,normal

                この例では、Sourceウィンドウの"active"属性のテキストだけが、
                黒色をバックグランドとしたシアン色の文字に設定されます。

Standout        ウィンドウの一部の項目は、"standout"カラー属性と組合せてハイ
                ライト表示することができます。たとえば、Examine/Sourceコマン
                ドを使用して表示されるソース行またはアセンブラ命令は、
                "standout"カラー属性で表示されます。

                例：
                    DBG>paint * standout red,reverse

                この例では、全ウィンドウの"standout"属性のテキストは、赤色を
                バックグランドとした黒色の文字に設定されます。

Title           各ウィンドウにタイトルを付け、そのタイトル行のカラーを選択す
                ることができます。

                例：
                    DBG>paint * title yellow,reverse

                この例では、タイトルがある全ウィンドウのタイトル行は、黄
                色をバックグランドとした黒色の文字で表示されます。

Gadget          マウスウィンドウの仕掛けは"gadget"カラー属性と組み合わせて表
                示されます。

                例：
                    DBG>paint * gadget cyan, reverse

                この例では、全ウィンドウの"gadget"カラーはシアン色をバックグ
                ランドとした黒色の文字に設定されます。
::::PRINT
+------------------------------------------------------------------------+
|　Print [/Program]{"{"format_spec"}"expr_list}                          |
|  ?                                                                     |
+------------------------------------------------------------------------+

Printまたは?コマンドは１つまたは複数の式を評価して、その結果をDialogueウィン
ドウ、または/Program修飾子を指定した場合にはアプリケーションの標準エラー領域
（通常はタスクマシンの画面）に表示します。Printコマンドは変数や式の値を調べ
るのに便利です。式にはレジスタ、アプリケーションの変数およびユーザ定義デバッ
ガ変数を指定できます。WATCOM C コンパイラおよびWATCOM FORTAN 77コンパイラで
使用できる演算をまねることができます。式は「VIDEO式の処理」の章で詳しく説明
してあります。

デフォルトでは、整数値は現在のデフォルト基数で、ポインタ値は16進表記法で、そ
して浮動小数点値は浮動小数点表記法でそれぞれ表示されます。さらに、式が列挙型
の場合には、式の数値に対応する列挙型定数の名前が表示されます。数値に対応する
列挙型定数がない場合には、数値は現在のデフォルト基数で表示されます。

数値をその他の表記法で表示するために、フォーマット文字列も指定できます。形式
的には、フォーマット指定は次のように定義されています。

    format_spec ::= {char|"%"specifier}
    specifier ::= "i"|"d"|"u"|"x"|"X"
                |"o"|"p"|"c"|"s"|"%"
                |"f"|"g"|"G"|"e"|"E"
                |"r"|"a"|"l"

テキストを入れて、出力に注釈を付けることができます。

指定子  説明

"i"     対応する引数を符号付き10進整数値として表示します。

"d"     対応する引数を符号付き10進整数値として表示します。

"u"     対応する引数を符号なし10進整数値として表示します。

"x"     対応する引数を符号なし16進整数値として表示します。文字は小文字で表示
        されます（a-f）。

"X"     対応する引数を符号なし16進整数値として表示します。文字は大文字で表示
        されます（A-F）。

"o"     対応する引数を符号なし８進整数値として表示します。

"p"     対応する引数を16進表記法でポインタ（セグメント：オフセット）値として
        表示します。

"c"     対応する引数を１文字として表示します。

"s"     対応する引数をＣ文字列として表示します。引数は、値が０のバイトで終了
        する文字列を指していなければなりません。

"%"     パーセント記号を表示するには、"%"を２個使わなければなりません（すな
        わち、%%）。

"f"     対応する引数を浮動小数点表記法で表示します。浮動小数点値が非常に大き
        いまたは非常に小さい場合には、"g"、"G"、"e"、または"E"フォーマットを
        使用しなければなりません。

"g"     対応する引数を浮動小数点表記法で表示します。非常に大きいまたは非常に
        小さい数字は科学計算用の"E"表記法（たとえば、1.54352e+16）で表示され
        ます。指数文字は小文字で表示されます。

"G"     対応する引数を浮動小数点表記法で表示します。非常に大きいまたは非常に
        小さい数字は科学計算用の"E"表記法（たとえば、1.54352E+16）で表示され
        ます。指数文字は大文字で表示されます。

"e"     対応する引数を科学計算用の"E"表記法（たとえば、1.23456e+02）で表示し
        ます。指数文字は小文字で表示されます。

"E"     対応する引数を科学計算用の"E"表記法（たとえば、1.23456E+02）で表示し
        ます。指数文字は大文字で表示されます。

"r"     対応する引数を現在のデフォルト基数で表示します。

"a"     可能な場合には、対応する引数をシンボル参照（simbol_name+offset）とし
        て表示します。不可能な場合には、16進表記法でポインタ（セグメント：
        オフセット）値として表示します。

"l"     可能な場合には、対応する引数を行番号参照（module_name@line_number+
        offset）として表示します。不可能な場合には、16進表記法でポインタ
        （セグメント：オフセット）値として表示します。

例：
    DBG>print ax
    DBG>? ax

AXレジスタの値が（デフォルトの基数を16と仮定して）16進フォーマットでDialogue
ウィンドウに表示されます。

例：
    DBG>? [dx ax]

DXレジスタとAXレジスタの内容が単一の32ビット長整数として扱われ、（デフォルト
の基数を16と仮定して）16進フォーマットでDialogueウィンドウに表示されます。
このようにレジスタをグループ化したものを集合体と呼びます。

例：
    DBG>? {%i} [cx bx]

CXレジスタとDXレジスタを結合して作成した集合体は32ビット長整数として扱われ、
10進整数値フォーマットで表示されます。

例：
    DBG>? (float) [ax bx]

型変換を使用して、このレジスタ集合体の長整数値は浮動小数点数値に変換され、
浮動小数点フォーマットで表示されます。

例：
    DBG>? [float] [ax bx]

型変更（pun）演算子を使用して、このレジスタ集合体の32ビット値は浮動小数点数
値として扱われ、浮動小数点フォーマットで表示されます。デフォルトでは、この32
ビット値は長整数として扱われます。

例：
    DBG>? [ax bx cx dx]

AX、BX、CX、およびDXレジスタからなる集合体は64ビット浮動小数点エンティティと
して扱われ、浮動小数点フォーマットで表示されます。デフォルトでは、64ビット
レジスタの集合体は倍精度浮動小数点値として扱われます。

例：
    DBG>print {The answer is %d (0x%x)} ans=foo/2, ans

fooの値を２で割った結果が、10進と16進の両フォーマットでDialogueウィンドウに
表示されます。

例：
    DBG>? &main_

main_のアドレス（セグメント：オフセット）がDialogueウィンドウに表示されます。

例：
    DBG>? {The address of "main" is %p} &main_

main_のアドレス（セグメント：オフセット）がテキスト文字列の一部としてDialog
ueウィンドウに表示されます。

例：
    DBG>? ax=dx

DXレジスタの内容がAXレジスタに割り当てられ、その結果がDialogueウィンドウに表
示されます。

例：
    DBG>print {%c-%c-%c-%c)3,4,5,6

"heart"、"diamond"、"club"、および"spade"文字が、ハイフンで区切られてDialo
gueウィンドウに表示されます。

例：
    DBG>print {%f} flt_vall

変数flt_vallが浮動小数点表記法で表示されます。

例：
    DBG>? {%i} (int) 3.1415926

引数が10進整数値３として表示されます。

例：
    DBG>? (char *) 256

引数（ポインタ）が16進表記法でポインタ値として表示されます（たとえば、"0100"
）。これはポインタのデフォルトのフォーマットです。

例：
    DBG>? {%r} (char *) 256

引数（ポインタ）が現在のデフォルト基数で表示されます（現在のデフォルト基数が
10進なら"0256"となります）。

次の16ビットの例を考えてみてください。

例：
    DBG>? {%x,%x} 65536, (short int) 65536

最初の引数、長整数65536は"10000"と表示されます。２番目の引数は、65536が符号
なし16ビット値の範囲を１だけ超えるため、短整数に変換され、"0"と表示されます。


配列の一部分の表示
------------------
VIDEOは、適切な型情報が使用可能なら、配列の内容を表示することができます。デ
フォルトでは、デバッガは配列全体の内容を表示します。次のＣプログラミング言語
で定義された３次元配列を考えてみましょう。

例：
    char *ProcessorType[2][4][2] =
        { { { "Intel 8086",  "Intel 8088" },
            { "Intel 80186", "Intel 80188" },
            { "Intel 80286", "unknown" },
            { "Intel 80386", "unknown" } },

          { { "NEC V30",     "NEC V20" },
            { "unknown",     "unknown" },
            { "unknown",     "unknown" }
            { "unknown",     "unknown" } } };

この配列は、４行２カラムから成る２層の方形行列とみることができます。配列要素
はすべて文字列値を指すポインタです。

配列の内容を調べるには、以下に示すコマンドを発行します。コマンドへの応答も示
します。

例：
    DBG>?processortype
    {[0]={[0]={[0]=0x0024, [1]=0x002F},
          [1]={[0]=0x003A, [1]=0x0046},
          [2]={[0]=0x0052, [1]=0x005E},
          [3]={[0]=0x0066, [1]=0x005E},
     [1]={[0]={[0]=0x0072, [1]= 0x007A},
          [1]={[0]=0x005E, [1]=0x005E},
          [2]={[0]=0x005E, [1]=0x005E},
          [3]={[0]=0x005E, [1]=0x005E}}}

表示された値は文字列値のアドレスです。

次元指定子を使って、配列の特定部分を表示することができます。次のコマンドを発
行すると、最初の層の値だけを見ることができます。

例：
    DBG>?processortype[0]
    {[0]={[0]={[0]=0x0024, [1]=0x002F},
          [1]={[0]=0x003A, [1]=0x0046},
          [2]={[0]=0x0052, [1]=0x005E},
          [3]={[0]=0x0066, [1]=0x005E}}

これは、前の例で表示されたアドレスの前半部分に相当します。

次のコマンドを発行すると、最初の層の最初の行だけを見ることができます。

例：
    DBG>?processortype[0][0]
    {[0]=0x0024, [1]=0x002F}

次のコマンドを発行すると、最初の層の２番目の行を見ることができます。

例：
    DBG>?processortype[0][1]
    {[0]=0x003A, [1]=0x0046}

すべてのインデックスを指定すると、行列中の特定のエントリの値を見ることができ
ます。

例：
    DBG>?{%s} processortype[0][0][0]
    Intel 8086
    DBG>?{%s} processortype[0][0][1]
    Intel 8088
    DBG>?{%s} processortype[0][1][0]
    Intel 80186

これらの例では、"%s"フォーマット指定子を使って文字列値を表示しています。
::::PRINT_WINDOW
+------------------------------------------------------------------------+
|　Print/Window expr                                                     |
|  ?/Windows                                                             |
+------------------------------------------------------------------------+

Print/Windowコマンドを使用して、動的に作成されるVariable Displayウィンドウに
Printコマンドの結果を表示することができます。

Variable Displayウィンドウは画面上に置かれ、変数および、それが構造体であれば
フィールドを含めて表示します。このウィンドウはデバッガに入るたびに更新されま
す。このウィンドウはその他のウィンドウと同じように操作することができます。
Variable Displayウィンドウは作成されたときにDialogueウィンドウのカラー属性を
引き継ぎます。Ctrl/Pキー（ペイント）を使用して、カラー属性を再定義することが
できます。Ctrl/Nキー（狭める）、Ctrl/Wキー（広げる）、Ctrl/Sキー（縮小する）、
Ctrl/Gキー（拡大する）を使ったり、マウスで「サイズ変更」仕掛けを操作して、
ウィンドウの大きさを変更することができます。Ctrl/Uキー（上）、Ctrl/Dキー（
下）、Ctrl/Lキー（左）、 Ctrl/Rキー（右）を使ったり、マウスでタイトル行をド
ラッグして移動することができます。Ctrl/Eキー（削除）を使ったり、マウスで「ク
ローズ」仕掛けをクリックして、ウィンドウを削除することができます。

構造体が表示されている場合には、Cursor UpキーおよびCursor Downキーを使用して
フィールドを上下に移動することができます。Enterキーを押して、フィールドの内
容を表示できます。Backspaceキーを押すと、前のレベルに戻ることができます。構
造体を表すエントリは"{...}"を使って表示され、配列を表すエントリは"(...)"を
使って表示されます。

本質的に、Enterキーを使うとネストされた構造体を「下る」ことができ、Backspace
キーを使うと前のレベルに戻ることができます。

エントリが文字列を表す場合には、"S"キーを使用して、エントリを文字列として表
示することができます。Backspaceキーを使って、元の表示フォーマットに戻すこと
ができます。

ウィンドウの一番上のエントリは、現在の構造体ネスティングレベルを表示します。
カーソルをこのエントリに移動して、編集することができます。エントリが構造体の
フィールドを表している場合には、その後書きフィールドを削除して前のレベルに戻
ることができます。新しいフィールドを追加すると、ネストされたフィールドへ下る
ことができます。

マウスを使ってフィールドを選択し、クリックして表示することができます。ウィン
ドウのダッシュ行をクリックすると、前のレベルに戻ります。

Escapeキーまたはマウスキーを使って、Promptウィンドウへ移動することができます。
::::QNX_DEBUGGING_USING_POSTMORTEM_DUMP
QNXは、サポートしておりません。
::::QNX_INTERRUPTING_A_PROGRAM
QNXは、サポートしておりません。
::::QNX_REMOTE_DEBUGGING
QNXは、サポートしておりません。
::::QNX_SEARCH_ORDER
QNXは、サポートしておりません。
::::QNX_STARTUP
QNXは、サポートしておりません。
::::QNX_WVIDEO_ENVIRONMENT_VARIABLE
QNXは、サポートしておりません。
::::QUIT
+------------------------------------------------------------------------+
|　QUIT                                                                  |
+------------------------------------------------------------------------+

QUITコマンドは、VIDEOを終了してオペレーティングシステムに戻るために使用しま
す。途中まで実行されていたアプリケーションも打ち切られます。
::::REGISTER
+------------------------------------------------------------------------+
|　Register[expr]                                                        |
+------------------------------------------------------------------------+

Registerコマンドは、VIDEOレジスタセットを選択するために使用します。

VIDEOは、入力されるたびに現在のレジスタ値をレジスタセットのリングに保存しま
す。このリングのサイズは起動時にRegisterオプションを用いて決定されます（デ
フォルトは２で最大値は100です）。式の結果が負の場合には、前のレジスタセット
が選択されます。式の結果が正の場合には、もっと最近のレジスタセットが選択され
ます。式を省略すると、現在のレジスタセットが選択されます。

Registerウィンドウが画面上にない場合には、レジスタ表示はDialogueウィンドウに
書き込まれます。RegisterウィンドウはDisplay Registerコマンドを使って作成しま
す。最も近い時点のレジスタセットが選択されている場合には、Registerウィンドウ
のどこかに大括弧に囲まれた数字が現れます。この数字は、現在表示されているもの
より新しいレジスタセットの数を表しています。GoまたはTraceコマンドを発行する
と、現在表示されているレジスタセットが「現在の」レジスタ値になります。この機
能により、ユーザは「チェックポイント／再開始」機能が使用できます。

例：
    DBG>register -1

この例では１つ前のレジスタセットに戻ります。
::::REMARK

+------------------------------------------------------------------------+
|　REMark comment_line                                                   |
|　*                                                                     |
+------------------------------------------------------------------------+

REMarkまたは*コマンドを使用して、VIDEOコマンドファイルに説明を付けることがで
きます。

例：
    * Count the number of times a routine is executed
      /cnt_<1>=0
    * Remove the break point definition
    * just in case one already exists
      break/clear /<1>
    * Set the new break point
      break/set <1> {/cnt_<1>++; go/keep}
::::REMOTE_DEBUGGING
リモートデバッグの概念
----------------------
２台のコンピュータを使って、１台でアプリケーションを動かし、もう１台でデバッ
ガを動かす「リモートデバッグ」について、説明します。これには、WindowsやOS/2
のようなマルチプログラミング・オペレーティングシステムでのマルチプルセッショ
ンの使用を含みます。これは、複数の「仮想」コンピュータを走らせていると考えら
れます。リモートデバッグの概念上、この２つのケースは本質的に同じことになります。

リモートデバッグでは、アプリケーションをデバッグするのに、２台のコンピュータ
を使用します。一方のPCは「タスクマシン」と呼ばれ、アプリケーションを走らせる
ために使用されます。もう一方のPCは「デバッガマシン」と呼ばれ、デバッガを走ら
せます。アプリケーションとデバッガの両方を走らせるのに十分なメモリがないとき
に、リモートデバッグは使用されます。

リモートデバッグの機能を使用するとき、デバッグされるアプリケーションは、オペ
レーティングシステムがそれをロードできるように、タスクマシンに入れておかなけ
ればなりません。アプリケーションのソースファイルは、モジュールに対応したソー
ス行を表示できるように、デバッガマシンからアクセスできるところになければなり
ません。

２台のコンピュータを使用したアプリケーションのデバッグ
------------------------------------------------------
ここで、PC#1がユーザの主開発マシンと仮定します。このマシンにはアプリケーショ
ン、そのデータファイルとソースファイル、およびアプリケーションを開発するため
に使用しているプログラム（エディタ、コンパイラ、リンカ、デバッガなど）が入っ
ています。また、PC#2はユーザが使用できる予備のマシンと仮定します。２つのコン
ピュータシステムが関係しているので、次の２つの状況が考えられます。

    1.　アプリケーションと必要なデータファイルをPC#2にコピーできます。この状
        況では、主開発マシン（PC#1）はデバッガを実行するのに使用します。アプ
        リケーションのソースファイルはデバッガマシンにあります。

    2.　デバッガをPC#2にコピーできます。この状況では、主開発マシン（PC#1）は
        アプリケーションを実行するのに使用します。アプリケーションのすべての
        ソースファイルをPC#2にコピーしないかぎり、デバッガはそれらにアクセス
        できません。この場合、VIDEOの"REMotefiles"オプションを使用して、ソー
        スファイルは通信リンクを通してタスクマシン（PC#1）から得られることを
        デバッガに知らせることができます。"REMotefiles"オプションにはもう１
        つの利点があります。それは、デバッガがデフォルトとしてデバッガのコマ
        ンドファイルもタスクマシン上で見つけることです。このオプションを指定
        しない場合には、デバッガコマンドファイルもデバッガマシン（PC#2）にコ
        ピーしなければなりません。

どのマシンをタスクに使い、どのマシンをデバッガに使うかはユーザの判断次第で
す。場合によっては、各マシンの使用可能メモリ量やそれぞれのプロセッサの処理速
度によって決まります。たとえば、アプリケーションに大量のメモリが必要な場合に
は、当然メモリの大きなマシンをタスクマシンにします。アプリケーションの実行速
度が重要な場合には、当然処理速度が速い方をタスクマシンにします。

注：

    1.　アプリケーションのリモートデバッグをサポートするには、バージョン2.0
        またはそれ以降のDOSが必要です。

    2.　アプリケーションのリモートデバッグをサポートするには、バージョン3.0
        またはそれ以降のMicrosoft Windowsが必要です。

    3.　アプリケーションのリモートデバッグをサポートするには、バージョン1.2
        またはそれ以降のOS/2が必要です。

    4.　NetWareサーバ上で動作するアプリケーションのリモートデバッグをサポー
        トするには、バージョン3.1またはそれ以降のNetware 386が必要です。
        リモートデバッグ機能を使用するには、デバッガマシンでVIDEOを起動する
        前にサーバタスクをタスクマシン（NetWareサーバ）上で動作させなければ
        なりません。

ＤＯＳおよびＯＳ／２での通信サーバ
----------------------------------
DOSおよびOS/2の下でVIDEOと共に使用するためのサーバがいくつか提供されていま
す。

SERSERV.EXE
        このプログラムはシリアルポートを介するリモートデバッグをサポートし
        ます。

PARSERV.EXE
        このプログラムはパラレルポートを介するリモートデバッグをサポートし
        ます。

NOVSERV.EXE
        このプログラムはNovellの"NetWare"ネットワークを介するリモートデバッ
        グをサポートします。

NETSERV.EXE
        このプログラムはNetBIOSサポートを使用するリモートデバッグをサポート
        します。

DQVSERV.EXE
        （DOSのみ）このプログラムはDESQviewを使用するリモートデバッグをサ
        ポートします。以下の説明では、「タスクマシン」はサーバが起動される
        DESQviewウィンドウ、「デバッガマシン」はデバッガが起動されるDESQview
        ウィンドウをそれぞれ指しています。

VDMSERV.EXE     (OS/2のみ)OS/2 DOSボックスまたはセッションで動作しているアプ
        リケーションのリモートデバッグをサポートします。以下の説明で、「タス
        クマシン」はサーバーが起動しているOS/2 DOSセッション、「デバッガマシ
        ン」はデバッガが起動しているOS/2セッションを意味しています。

WINSERV.EXE
        （Microsoft Windows 3.xのみ）このプログラムはWindows DOSボックスを使
        用するリモートデバッグをサポートします。以下の説明では、「タスクマシ
        ン」はサーバが起動されるWindows DOSボックス、「デバッガマシン」はデ
        バッガが起動されるWindows DOSボックスをそれぞれ指しています。

これらのプログラムについて以下の項で説明します。コマンド行の一般的な構文を以
下に示します。
+------------------------------------------------------------------------+
|　server_name[/TRap=trap_file[;trap_parm]]server_specs                  |
+------------------------------------------------------------------------+

/TRapオプションは次の３つの場合だけ指定します。

    1.　DOSの下で、サーバタスクが386/486デバッグレジスタ（デバッグを支援する
        ために使用されるハードウェア機能）を使用しないようにするため

    2.　DOSエクステンダのサービスを必要とする386アプリケーションに対して

    3.　３つ以上のコンピュータシステムがチェーンとして接続される特殊なアプリ
        ケーションの場合

一般に、サーバプログラムは別のコンピュータシステム（デバッガマシン）から要求
を受信します。サーバプログラムはこれらの要求をローカルで処理するか、または別
のコンピュータシステムで動作しているサーバに渡すことができます。

STD.TRP、STD16.DLL、STD32.DLL
        デフォルトでは要求は、DOSが動作している場合には"STD.TRP"ファイルに
        よって、OS/2 1.xが動作している場合には"STD16.DLL"ファイルによって、
        OS/2 2.xが動作している場合には"STD32.DLL"ファイルによってそれぞれ
        ローカルで処理されます。

        DOSの下では、サーバタスクが386/486デバッグレジスタ（デバッグを支援す
        るために使用されるハードウェア機能）を使用しないようにする必要がある
        かもしれません。DOS制御プログラムがデバッグレジスタを正しく管理しな
        い場合には、使用しないようにする必要があります。386/486システム上で
        サーバタスクがうまく起動できない場合には、デバッグレジスタを使用禁止
        にしなければならないことを示しています。"STD.TRP"を用いる場合には、
        トラップファイルパラメータ"d"を指定してデバッグレジスタの使用を禁止
        することができます。下にトラップファイルパラメータ"d"の指定例を示し
        ます。

        例
            C>serserv /trap=std;d
                または
            C>parserv /trap=std;d
                など

PLS.TRP アプリケーションをタスクマシン上でPhar Lap Software,Incの386|DOS-
        Extenderを用いて実行している場合には、"PLS.TRP"インタフェース
        モジュールを通信サーバと一緒に使用することができます。"trap_parm"
        オプションはコマンド行スイッチとしてDOSエクステンダ"RUN386"に渡され
        ます。

        例
            C>serserv /trap=pls
                または
            C>parserv /trap=pls
                など

RSI.TRP アプリケーションをタスクマシン上でRational Systems,Incの"DOS/4G" DOS
        エクステンダを用いて実行している場合には、"RSI.TRP"インタフェース
        モジュールを通信サーバと一緒に使用することができます。このDOSエクス
        テンダはWATCOM C/386およびWATCOM FORTRAN 77/386パッケージに入ってい
        ます。"trap_parm"オプションは無視されます。

        例
            C>serserv /trap=rsi
                または
            C>parserv /trap=rsi
                など


WindowsとWIN-OS/2のコミュニケーションサーバー
---------------------------------------------
Windows 3.xアプリケーションのデバッグについての詳細は、21ページの「Windowsア
プリケーションのリモートデバッグ」の章で、説明します。詳しい情報は、そちらを
参照してください。


Ｎｏｖｅｌｌ　ＮｅｔＷａｒｅでの通信サーバ
------------------------------------------
Novell NetWare 386の下でVIDEOと共に使用するために３つのサーバが提供されてい
ます。

SERSERV.NLM
        このプログラムはシリアルポートを介するリモートデバッグをサポートしま
        す。

PARSERV.NLM
        このプログラムはパラレルポートを介するリモートデバッグをサポートしま
        す。

NOVSERV.NLM
        このプログラムはNovellの"NetWare"ネットワークを介するリモートデバッ
        グをサポートします。

これらのプログラムについて以下の項で説明します。コマンド行の一般的な構文を以
下に示します。

+------------------------------------------------------------------------+
|　LOAD server_name server_specs                                         |
+------------------------------------------------------------------------+

例：
    : LOAD PARSERV 2

この例では、通信にNetWareのパラレルポート２を使用するパラレルポートサーバを
ロードします。


ＰＣ対ＰＣ通信リンクの例
------------------------
下の図は、DOSの下で動作するVIDEOを使用して、別のコンピュータシステム上のDOS
の下で動作するアプリケーションをデバッグする例を示しています。ここではシリア
ル通信を使用しています。

        PC #1                       PC #2
+-------------------+        +-------------------+
|  デバッガマシン   |        |　　タスクマシン   |
|       DOS         |        |        DOS        |
|                   |        |                   |
|     WVIDEO        |     +--|---->PARSERV       |
|       ↓          |     |  |        ↓         |
|　　               |     |  |                   |
|トラップハンドラ<--|-----+  | トラップハンドラ  |
|    PAR.TRP        |        |      STD.TRP      |
+-------------------+        +-------------------+

図21.　DOSからDOSへのリモートデバッグ

下の図は、DOSの下で動作するVIDEOを使用して、別のコンピュータシステム上のOS/2
の下で動作するアプリケーションをデバッグする例を示しています。ここではシリア
ル通信を使用しています。

        PC #1                       PC #2
+-------------------+        +-------------------+
|  デバッガマシン   |        |　　タスクマシン   |
|       DOS         |        |       OS/2 1.x    |
|                   |        |                   |
|     WVIDEO        |     +--|ｰｰｰｰ>SERSERV       |
|       ↓          |     |  |        ↓         |
|　　               |     |  |                   |
|トラップハンドラ<--|-----+  | トラップハンドラ  |
|    SER.TRP        |        |     STD16.DLL     |
+-------------------+        +-------------------+

図22.　DOSからOS/2へのリモートデバッグ

下の図は、OS/2の下で動作するVIDEOを使用して、別のコンピュータシステム上のDOS
エクステンダの下で動作するアプリケーションをデバッグする例を示しています。
ここではシリアル通信を使用しています。

        PC #1                       PC #2
+-------------------+        +-------------------+
|  デバッガマシン   |        |　　タスクマシン   |
|      OS/2         |        |  386|DOS-Extender |
|                   |        |                   |
|     WVIDEO        |     +--|ｰｰｰｰ>SERSERV       |
|       ↓          |     |  |        ↓         |
|　　               |     |  |                   |
|トラップハンドラ<--|-----+  | トラップハンドラ  |
|    SER.DLL        |        |       PLS.TRP     |
+-------------------+        +-------------------+

図23.　OS/2からDOSエクステンダへのリモートデバッグ

この他にもいろいろな組み合せが可能です。下の図は、DOSの下で動作するVIDEOを使
用して、１番目のコンピュータシステムに間接的に接続されている３番目のコン
ピュータシステム上のDOSの下で動作するアプリケーションをデバッグする例を示し
ています。ここでは、PC#1からPC#2への接続にはパラレル通信を使い、PC#2からPC#3
への接続にはNetWareネットワーク通信を使っています。

        PC #1                       PC #2                       PC #3
+-------------------+        +-------------------+        +-------------------+
|　デバッガマシン   |        |　　中間マシン 　  |        |   タスクマシン    |
|       DOS         |        |        DOS        |        |        DOS        |
|                   |        |                   |        |                   |
|     WVIDEO        |     +--|---->PARSERV       |     +--|---->NOVSERV       |
|       ↓          |     |  |        ↓         |     |  |       ↓          |
|　　               |     |  |                   |     |  |                   |
|トラップハンドラ<--|-----+  |トラップハンドラ<--|-----+  | トラップハンドラ  |
|    PAR.TRP        |        |     NOV.TRP       |        |     STD.TRP       |
+-------------------+        +-------------------+        +-------------------+

図24.　中間マシンを経由したリモートデバッグ

注：

    1.　キーボード入力に関して次のことに注意しなければなりません。デバッガに
        対して入力するものはすべてデバッガマシンに入力しなければなりません。
        同様に、デバッグするアプリケーションに対する入力はすべてタスクマシン
        に入力しなければなりません。

    2.　画面出力に関しても同様です。　デバッガの出力はすべてデバッガマシン上
        に表示されます。一方、プログラムの出力はすべてタスクマシンに表示され
        ます。

シリアル通信およびパラレル通信に必要な配線方法については、付録の「リモートデ
バッグの配線」で説明してあります。


シリアルポートを介するリモートデバッグ
--------------------------------------
シリアルポートを介してリモートデバッグを行うには、デバッガマシン上でVIDEOを
起動する前にタスクマシン上でサーバタスクを動作させる必要があります。これは、
VIDEOがこの特殊なサーバプログラムを介してすぐにタスクマシンと通信を開始する
ためです。

シリアル通信に必要な配線方法については、付録「リモートデバッグの配線」の
「シリアルポート配線上の注意事項」の項で説明してあります。

デバッガとサーバは通信速度で自動的に同期します。最高115,200 BAUDで通信するこ
とができます。BAUDレート、パリティ、そしてデータビット数とストップビット数は
自動的に選択されるので、DOSまたはOS/2の"MODE"コマンドを使う必要はありません。

DOSおよびOS/2のシリアルポート・デバッグサーバの形式的なコマンド行構文を以下
に示します。

+------------------------------------------------------------------------+
|　SERSERV [/TRap=trap_file[;trap_parm]][port_number][.max_baud]         |
+------------------------------------------------------------------------+

NetWare 386のシリアルポート・デバッグサーバの形式的なコマンド行構文を以下に
示します。

+------------------------------------------------------------------------+
|　LOAD SERSERV [port_number][.max_baud]                                 |
+------------------------------------------------------------------------+

シリアルサーバの"port_number"は、サーバがデバッガマシン上で動作するVIDEOと通
信するのに使用するシリアルポート番号（１、２、３など）です。デフォルトのポー
ト番号は１です。

DOS、OS/2、およびNetWare 386では、これらの番号はシリアルデバイス"COMx"
（"COM1"、"COM2"など）を指定するときに使用するデバイス番号に対応します。

シリアルポートが別ノードにある場合には、ノードIDを指定しなければなりません。
ノードIDを指定し、ポート番号を指定しない場合には、ポート番号はデフォルトとし
て１をとります。

    [nid,][port_number][.max_baud]

ノード番号を最初に指定し、次にコンマ、そして最後にポート番号を指定します。

例：
    serserv 7,2.9600

任意指定の"max_baud"値は最大BAUDレートを指定します。この値はピリオドでポート
番号と区切られています。

DOSの下では、最大BAUDレートを以下のうちのどれかにすることができます。

        115200
         57600
         38400
         19200
          9600
          4800
          2400
          1200
             0　（特別な場合）

デフォルトの最大BAUDレートは115,200です。

OS/2の下では、最大BAUDレートを以下のうちのどれかにすることができます。

         19200
          9600
          4800
          2400
          1200
             0　（特別な場合）

デフォルトの最大BAUDレートは19,200です。

特別の場合のBAUDレート０を除いて、希望する最大BAUDレートを識別するためには少
なくとも最初の２桁を指定しなければなりません。２台のマシン間で効率よく通信で
きる最大BAUDレートが分かっている場合には、その値を指定すると便利です。通常、
サーバとデバッガは可能な最大速度で起動し、効果的な（エラーのない）レートにな
るまで徐々に速度を落としていきます。事前に最大BAUDレートを指定しておけば、
スタートアップ時間を短縮することができます。実際に選択されるBAUDレートは、
サーバとデバッガの両方が起動されたときに指定された最大レートの最小値で、これ
ら２つが効果的に通信できるレートです。わかりやすいように、例を使って説明し
ます。

例：
    Task  machine: serserv 2.38400
    Debug machine: wvideo -trap=ser;1.57600 hello

この例では、２台のマシンが通信可能な最大レートは38,400 BAUDになります
（38,400と57,600の最小値は38,400だからです）。しかし、効果的な通信を行うため
に実際に選択されるレートはこれよりも小さい値になります。

サーバとデバッガの両方を起動するときに最大BAUDレートに０を指定すると、２つの
マシンが通信できる最大レートを見つけ出すプロセスは行われません。各々のBAUD
レートは別の手段（DOSまたはOS/2の"MODE"コマンド）で設定しなければなりませ
ん。また、これらのレートは同じでなければなりません。パリティ、ワード長、およ
びストップビット数はサーバとデバッガによって選択されるので、ユーザが指定する
必要はありません。２台のマシン間にモデムを使用している場合には、最大BAUDレー
トの値を０に指定しなければなりません（そうです。電話回線を介してアプリケー
ションをデバッグできるのです）。下に、DOSまたはOS/2の"MODE"コマンドを使って
BAUDレートを2400に設定する例を示します。

例：
    Task  machine: mode com2:2400
    Task  machine: serserv 2.0
    Debug machine: mode com1:2400
    Debug machine: wvideo -trap=ser;1.0

この例では、２台のマシンが通信できる最大レートは2400 BAUDになります（DOSまた
はOS/2の"MODE"コマンドを使って、外部的に指定されているためです）。

シリアルポートを介してデバッグする場合には、タスクマシンには以下のファイルが
必要です。

    1.　以下のシリアルサーバの１つ
        DOS、OS/2       SERSERV.EXE
        NetWare         SERSERV.NLM

    2.　以下のファイルセットの１つ
        DOS               STD.TRP
        OS/2 1.x          STD16.DLL
        OS/2 2.x          STD32.DLLおよびOS2V2HLP.EXE
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems　RSI.TRP、RSIHELP.EXP、およびDOS4G.EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガマシンには次のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             SER.TRP
        OS/2            SER.DLL

以下に、シリアルポートを介してアプリケーションをリモートデバッグするときに発
行するコマンドシーケンスを示します。

    Task  machine: serserv 2
    Debug machine: wvideo -trap=ser;1 bug
    Debug machine: VIDEO commands such as "go".
    Task  machine: Type any keyboard input that is required
    Debug machine: quit
    Task  machine: q

この例では、タスクマシン上ではシリアルポート２を、デバッガマシン上ではシリア
ルポート１を使っています。タスクマシンのシリアルポート２とデバッガマシンのシ
リアルポート１の間は、正しく配線したケーブルで接続しなければなりません。タス
クマシンとデバッガマシンの両方に、２台のマシンが通信しているBAUDレートを示す
メッセージが表示されます。

タスクマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。こ
れを入力しない場合には、サーバは起動時の状態に戻り、VIDEOを再起動してさらに
デバッグを行うことができます。


パラレルポートを介するリモートデバッグ
--------------------------------------
デバッグをパラレルポートを介して行う方が、シリアルポートを介して行うよりずっ
と高速になります。パラレルポートを介してリモートデバッグを行うには、デバッガ
マシン上でVIDEOを起動する前にタスクマシン上でサーバタスクを動作させなければ
なりません。これは、VIDEOがこの特殊なサーバプログラムを介してタスクマシンと
すぐに通信を開始するためです。

パラレル通信に必要な配線方法については、付録「リモートデバッグの配線」の「パ
ラレルポート配線上の注意事項」の項で説明してあります。

DOSおよびOS/2のパラレルポート・デバッグサーバの形式的なコマンド行構文を以下
に示します。

+------------------------------------------------------------------------+
|　PARSERV [/TRap=trap_file[;trap_parm]][port_number]                    |
+------------------------------------------------------------------------+

Microsoft Windowsのパラレルポート・デバッグサーバの形式的なコマンド行構文を
以下に示します。

+------------------------------------------------------------------------+
|　PARSERVW [port_number]                                                |
+------------------------------------------------------------------------+

NetWare 386のパラレルポート・デバッグサーバの形式的なコマンド行構文を以下に
示します。

+------------------------------------------------------------------------+
|　LOAD PARSERV [port_number]                                            |
+------------------------------------------------------------------------+

パラレルサーバの"port_number"は、サーバがデバッガマシン上で動作するVIDEOと通
信するために使用しなければならないパラレルポート番号（１から３）です。デフォ
ルトのポート番号は１です。

DOS、MS Windows、OS/2、およびNetWare 386の下では、これらの番号はパラレルプリ
ンタデバイス"LPTx"（"LPT1"、"LPT2"など）を指定するときに使用するデバイス番号
に対応します。

パラレルポートを介してデバッグする場合には、タスクマシンには以下のファイルが
必要です。

    1.　以下のパラレルサーバの１つ

        DOS、OS/2       PARSERV.EXE
        MS Windows      PARSERVW.EXE
        NetWare         PARSERV.NLM

    2.　以下のファイルセットの１つ

        DOS               STD.TRP
        MS Windows        STD.DLLおよびWINDEBUG.DLL
        OS/2 1.x          STD16.DLL
        OS/2 2.x          STD32.DLLおよびOS2V2HLP.EXE
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems  RSI.TRP、RSIHELP.EXP、およびDOS4G[W].EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガマシンには以下のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             PAR.TRP
        OS/2            PAR.DLL

以下に、パラレルポートを介してリモートでアプリケーションをデバッグするときに
発行するコマンドシーケンスを示します。

    Task  machine: parserv 1
    Debug machine: wvideo -trap=par;2 bug
    Debug machine: VIDEO commands such as "go"
    Task  machine: Type any keyboard input that is required.
    Debug machine: quit
    Task  machine: q

この例では、タスクマシン上ではパラレルポート１を、デバッガマシン上ではパラレ
ルポート２を使っています。タスクマシンのパラレルポート１とデバッガマシンのパ
ラレルポート２の間は、正しく配線したケーブルで接続しなければなりません。

タスクマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。こ
れを入力しない場合には、サーバは起動時の状態に戻り、VIDEOを再起動してさらに
デバッグを行うことができます。


Novellの"NetWare"ネットワークを介するリモートデバッグ(DOSおよびOS/2のみ）
-------------------------------------------------------------------------
Novellの"NetWare"ネットワークを介してリモートデバッグを行うには、NetWareシェ
ルが必要です。最初にSequenced Packet Exchange (SPX)をロードし、デバッガマシ
ン上でVIDEOを起動する前にタスクマシン上でサーバタスクを動作させなければなり
ません。これは、VIDEOがこの特殊なサーバプログラムを介してすぐにタスクマシン
と通信を開始するためです。

DOSおよびOS/2のNetWareデバッグサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|　NOVSERV [/TRap=trap_file[;trap_parm]][server_name]                    |
+------------------------------------------------------------------------+

NetWare 386のNetWareデバッグサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|　LOAD NOVSERV [server_name]                                            |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前は47字までにしなければなりません。以下の特殊
文字は使用できません。

    / ＼ : ; . , * ? + -

無効な文字は削除され、47字を超える文字は切捨てられます。"server_name"は、デ
バッガマシン上で動作するVIDEOに対してサーバを一意に識別します。デフォルトの
"server_name"は"NovLink"です。

"NetWare"ネットワークを介してデバッグする場合には、タスクマシンには以下の
ファイルが必要です。

    1.　以下に示すNetWareサーバの１つ

        DOS、OS/2       NOVSERV.EXE
        NetWare         NOVSERV.NLM

    2.　以下のファイルセットの１つ

        DOS               STD.TRP
        OS/2 1.x          STD16.DLL
        OS/2 2.x          STD32.DLLおよびOS2V2HLP.EXE
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems  RSI.TRP、RSIHELP.EXP、およびDOS4G[W].EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガマシンには以下のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             NOV.TRP
        OS/2            NOV.DLL

以下に、"NetWare"ネットワークを介してアプリケーションをリモートデバッグする
ときに発行するコマンドシーケンスを示します。

    Task  machine: novserv rmt_dbg
    Debug machine: wvideo -trap=nov;rmt_dbg bug
    Debug machine: VIDEO commands such as "go".
    Task  machine: Type any keyboard input that is required
    Debug machine: quit
    Task  machine: q

この例では、サーバ名"RMT_DBG"をタスクマシン上で使っているので、デバッガマシ
ン上でも同じサーバ名を使っています。

タスクマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。こ
れを入力しない場合には、サーバは起動時の状態に戻り、VIDEOを再起動してさらに
デバッグを行うことができます。


ＮｅｔＢＩＯＳサポートを使用したリモートデバッグ（ＤＯＳおよびＯＳ／２のみ）
----------------------------------------------------------------------------
NetBIOSネットワークプログラミングインタフェースを使用しても、デバッグを行う
ことができます。このネットワークプロトコルを使ってリモートデバッグを行うには、
デバッガマシン上でVIDEOを起動する前にタスクマシン上でサーバタスクを動作させ
なければなりません。これは、VIDEOがこの特殊なサーバプログラムを介してすぐに
タスクマシンと通信を開始するためです。

DOSおよびOS/2のNetBIOSデバッグサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|　NETSERV [/TRap=trap_file[;trap_parm]][server_name]                    |
+------------------------------------------------------------------------+

Microsoft WindowsのNetBIOSデバッグサーバの形式的なコマンド行構文を以下に示し
ます。

+------------------------------------------------------------------------+
|　NETSERVW [server_name]                                                |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前は英数字で15字までにしなければなりません。
"server_name"は、デバッガマシン上で動作するVIDEOに対してサーバを一意に識別し
ます。デフォルトの"server_name"は"NetLink"です。

NetBIOSネットワークプログラミングインタフェースを用いてデバッグする場合に
は、タスクマシンには以下のファイルが必要です。

    1.　NetBIOSサーバ

        DOS、OS/2       NETSERV.EXE
        MS Windows      NETSERVW.EXE

    2.　以下のファイルセットの１つ

        DOS               STD.TRP
        MS Windows        STD.DLL
        OS/2 1.x          STD16.DLL
        OS/2 2.x          STD32.DLLおよびOS2V2HLP.EXE
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems  RSI.TRP、RSIHELP.EXP、およびDOS4G[W].EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガマシンには以下のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             NET.TRP
        OS/2            NET.DLL

以下に、NetBIOSネットワークプログラミングインタフェースを使用してアプリケー
ションをリモートデバッグするときに発行するコマンドシーケンスを示します。

    Task  machine: netserv rmt_dbg
    Debug machine: wvideo -trap=net;rmt_dbg bug
    Debug machine: VIDEO commands such as "go".
    Task  machine: Type any keyboard input that is required
    Debug machine: quit
    Task  machine: q

この例では、サーバ名"rmt_dbg"をタスクマシン上で使っているので、デバッガマシ
ン上でも同じサーバ名を使っています。

タスクマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。こ
れを入力しない場合には、サーバは起動時の状態に戻り、VIDEOを再起動してさらに
デバッグを行うことができます。


ＤＥＳＱｖｉｅｗを使用したリモートデバッグ（ＤＯＳのみ）
--------------------------------------------------------
DESQviewウィンドウを使用しても、デバッグを行うことができます。DESQviewを使っ
てリモートデバッグを行うには、VIDEOをあるウィンドウ（「デバッガ」ウィンドウ）
で起動する前に別のウィンドウ（「タスク」ウィンドウ）でサーバタスクを動作させ
なければなりません。これは、VIDEOがこの特殊なサーバプログラムを介してすぐに
タスクウィンドウと通信を開始するためです。

DOSおよびOS/2のDESQviewデバッグサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|　DQVSERV [/TRap=trap_file[;trap_parm]][server_name]                    |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前には任意の英数字文字列を指定できます。"serve
r_name"は、デバッガマシン上で動作するVIDEOに対してサーバを一意に識別します。
デフォルトの"server_name"は"WATCOM Server"です。

DESQviewウィンドウを用いてデバッグする場合には、タスクウィンドウには以下の
ファイルが必要です。

    1.　DESQviewサーバ、DQVSERV.EXE

    2.　以下のファイルセットの１つ

        DOS               STD.TRP
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems  RSI.TRP、RSIHELP.EXP、およびDOS4G[W].EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガウィンドウには以下のファイルが必要です。

    1.　WATCOMデバッガ、WVIDEO.EXE

    2.　トラップファイル、DQV.TRP

以下に、DESQviewウィンドウを使用してアプリケーションをリモートデバッグすると
きに発行するコマンドシーケンスを示します。

    Task  window: dqvserv rmt_dbg
    Debug window: wvideo -trap=dqv;rmt_dbg bug
    Debug window: VIDEO commands such as "go".
    Task  window: Type any keyboard input that is required
    Debug window: quit
    Task  window: q

この例では、サーバ名"rmt_dbg"をタスクウィンドウで使っているので、デバッガ
ウィンドウでもこのサーバ名を使っています。

タスクウィンドウがアクティブのときにキーボードから最後の"q"を入力すると、
サーバは終了します。入力しない場合には、サーバは起動時の状態に戻り、VIDEOを
再起動してさらにデバッグを行うことができます。


OS/2仮想DOSマシン・リンクを使用したリモートデバッグ
---------------------------------------------------
OS/2 DOSボックスあるいはセッションで走るアプリケーションのデバッグも可能で
す。OS/2の下でのリモートデバッグには、OS/2セッション(「デバッガ」ウィンドウ)
でVIDEOを起動する前に、DOSセッション(「タスク」ウィンドウ)で走っているサー
バータスクが必要です。これは、VIDEOが、この特別なサーバープログラムを通し
て、タスクウィンドウと、直ちに通信を開始するためです。

形式的なOS/2 DOSセッションデバッグサーバーのコマンドラインの文法は、以下の通
りです。
+------------------------------------------------------------------------+
|VDMSERV [/TRap=trap_file[;trap_parm]] [server_name]                     |
+------------------------------------------------------------------------+
"server_name"では、大文字・小文字の区別は無視されます。複数のサーバーが動作
するときには、この名前は重なってはいけません。(同じ名前が使われているときに
は、警告されます。)名前は、英数字で構成されます。"server_name"によって、
デバッガウィンドウで走っているVIDEOは、サーバーを特定できます。"server_name"
のデフォルトは、"VDMLink"です。

32ビットDOSエクステンダのアプリケーションをVDMリンクで、デバッグしたいとき
は、VDMSERVにトラップファイルを指定できます。

例：
    VDMSERV /TRap=RSI (DOS/4Gプログラムのデバッグ)
    VDMSERV /TRap=PLS (386|DOS-Extenderプログラムのデバッグ)

OS/2 DOSボックスで走るアプリケーションをデバッグするとき、タスクウィンドウに
は以下のファイルが必要です。

    1. OS/2 VDMサーバー、VDMSERV.EXE

    2. 以下のファイルのうちの１組
        DOS                     STD.TRP
        Phar Lap                PLS.TRP,PLSHELP.EXP,DBGLIB.REX,RUN386.EXE
        Rational Systems        RSI.TRP,RSIHELP.EXP,DOS4G.EXE

    3. デバッグされる実行可能ファイル

    4. 実行可能ファイルが使用するデータファイル

デバッガウィンドウには、以下のファイルが必要です。

    1. WATCOMデバッガ、WVIDEO.EXE

    2. トラップファイル、VDM.DLL

以下は、OS/2 DOSボックスで走るアプリケーションをデバッグするために、入力する
一連のコマンドです。

    Task  window: vdmserv rmt_dbg
    Debug window: wvideo -trap=vdm;rm_dbg bug
    Debug window: "go"などのようなVIDEOコマンド
    Task  window: アプリケーションが必要とする操作
    Debug window: quit
    Task  window: q

この例では、サーバー名"rmt_dbg"がタスクウィンドウで使用され、デバッグウィン
ドウでも、同じ"rmt_dbg"を指定しています。

タスクウィンドウがアクティブの時、キーボードから入力された最後の"q"キーに
よって、サーバーは終了します。"q"キーを入力しないと、サーバーは起動初期の状
態に戻っているので、さらにデバッグを続けるために、VIDEOを、再起動することが
できます。


Ｍｉｃｒｏｓｏｆｔ　Ｗｉｎｄｏｗｓ　ＤＯＳボックスを使用したリモートデバッグ
----------------------------------------------------------------------------
Microsoft Windows DOSボックスを使用しても、デバッグを行うことができます。
Windowsを使ってリモートデバッグを行うには、VIDEOをあるDOSボックス（「デバッ
ガ」ウィンドウ）で起動する前に別のDOSボックス（「タスク」ウィンドウ）でサー
バタスクを作動させなければなりません。これは、VIDEOがこの特殊なサーバプログ
ラムを介してすぐにタスクウィンドウと通信を開始するためです。

Microsoft Windowsはエンハンスドモードで起動しなければなりません。そのために
は、以下に示す"device"指定をWindowsの"SYSTEM.INI"ファイルの[386Enh]セクショ
ンに入れなければなりません。

    DEVICE=[d:]＼WATCOM＼BINW＼WDEBUG.386

このデバイスドライバは、16ビットと32ビットの両アプリケーションのデバッグをサ
ポートします。

Microsoft Windows DOSボックス・デバッグサーバの形式的なコマンド行構文を以下
に示します。

+------------------------------------------------------------------------+
|　WINSERV [/TRap=trap_file[;trap_parm]][server_name]                    |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前には任意の英数字文字列を指定できます。"serve
r_name"は、デバッガマシン上で動作するVIDEOに対してサーバを一意に識別します。
デフォルトの"server_name"は"WinLink"です。

Windows DOSボックスを用いてデバッグする場合には、タスクウィンドウに以下の
ファイルが必要です。

    1.　Windowsサーバ、WINSERV.EXE

    2.　以下のファイルセットの１つ

        DOS               STD.TRP
        Phar Lap          PLS.TRP、PLSHELP.EXP、DBGLIB.REX、およびRUN386.EXE
        Rational Systems  RSI.TRP、RSIHELP.EXP、およびDOS4G[W].EXE

    3.　デバッグされる実行可能ファイル

    4.  実行可能形式が必要とするデータファイル

デバッガウィンドウには以下のファイルが必要です。

    1.　WATCOMデバッガ、WVIDEO.EXE

    2.　トラップファイル、WIN.TRP

以下に、Windows DOS ボックスを使用してアプリケーションをリモートデバッグする
ときに発行するコマンドシーケンスを示します。

    Task  window: winserv rmt_dbg
    Debug window: wvideo -trap=win;rmt_dbg bug
    Debug window: VIDEO commands such as "go".
    Task  window: Type any keyboard input that is required
    Debug window: quit
    Task  window: q

この例では、サーバ名"rmt_dbg"をタスクウィンドウで使っているので、デバッガ
ウィンドウでもこのサーバ名を使っています。

タスクウィンドウがアクティブのときにキーボードから最後の"q"を入力すると、
サーバは終了します。入力しない場合には、サーバは起動時の状態に戻り、VIDEOを
再起動してさらにデバッグを行うことができます。


タスクマシンおよびデバッガマシン上でのファイルの指定
----------------------------------------------------
リモートデバッグ機能を使ってアプリケーションをデバッグする場合には、タスクマ
シンまたはデバッガマシン上のファイルを識別する必要があります。タスクマシンま
たはデバッガマシン上のファイルを識別するために、デバッガは２つの特別なプレ
フィックス"@L"および"@R"をサポートしています。

プレフィックス"@L"または"@l"は、ファイルがローカルデバッガマシン上にあること
を示すのに使用します。

DOS、OS/2、NetWare
        @L[d:][path]filename[.ext]

        "[path]"を指定しない場合には、ローカルマシンの指定したドライブのカレ
        ントディレクトリと見なされます。"[d]"を指定しない場合には、ローカル
        マシンのカレントドライブと見なされます。

        例：
            view @loutput.log
            invoke @l＼cmds＼setup.dbg
            invoke @ld:＼cmds＼setup.dbg
            log @llpt2

プレフィックス"@R"または"@r"は、ファイルがリモートタスクマシン上にあることを
示すのに使用します。

DOS、OS/2、NetWare
        @R[d:][path]filename[.ext]

        "[path]"を指定しない場合には、リモートマシンの指定したドライブのカレ
        ントディレクトリと見なされます。"[d]"を指定しない場合には、リモート
        マシンのカレントドライブと見なされます。

        例：
            view @rmyappl.dat
            view @r＼programs＼src＼uilib.c
            view @rd:＼programs＼exe＼myappl.lnk
            log @rlpt1

このように、ファイルはデバッガに対して以下の３通りの方法で識別することができ
ます。

DOS、OS/2、NetWare
        [d:][path]filename[.ext]

        @L[d:][path]filename[.ext]

        @R[d:][path]filename[.ext]

最初の形式のファイルは、"REMotefile"オプションが指定されていない場合には、
デバッガマシン上にあります。指定されている場合には、ファイルはタスクマシン上
にあります。２番目の形式のファイルは常にデバッガマシン上にあります。３番目の
形式のファイルは常にタスクマシン上にあります。

+------------------------------------------------------------------------+
|　注：　これらの特殊なドライブサフィックス"@L"および"@R"は、ユーザ自身  |
|　のアプリケーションで２台のマシン上のファイルを参照するためには使え    |
|　ません。VIDEOとRFXユーティリティだけがこれらのプレフィックスを認識し  |
|　ます。ユーザのファイルの中に、これらと同じプレフィックス（"@L"、"@l"、|
|　"@R"、または"@r"）で始まるファイルがある場合には、"@@"を使ってくださ  |
|　い。たとえば、ディスク上の"@link@"というファイルを参照したいなら、    |
|　"@@link@"と指定できます。".＼@link@"（DOS、OS/2、NetWare）を使っても  |
|　かまいません。                                                        |
+------------------------------------------------------------------------+

タスクマシン上で実行中のプログラムの中断
----------------------------------------
プログラムをVIDEOによってロードすると、Goコマンドによって実行を開始すること
ができます（Goコマンドは「VIDEOコマンド」の章で説明してあります）。開発段階
ではよくあることですが、プログラムの実行が際限なく続くことがあります。

ＤＯＳで実行中プログラムの中断
------------------------------
アプリケーションがタスクマシン上のDOSの下で動作している場合には、タスクマシ
ン（アプリケーションが動作しているPC）でPrint Screen（PrtSc）キーまたは
System Request（SysRq）キー（PC-9801ではCOPYキー）を押してアプリケーションを
中断することができます。キーボードによっては、Print Screen関数を得るためにシ
フトキーも押さなければならない場合があります。

デバッガマシンのキーボードでCtrl/Breakキーの組合せを押して、VIDEOコマンドの
実行を中断することができます。


ＯＳ／２で実行中のプログラムの中断
----------------------------------
アプリケーションがタスクマシン上のOS/2の下で動作している場合には、リモート
サーバセッション（サーバプログラムを動作しているセッション）でCtr/Breakキー
の組合せを押してアプリケーションを中断することができます。

デバッガマシンのVIDEOセッションでCtr/Breakキーの組合せを押して、VIDEOコマン
ドの実行を中断することができます。
::::REMOTE_WIN3
Ｗｉｎｄｏｗｓアプリケーションのリモートデバッグ
------------------------------------------------
２台のコンピュータを使用し、一方でアプリケーションを走らせ、もう一方でデバッ
ガを走らせる「リモートデバッグ」について説明します。これには、WindowsやOS/2
のようなマルチプログラミング・オペレーティングシステムでのマルチプルセッショ
ンの使用を含みます。これは、複数の「仮想」コンピュータを走らせていると考えら
れます。リモートデバッグの概念上、この２つのケースは本質的に同じことになりま
す。

Windowsアプリケーションの実行に使用するパーソナルコンピュータを「タスクマシ
ン」と呼びます。このPCにはMicrosoft Windowsをインストールしなければなりませ
ん。後で説明するVIDEOサーバタスクの１つをタスクマシン上に置き、Windowsから起
動できるようにしなければなりません。デバッグするアプリケーションがタスクマシ
ンからアクセスできるようにして、Windowsの下で動作するサーバタスクがロードで
きるようにしなければなりません。

リモートデバッグの機能を使用するとき、デバッグされるアプリケーションは、オペ
レーティングシステムがそれをロードできるように、タスクマシンに入れておかなけ
ればなりません。アプリケーションのソースファイルは、モジュールに対応したソー
ス行を表示できるように、デバッガマシンからアクセスできるところになければなり
ません。


２台のコンピュータを使ったリモートデバッグ
------------------------------------------
ここで、PC#1がユーザの主開発マシンと仮定します。このマシンにはアプリケーショ
ン、そのデータファイルとソースファイル、およびアプリケーションを開発するため
に使用しているプログラム（エディタ、コンパイラ、リンカ、デバッガなど）が入っ
ています。また、Microsoft Windowsのコピーもインストールされているものとしま
す。PC#2はユーザが使用できる予備のマシンと仮定します。２つのコンピュータシス
テムが関係しているので、次の２つの状況が考えられます。

    1.　アプリケーションと必要なデータファイルをPC#2にコピーできます。
        Microsoft WindowsがPC#2にインストールされていることも確認してくださ
        い。この状況では、主開発マシン（PC#1）を使用してデバッガを実行し、予
        備マシンを使用してWindowsアプリケーションを実行します。このため、ア
        プリケーションのソースファイルはデバッガマシンにあります。

    2.　デバッガをPC#2にコピーできます。この状況では、主開発マシン（PC#1）は
        Windowsアプリケーションを実行するのに使用します。アプリケーションの
        すべてのソースファイルをPC#2にコピーしないかぎり、デバッガはそれらに
        アクセスできません。この場合、VIDEOの"REMotefiles"オプションを使用し
        て、ソースファイルは通信リンクを通してタスクマシン（PC#1）から得られ
        ることをデバッガに知らせることができます。"REMotefiles"オプションに
        はもう１つの利点があります。それは、デバッガがデフォルトとしてデバッ
        ガのコマンドファイルもタスクマシン上に見つけることです。このオプショ
        ンを指定しない場合には、デバッガコマンドファイルもデバッガマシン
        （PC#2）にコピーしなければなりません。

どのマシンをタスクに使い、どのマシンをデバッガに使うかはユーザの判断次第で
す。場合によっては、各マシンの使用可能メモリ量やそれぞれのプロセッサの処理速
度によって決まります。たとえば、アプリケーションに大量のメモリが必要な場合に
は、当然メモリの大きなマシンをタスクマシンにします。アプリケーションの実行速
度が重要な場合には、当然処理速度が速い方をタスクマシンにします。


Ｍｉｃｒｏｓｏｆｔ　Ｗｉｎｄｏｗｓを用いたリモートデバッグ
----------------------------------------------------------
VIDEOのリモートデバッグ機能を使うには、Microsoft Windowsをエンハンスドモード
で起動しなければなりません。32ビットアプリケーションをデバッグする場合には、
以下に示す"device"指定をWindowsの"SYSTEM.INI"ファイルの[386Enh]セクションに
入れなければなりません。

    DEVICE=[d:]＼WATCOM＼BINW＼WDEBUG.386

このデバイスドライバは16ビットアプリケーションのデバッグにも使用できます。

Windows SDKファイル"WINDEBUG.DLL"をパスに入れなければなりません。このファイ
ルはWATCOMソフトウェアパッケージに入っています。


IBM OS/2での16ビットWindwosアプリケーションのデバッグ
-----------------------------------------------------
OS/2のWIN-OS/2と仮想DOSマシン(VDM)機能を使用して、16ビットWindowsアプリケー
ションのデバッグがサポートされます。デバッガはOS/2セッションで起動され、VDM
インターフェースを使用して、WIN-OS/2セッションで走っているサーバープログラム
と通信します。

以下のセクションで、Windowsアプリケーションのリモートデバッグに利用可能な異
なるデバッグサーバーについて、説明します。


WindowsとWIN-OS/2のコミュニケーションサーバー
---------------------------------------------
デバッガマシン上でVIDEOが起動される前に、サーバータスクはタスクマシン上で走
っていなければなりません。MS Windows 3.xとIBM WIN-OS/2の下でVIDEOとともに使
用されるサーバーは３種類あります。

PARSERVW.EXE    パラレルポートを通して、Windowsアプリケーションのリモートデ
                バッグをサポートします。

NETSERVW.EXE    NetBIOSサポートを使って、Windowsアプリケーションのリモートデ
                バッグをサポートします。

VDMSERVW.EXE    (OS/2のみ)仮想DOSマシンリンクを使用して、IBMWIN-OS/2の下で走
                るWindowsアプリケーションのリモートデバッグをサポートしま
                す。以下の説明で、「タスクマシン」とは、サーバーが起動される
                WIN-OS/2セッションであり、「デバッガマシン」とは、デバッガが
                起動されるOS/2セッションのことです。

これらのプログラムについて、続いて説明します。


ＰＣ間コミュニケーションリンクの例
----------------------------------
下の図は、２台目のコンピュータシステム上で動作するVIDEOを使用して、１台目の
コンピュータシステム上のWindowの下で動作するアプリケーションをデバッグする例
を示しています。ここではパラレル通信を使用しています。

        PC #1                       PC #2
+-------------------+        +--------------------+
| 　 タスクマシン   |        | 　デバッガマシン   |
|      Windows      |        |        DOS         |
|                   |        |                    |
|     PARSERVW<-----|-----+  |       WVIDEO       |
|       ↓          |     |  |         ↓         |
|　　               |     |  |                    |
| トラップハンドラ  |     +--|-->トラップハンドラ |
|     STD.DLL       |        |       PAR.TRP      |
+-------------------+        +--------------------+

図26.　２つのコンピュータシステムを使用したMS Windowsのデバッグ

注：

    1.　キーボード入力に関して次のことに注意しなければなりません。デバッガに
        対して入力するものはすべてデバッガマシンに入力しなければなりません。
        同様に、デバッグするアプリケーションに対する入力はすべてタスクマシン
        に入力しなければなりません。

    2.　画面出力に関しても同様です。　デバッガの出力はすべてデバッガマシン上
        に表示されます。一方、プログラムの出力はすべてタスクマシンに表示され
        ます。


Ｗｉｎｄｏｗｓでバッグコミュニケーションサーバーの起動
------------------------------------------------------
VIDEOデバッグサーバプログラムをインストールしたウィンドウを選択してくださ
い。各デバッグサーバに対してアイコンが表示されています。使用したいデバッグ
サーバのアイコンをダブルクリックしてください。


パラレルポートサーバ
--------------------
デバッガマシン上でVIDEOを起動する前にタスクマシン上でサーバタスクを動作させ
なければなりません。これは、VIDEOがこの特殊なサーバプログラムを介してタスク
マシンとすぐに通信を開始するためです。

Microsoft Windowsで、パラレルポートデバッグサーバのコマンド来の形式は、以下
の通りです
+--------------------------------------------------------------------------+
| PARSERVW [server_name]                                                   |
+--------------------------------------------------------------------------+

パラレル通信に必要な配線方法については、付録「リモートデバッグの配線」の「パ
ラレルポート配線上の注意事項」の項で説明してあります。

パラレルサーバタスクは使用するパラレルポートの番号（１、２、３）で指定できま
す。デフォルトのポート番号は１です。

これらの番号はパラレルプリンタデバイス"LPTx"（"LPT1"、"LPT2"など）を指定する
ときに使用するデバイス番号に対応します。

パラレルポートを介してデバッグする場合には、タスクマシンには以下のファイルが
必要です。

    1.　パラレルポートサーバタスク、"PARSERVW.EXE"

    2.　Microsoft Windowsとのインタフェース、"STD.DLL"

    3.　Microsoft SDKファイル、"WINDEBUG.DLL"

    4.　デバイスドライバ、"WDEBUG.386"

    5.　デバッグされる実行可能ファイル

    6.  実行可能形式が必要とするデータファイル

デバッガマシンには以下のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             PAR.TRP
        OS/2            PAR.DLL


ＮｅｔＢＩＯＳサーバ（ＤＯＳおよびＯＳ／２のみ）
------------------------------------------------
NetBIOSネットワークプログラミングインタフェースを使用しても、デバッグを行う
ことができます。このネットワークプロトコルを使ってリモートデバッグを行うに
は、デバッガマシン上でVIDEOを起動する前にタスクマシン上でサーバタスクを動作
させなければなりません。これは、VIDEOがこの特殊なサーバプログラムを介してす
ぐにタスクマシンと通信を開始するためです。

Microsoft Windowsで、NetBIOSデバッグサーバのコマンド来の形式は、以下の通り
です。
+--------------------------------------------------------------------------+
| NETSERVW [server_name]                                                   |
+--------------------------------------------------------------------------+

"server_name"を指定できます。サーバ名は大文字と小文字の区別がなく、一意でな
ければなりません（一意でない場合には通知されます）。名前は英数字で15字まで
にしなければなりません。サーバ名は、デバッガマシン上で動作するVIDEOに対して
サーバを一意に識別します。デフォルトのサーバ名は"NetLink"です。

NetBIOSネットワークプログラミングインタフェースを用いてデバッグする場合に
は、タスクマシンには以下のファイルが必要です。

    1.　NetBIOSサーバタスク、"NETSERVW.EXE"

    2.　Microsoft Windowsとのインタフェース、"STD.DLL"

    3.　Microsoft SDKファイル、"WINDEBUG.DLL"

    4.　デバイスドライバ、"WDEBUG.386"

    5.　デバッグされる実行可能ファイル

    6.  実行可能形式が必要とするデータファイル

デバッガマシンには以下のファイルが必要です。

    1.　WATCOMデバッガ

        DOS、OS/2       WVIDEO.EXE

    2.　以下のトラップファイルの１つ

        DOS             NET.TRP
        OS/2            NET.DLL


OS/2仮想DOSマシン・リンクを使用したリモートデバッグ
---------------------------------------------------
OS/2 DOSボックスあるいはセッションで走るアプリケーションのデバッグも可能で
す。OS/2の下でのリモートデバッグには、OS/2セッション(「デバッガ」ウィンドウ)
でVIDEOを起動する前に、DOSセッション(「タスク」ウィンドウ)で走っているサー
バータスクが必要です。これは、VIDEOが、この特別なサーバープログラムを通し
て、タスクウィンドウと、直ちに通信を開始するためです。

形式的なOS/2 DOSセッションデバッグサーバーのコマンドラインの文法は、以下の通
りです。
+------------------------------------------------------------------------+
|VDMSERV [/TRap=trap_file[;trap_parm]] [server_name]                     |
+------------------------------------------------------------------------+
"server_name"では、大文字・小文字の区別は無視されます。複数のサーバーが動作
するときには、この名前は重なってはいけません。(同じ名前が使われているときに
は、警告されます。)名前は、英数字で構成されます。"server_name"によって、
デバッガウィンドウで走っているVIDEOは、サーバーを特定できます。"server_name"
のデフォルトは、"VDMLink"です。

32ビットDOSエクステンダのアプリケーションをVDMリンクで、デバッグしたいとき
は、VDMSERVにトラップファイルを指定できます。

例：
    VDMSERV /TRap=RSI (DOS/4Gプログラムのデバッグ)
    VDMSERV /TRap=PLS (386|DOS-Extenderプログラムのデバッグ)

OS/2 DOSボックスで走るアプリケーションをデバッグするとき、タスクウィンドウに
は以下のファイルが必要です。

    1. OS/2 VDMサーバー、VDMSERV.EXE

    2. 以下のファイルのうちの１組
        DOS                     STD.TRP
        Phar Lap                PLS.TRP,PLSHELP.EXP,DBGLIB.REX,RUN386.EXE
        Rational Systems        RSI.TRP,RSIHELP.EXP,DOS4G.EXE

    3. デバッグされる実行可能ファイル

    4. 実行可能ファイルが使用するデータファイル

デバッガウィンドウには、以下のファイルが必要です。

    1. WATCOMデバッガ、WVIDEO.EXE

    2. トラップファイル、VDM.DLL

以下は、OS/2 DOSボックスで走るアプリケーションをデバッグするために、入力する
一連のコマンドです。

    Task  window: vdmserv rmt_dbg
    Debug window: wvideo -trap=vdm;rm_dbg bug
    Debug window: "go"などのようなVIDEOコマンド
    Task  window: アプリケーションが必要とする操作
    Debug window: quit
    Task  window: q

この例では、サーバー名"rmt_dbg"がタスクウィンドウで使用され、デバッグウィン
ドウでも、同じ"rmt_dbg"を指定しています。

タスクウィンドウがアクティブの時、キーボードから入力された最後の"q"キーに
よって、サーバーは終了します。"q"キーを入力しないと、サーバーは起動初期の状
態に戻っているので、さらにデバッグを続けるために、VIDEOを、再起動することが
できます。
::::RFX
リモートファイル操作（ＤＯＳ、ＯＳ／２のみ）
-------------------------------------------

リモートファイル交換プログラム（RFX）を使用すると、本章の後半で説明するどれ
か１つの接続方法を用いてユーザのパソコンに接続されているパソコン上のファイル
を操作することができます。ローカルマシンとリモートマシンの両方でサポートされ
るファイル操作は、次のとおりです。

    1.  ディレクトリの作成、表示、および削除

    2.  カレントドライブとカレントディレクトリの設定

    3.  ファイルの表示、名前変更、消去、および複写（PCからPCへのファイル転送
        を含む）

現在サポートされているPCとPCのリンクは、次のとおりです。

    1.  シリアルポートからシリアルポートへのリンク

    2.  パラレルポートからパラレルポートへのリンク

    3.  Novellの"NetWare"ネットワーク

    4.  NetBIOSネットワークプログラミングインタフェース

リモートファイル操作ユーティリティRFXを起動するには、以下の構文を使用します。

+------------------------------------------------------------------------+
|  RFX trap_file[;trap_parm][rfx_cmd]                                    |
+------------------------------------------------------------------------+

RFXを起動する場合には、トラップファイル名を指定しなければなりません。この
ファイルは、リモートファイル操作に必要なマシン対マシンの通信を処理します。

DOSでは、デフォルトのファイル拡張子は".TRP"となります。DOSのPATH環境変数には
トラップファイルのパスが入っていなければなりません。トラップファイルは通常、
VIDEOがインストールされているディレクトリの"BIN"サブディレクトリにあります。

OS/2では、デフォルトのファイル拡張子は".DLL"となります。"CONFIG.SYS"のOS/2の
LIBPATHコマンドを使用して、"DLL"トラップファイルの位置を識別しなければなりま
せん。トラップファイルは通常、VIDEOがインストールされているディレクトリの
"BINP＼DLL"サブディレクトリにあります。

トラップファイルについては、次の項で説明します。

rfx_cmdは任意に指定することができます。RFXコマンドについては、「RFXコマンド
」の項で説明します。コマンドを指定せずにRFXを実行した場合には、RFXは対話モー
ドで使用できます。DOSやOS/2と同じようなプロンプトが表示されます。"EXIT"コマ
ンドが入力されるまで、RFXはコマンドを処理します。


トラップファイル
----------------
マシン対マシンの通信をサポートするために、以下のトラップファイルはRFXととも
に使用できます。

STD.TRP、STD16.DLL、STD32.DLL
            トラップファイルを指定しない場合、DOSの下では、デフォルトのト
            ラップファイル"STD.TRP"がロードされます。OS/2バージョン1.xの下で
            は、デフォルトのトラップファイル"STD16.DLL"がロードされます。
            OS/2バージョン2.xの下では、デフォルトのトラップファイル"STD32.
            DLL"がロードされます。これらのインタフェースモジュールは、ローカ
            ルパーソナルコンピュータ上のファイル操作だけをサポートします。リ
            モートファイル操作はできません。任意指定の"trap_parm"は無視され
            ます。

SER.TRP、SER.DLL
            この通信ドライバファイルは、２台のマシンのシリアルポートを使用し
            た、それらのパーソナルコンピュータ間で行われるリモートファイル操
            作をサポートします。RFXがDOSの下で動作する場合には、"SER.TRP"を
            使用しなければなりません。RFXがOS/2の下で動作する場合には、"SER.
            DLL"を使用しなければなりません。ローカルマシンのシリアルポートは
            リモートマシンのシリアルポートと接続されます。"trap_parm"値は、
            使用するポート番号と任意指定の最大BAUDレート（ポート番号とピリオ
            ドで区切られています）を指定します。ポート番号は、１、２、３、ま
            たは４（デフォルトは１）です。これらの数字は、シリアルデバイス
            "COMx"（"COM1"、"COM2"など）を指定するときに使われるデバイス番号
            に対応します。

            DOSの下では、最大BAUDレートを以下のうちのどれかにすることができ
            ます。

                115200
                 57600
                 38400
                 19200
                  9600
                  4800
                  2400
                  1200
                     0　（特別な場合）

            デフォルトの最大BAUDレートは115,200です。（NEC PC-9801シリーズで
            は、最大9600までです。）

            OS/2の下では、最大BAUDレートを以下のうちのどれかすることができま
            す。

                 19200
                  9600
                  4800
                  2400
                  1200
                     0　（特別な場合）

            デフォルトの最大BAUDレートは19,200です。

            特別なBAUDレート０を除いて、希望する最大BAUDレートを識別するには
            少なくとも最初の２桁を指定しなければなりません。最大BAUDレートに
            ついては、「シリアルポートを介したリモートファイル操作」の項で説
            明します。以下の例では、ポート２と最大BAUDレート19,200が指定され
            ています。

            例：
                /trap=ser;2.19

PAR.TRP、PAR.DLL（NEC PC-9801シリーズではサポートされません）
            この通信ドライバファイルは、２台のマシンのパラレルポートを使用し
            た、それらのパーソナルコンピュータ間で行われるリモートファイル操
            作をサポートします。RFXがDOSの下で動作する場合には、"PAR.TRP"を
            使用しなければなりません。RFXがOS/2の下で動作する場合には、"PAR.
            DLL"を使用しなければなりません。ローカルマシンのパラレルポートは
            リモートマシンのパラレルポートと接続されます。使用するポート番号
            は、"trap_parm"で指定します。ポート番号は、１、２、または３（デ
            フォルトは１）です。これらの数字はプリンタデバイス"LPTx"（"LPT1"、
            "LPT2"など）を指定するときに使われるデバイス番号に対応します。

NOV.TRP、NOV.DLL
            この通信ドライバファイルは、Novellの"NetWare"ネットワークに接続
            された２台のパーソナルコンピュータ間で行われるリモートファイル操
            作をサポートします。バージョン2.0またはそれ以降のNetWareを使用し
            なければなりません。使用するサーバ名は"trap_parm"で指定します。
            そのサーバ名は、サーバを「タスク」マシン上で起動したときに指定し
            た名前と一致していなければなりません。「サーバ」の概念については、
            「通信サーバ」の項で説明します。

NET.TRP、NET.DLL
            この通信ドライバファイルは、NetBIOSネットワークプログラミングイ
            ンタフェースを使用した、２台のパーソナルコンピュータ間で行われる
            リモートファイル操作をサポートします。使用するサーバ名は"trap_pa
            rm"で指定します。サーバ名は、サーバをリモートマシン上で起動した
            ときに指定した名前と一致していなければなりません。サーバ名は最大
            15字までの英数字です。「サーバ」の概念については、「通信サーバ」
            の項で説明します。

通信サーバ
----------
リモートファイル操作を行うには、ローカルマシン上でRFXを起動する前にリモート
マシン上でサーバタスクが動作していなければなりません。このような機能を備え、
かつRFXと共に使用できるサーバとして、以下の４つのサーバが提供されています。

SERSERV.EXE     このプログラムはシリアルポートを介するリモートファイル操作を
                サポートします。

PARSERV.EXE     このプログラムはパラレルポートを介するリモートファイル操作を
                サポートします。

NOVSERV.EXE     このプログラムはNovellの"NetWare"ネットワークを介するリモー
                トファイル操作をサポートします。

NETSERV.EXE     このプログラムはNetBIOSサポートを使用するリモートファイル操
                作をサポートします。

これらのプログラムについては以下の項で説明します。

シリアルポートによるリモートファイル操作
----------------------------------------
シリアルポートを介してリモートファイル操作を行うには、ローカルマシン上でRFX
を起動する前にリモートマシン上でサーバタスクを動作させる必要があります。これ
は、RFXがこの特殊なサーバプログラムを介してすぐにリモートマシンと通信を開始
するためです。

RFXとサーバは通信速度で自動的に同期します。最高115,200 BAUDで通信することが
できます（NEC PC-9801シリーズでは最高9,600 BAUD）。BAUDレート、パリティ、そ
してデータビット数とストップビット数は自動的に選択されるので、DOSまたはOS/2
の"MODE"コマンドを使う必要はありません。

DOSまたはOS/2のシリアルポートサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|  SERSERV[/TRap=trap_file[;trap_parm]][port_number][.max_baud]          |
+------------------------------------------------------------------------+

シリアルサーバの"port_number"は、サーバがローカルマシン上で動作するRFXと通信
するのに使用するシリアルポート番号（１から４）です。デフォルトのポート番号は
１です。これらの番号はシリアルデバイス"COMx"（"COM1"、"COM2"など）を指定する
ときに使用するデバイス番号に対応します。

任意指定の"max_baud"値は最大BAUDレートを指定します。この値はピリオドでポート
番号と区切られています。最大BAUDレートは以下のうちのどれかにすることができま
す。

        115200
         57600
         38400
         19200
          9600
          4800
          2400
          1200
             0（特殊な場合）

デフォルトの最大BAUDレートは115,200（NEC PC-9801シリーズでは9,600）です。特
別の場合のBAUDレート０を除いて、希望する最大BAUDレートを識別するためには少な
くとも最初の２桁を指定しなければなりません。２台のマシン間で効率よく通信でき
る最大BAUDレートが分かっている場合には、その値を指定すると便利です。通常、
サーバとRFXは可能な最大速度で起動し、効果的な（エラーのない）レートになるま
で徐々に速度を落としていきます。各速度でテストするのに最大５秒必要です。事前
に最大BAUDレートを指定しておけば、スタートアップ時間を短縮することができます。
実際に選択されるBAUDレートは、サーバとRFXの両方が起動されたときに指定された
最大レートの最小値で、これら２つが効果的に通信できるレートです。わかりやすい
ように、例を使って説明します。

例：
        Remote machine: C>serserv 2.38400
        Local  machine: D>rfx ser;1.57600

この例では、２台のマシンが通信可能な最大レートは38,400 BAUDになります（38,
400と57,600の最小値は38,400だからです）。しかし、効果的な通信を行うために実
際に選択されるレートはこれよりも小さい値になります。

サーバとRFXの両方を起動するときに最大BAUDレートに０を指定すると、２つのマシ
ンが通信できる最大レートを見つけ出すプロセスは行われません。各々のBAUDレート
は別の手段（DOSまたはOS/2の"MODE"コマンド（NEC PC-9801シリーズではSPEEDまた
はSWITCHコマンド）など）で設定しなければなりません。また、これらのレートは同
じでなければなりません。パリティ、ワード長、およびストップビット数はサーバと
RFXによって選択されるので、ユーザが指定する必要はありません。２台のマシン間
にモデムを使用している場合には、最大BAUDレートの値を０に指定しなければなりま
せん。

例：
        Remote machine: C>mode com2:2400
        Remote machine: C>serserv 2.0
        Local  machine: D>mode com1:2400
        Local  machine: D>rfx ser;1.0

この例では、２台のマシンが通信できる最大レートは2400 BAUDになります（DOSまた
はOS/2の"MODE"コマンドを使って、外部的に指定されているためです）。

３台以上のパーソナルコンピュータがチェーンとして接続される特殊なアプリケー
ションの場合だけ、"TRap"オプションを指定します。"SERSERV"は、シリアルポート
を介して要求を受信します。このプログラムはこれらの要求をローカルで処理する
か、または別のコンピュータシステムで動作しているサーバに渡すことができます。
デフォルトでは要求は、DOSが動作している場合には"STD.TRP"ファイルによって、OS
/2バージョン1.xが動作している場合には"STD16.DLL"ファイルによって、またOS/2バ
ージョン2.xが動作している場合には"STD32.DLL"ファイルによってそれぞれローカル
で処理されます。

シリアルポートを介してファイルを操作する場合には、リモートマシンには以下のフ
ァイルが必要です。

        SERSERV.EXE
        STD.TRP、STD16.DLL、またはSTD32.DLL

ローカルマシンには以下のファイルが必要です。

        RFX.EXE
        SER.TRPまたはSER.DLL

以下に、シリアルポートを介してファイルをリモート操作するときにDOSの下で発行
するコマンドシーケンスを示します。

        Remote machine: C>serserv 2
        Local  machine: D>rfx ser;1
        Local  machine: "copy"、"dir"などのようなコマンド
        Local  machine: exit
        Remote machine: q

この例では、リモートマシン上ではシリアルポート２を、ローカルマシン上ではシリ
アルポート１を使っています。リモートマシンのシリアルポート２とローカルマシン
のシリアルポート１の間は、（以下に示すような）正しく配線したケーブルで接続し
なければなりません。リモートマシンとローカルマシンの両方に、２台のマシンが通
信しているBAUDレートを示すメッセージが表示されます。

リモートマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。
これを入力しない場合には、サーバは起動時の状態に戻り、RFXの再起動またはVIDEO
の起動を行うことができます。

シリアル通信に必要な配線方法については、付録「リモートデバッグの配線」の「シ
リアルポート配線上の注意事項」の項で説明してあります。

パラレルポートを介するリモートファイル操作
------------------------------------------
リモートファイル操作をパラレルポートを介して行う方が、シリアルポートを介して
行うよりずっと高速になります。パラレルポートを介してリモートファイル操作を行
うには、ローカルマシン上でRFXを起動する前にリモートマシン上でサーバタスクを
動作させなければなりません。これは、RFXがこの特殊なサーバプログラムを介して
リモートマシンとすぐに通信を開始するためです。

DOSおよびOS/2のパラレルポートサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|  PARSERV[/TRap=trap_file[;trap_parm]][port_number]                     |
+------------------------------------------------------------------------+

パラレルサーバの"port_number"は、サーバがローカルマシン上で動作するRFXと通信
するために使用しなければならないパラレルポート番号（１から３）です。デフォル
トのポート番号は１です。これらの番号はパラレルプリンタデバイス"LPTx"（"LPT1"、
"LPT2"など）を指定するときに使用するデバイス番号に対応します。

３台以上のパーソナルコンピュータがチェーンとして接続される特殊なアプリケー
ションの場合だけ、"TRap"オプションを指定します。"PARSERV"は、パラレルポート
を介して要求を受信します。このプログラムはこれらの要求をローカルで処理する
か、または別のコンピュータシステムで動作しているサーバに渡すことができます。
デフォルトでは要求は、DOSが動作している場合には"STD.TRP"ファイルによって、OS
/2バージョン1.xが動作している場合には"STD16.DLL"ファイルによって、またOS/2バ
ージョン2.xが動作している場合には"STD32.DLL"ファイルによってそれぞれローカル
で処理されます。

パラレルポートを介してファイルを操作する場合には、リモートマシンには以下の
ファイルが必要です。

        PARSERV.EXE
        STD.TRP、STD16.DLL、またはSTD32.DLL

ローカルマシンには以下のファイルが必要です。

        RFX.EXE
        PAR.TRPまたはPAR.DLL

以下に、パラレルポートを介してファイルをリモート操作するときにDOSの下で発行
するコマンドシーケンスを示します。

        Remote machine: C>parserv 1
        Local  machine: D>rfx par;2
        Local  machine: "copy"、"dir"などのようなコマンド
        Local  machine: exit
        Remote machine: q

この例では、リモートマシンではパラレルポート１が、ローカルマシンではパラレル
ポート２がそれぞれ使用されています。（以下に示すように）ケーブルが、リモート
マシンのパラレルポート１とローカルマシンのパラレルポート２の間に適切に配線さ
れています。

この例では、リモートマシン上ではパラレルポート１を、ローカルマシン上ではパラ
レルポート２を使っています。リモートマシンのパラレルポート１とローカルマシン
のパラレルポート２の間は、（以下に示すような）正しく配線したケーブルで接続し
なければなりません。

リモートマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。
これを入力しない場合には、サーバは起動時の状態に戻り、RFXの再起動またはVIDEO
の起動を行うことができます。

パラレル通信に必要な配線方法については、付録「リモートデバッグの配線」の「パ
ラレルポート配線上の注意事項」の項で説明してあります。


Ｎｏｖｅｌｌの”ＮｅｔＷａｒｅ”ネットワークを介するリモートファイル操作
------------------------------------------------------------------------
Novellの"NetWare"ネットワークを介してリモートファイル操作を行うには、NetWare
シェルが必要です。最初にInternetwork Packet Exchange （IPX）をロードし、次に、
ローカルマシン上でRFXを起動する前にリモートマシン上でサーバタスクを動作させ
なければなりません。これは、RFXがこの特殊なサーバプログラムを介してすぐにリ
モートマシンと通信を開始するためです。
す。

DOSまたはOS/2のNetWareサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|  NOVSERV[/TRap=trap_file[;trap_parm]][server_name]                     |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前は47字までにしなければなりません。以下の特殊
文字は使用できません。

        / ＼ : ; . , * ? + -

無効な文字は削除され、47字を超える文字は切捨てられます。"server_name"は、
ローカルマシン上で動作するRFXに対してサーバを一意に識別します。デフォルトの
"server_name"は"NovLink"です。

３台以上のパーソナルコンピュータがチェーンとして接続される特殊なアプリケー
ションの場合だけ、"TRap"オプションを指定します。"NOVSERV"は、"NetWare"ネット
ワークを介して要求を受信します。このプログラムはこれらの要求をローカルで処理
するか、または別のコンピュータシステムで動作しているサーバに渡すことができま
す。デフォルトでは要求は、DOSが動作している場合には"STD.TRP"ファイルによって、
OS/2バージョン1.xが動作している場合には"STD16.DLL"ファイルによって、またOS/2
バージョン2.xが動作している場合には"STD32.DLL"ファイルによってそれぞれローカ
ルで処理されます。

"NetWare"ネットワークを介してファイルを操作する場合には、リモートマシンには
以下のファイルが必要です。

        NOVSERV.EXE
        STD.TRP、STD16.DLL、またはSTD32.DLL

ローカルマシンには以下のファイルが必要です。

        RFX.EXE
        NOV.TRPまたはNOV.DLL

以下に、"NetWare"ネットワークを介してファイルをリモート操作するときにDOSの下
で発行するコマンドシーケンスを示します。

        Remote machine: C>novserv rmt_dbg
        Local  machine: D>rfx nov;rmt_dbg
        Local  machine: "copy"、"dir"などのようなコマンド
        Local  machine: exit
        Remote machine: q

この例では、サーバ名"RMT_DBG"をリモートマシン上で使っているので、ローカルマ
シン上でも同じサーバ名を使っています。

リモートマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。
これを入力しない場合には、サーバは起動時の状態に戻り、RFXの再起動またはVIDEO
の起動を行うことができます。


ＮｅｔＢＩＯＳサポートを使用したリモートファイル操作
----------------------------------------------------
NetBIOSネットワークプログラミングインタフェースを使用しても、リモートファイ
ル操作を行うことができます。このネットワークプロトコルを使ってリモートファイ
ル操作を行うには、ローカルマシン上でRFXを起動する前にリモートマシン上でサー
バタスクを動作させなければなりません。これは、RFXがこの特殊なサーバプログラ
ムを介してすぐにリモートマシンと通信を開始するためです。

DOSおよびOS/2のNetBIOSサーバの形式的なコマンド行構文を以下に示します。

+------------------------------------------------------------------------+
|  NETSERV[/TRap=trap_file[;trap_parm]][server_name]                     |
+------------------------------------------------------------------------+

"server_name"は大文字と小文字の区別がなく、一意でなければなりません（一意で
ない場合には通知されます）。名前は英数字で15字までにしなければなりません。
"server_name"は、ローカルマシン上で動作するRFXに対してサーバを一意に識別し
ます。デフォルトの"server_name"は"NetLink"です。

３台以上のパーソナルコンピュータがチェーンとして接続される特殊なアプリケー
ションの場合だけ、"TRap"オプションを指定します。"NETSERV"は、NetBIOSネット
ワークプログラミングインタフェースを使用して要求を受信します。このプログラム
はこれらの要求をローカルで処理するか、または別のコンピュータシステムで動作し
ているサーバに渡すことができます。デフォルトでは要求は、DOSが動作している場
合には"STD.TRP"ファイルによって、OS/2バージョン1.xが動作している場合には
"STD16.DLL"ファイルによって、またOS/2バージョン2.xが動作している場合には
"STD32.DLL"ファイルによってそれぞれローカルで処理されます。

NetBIOSネットワークプログラミングインタフェースを用いてファイルを操作する場
合には、リモートマシンには以下のファイルが必要です。

        NETSERV.EXE
        STD.TRP、STD16.DLL、またはSTD32.DLL

ローカルマシンには以下のファイルが必要です。

        RFX.EXE
        NET.TRPまたはNET.DLL

以下に、NetBIOSネットワークプログラミングインタフェースを使用してファイルを
リモート操作するときにDOSの下で発行するコマンドシーケンスを示します。

        Remote machine: C>netserv rmt_dbg
        Local  machine: D>rfx net;rmt_dbg
        Local  machine: "copy"、"dir"などのようなコマンド
        Local  machine: exit
        Remote machine: q

この例では、サーバ名"rmt_dbg"をリモートマシンで使っていので、ローカルマシン
上でも同じサーバ名を使っています。

リモートマシン上のキーボードから最後の"q"を入力すると、サーバは終了します。
これを入力しない場合には、サーバは起動時の状態に戻り、RFXの再起動またはVIDEO
の起動を行うことができます。


リモートマシンおよびローカルマシン上でのファイルの指定
------------------------------------------------------
リモートファイル操作機能を使用する場合には、ローカルマシンまたはリモートマシ
ンのどちらにあるファイルなのかを識別する方法が必要です。ローカルマシンまたは
リモートマシン上のファイルを識別するために、RFXは２つの特別なプレフィックス
をサポートしています。

@L      "@L"プレフィックスは、（RFXが動作している）ローカルマシンにファイル
        があることを示すために使用します。

            @L[d:][path]filename[.ext]

        "[path]"を指定しない場合には、ローカルマシンの指定したドライブのカレ
        ントディレクトリと見なされます。"[d:]"を指定しない場合には、ローカル
        マシンのカレントドライブと見なされます。

        例：
            TYPE @LOUTPUT.LOG
            COPY @LOUTPUT.LOG @LLPT2
            DIR @LD:＼CMDS
            ERASE @LD:＼CMDS＼DATA.TMP

@R      "@R"プレフィックスは、ファイルがリモートマシンにあることを示すために
        使用します。

            @R[d:][path]filename[.ext]

        "[path]"を指定しない場合には、リモートマシンの指定したドライブのカレ
        ントディレクトリと見なされます。"[d:]"を指定しない場合には、リモート
        マシンのカレントドライブと見なされます。

        例：
            TYPE @RMYAPPL.DAT
            ERASE @RD:＼PROGRAMS＼EXE＼MYAPPL.LNK
            DIR @R＼PROGRAMS＼SRC
            COPY @R＼PROGRAMS＼SRC＼UILIB.C @RLPT1

このように、ファイルはRFXに対して以下の３通りの方法で識別することができます。

        [d:][path]filename[.ext]
        @L[d:][path]filename[.ext]
        @R[d:][path]filename[.ext]

最初の形式のファイルは、カレントドライブがローカルドライブかリモートドライブ
のどちらであるかによって、ローカルマシンまたはリモートマシンのどちらかにあり
ます。２番目の形式のファイルは常にローカルマシンにあります。３番目の形式の
ファイルは常にリモートマシンにあります。

注：

    1.  どの形式の場合でも、"[d:]"を省略するとカレントドライブを示します。

            [path]filename[.ext]
            @L[path]filename[.ext]
            @R[path]filename[.ext]

    2.  どの形式の場合でも、"[path]"を省略すると指定したドライブのカレントパ
        スを示します。

            [d:]filename[.ext]
            @L[d:]filename[.ext]
            @R[d:]filename[.ext]

        "[d:]"も省略すると、以下の形式になります。

            filename[.ext]
            @Lfilename[.ext]
            @Rfilename[.ext]

    3.  これらの特殊なドライブサフィックス"@L"および"@R"は、ユーザ自身のアプ
        リケーションで２台のマシン上のファイルを参照するためには使えません。
        VIDEOとRFXユーティリティだけがこれらのプレフィックスを認識します。
        ユーザのファイルの中に、これらと同じプレフィックス（"@L"、"@l"、"@R"、
        または"@r"）で始まるファイルがある場合には、"@@"を使ってください。た
        とえば、ディスク上の"@link@"というファイルを参照したいなら、
        "@@link@"と指定できます。".＼@link@"を使ってもかまいません。

ＲＦＸコマンド
--------------
コマンドを指定せずにRFXを起動すると、DOSまたはOS/2のプロンプトは下の例のよう
に変更されます。

例：
        Mon  11-06-1989 15:17:05.84 E:＼DOC＼UG
        E>rfx par
        [RFX] Mon  11-06-1989 15:17:12.75 @LE:＼DOC＼UG
        [RFX] E>

"E:＼DOC＼UG"のカレントドライブ指定子"E"が"@LE"に変更され、カレントドライブ
がローカルの"E"ドライブであることを示していることに注意してください。

プロンプトが表示されているときは、どのようなコマンドでも入力できます。RFX
は、特別なコマンドセットを認識しますが、その他のコマンドはDOSまたはOS/2へ渡
して処理させます。以降の項では、RFXコマンドについて説明します。


カレントドライブの設定　−　ｄｒｉｖｅ：
----------------------------------------
+------------------------------------------------------------------------+
|  drive:                                                                |
+------------------------------------------------------------------------+

このコマンドを使用して、カレントドライブと地域環境を設定することができます。
プレフィックス"@L"または"@R"を使用して、地域環境（ローカルまたはリモート）を
指定できます。

例：
        d:

現在の地域環境（ローカルまたはリモート）の"D"ディスクをカレントドライブにし
ます。地域環境は、何も指定がないので変更されません。

例：
        @rc:

リモートマシンの"C"ディスクをカレントドライブにします。地域環境とディスクの
両方を指定しています。

例：
        @le:

ローカルマシンの"E"ディスクをカレントドライブにします。地域環境とディスクの
両方を指定します。


ディレクトリの変更　−　ＣＨＤＩＲ、ＣＤ
----------------------------------------
+------------------------------------------------------------------------+
|  chdir dir_spec                                                        |
|  cd dir_spec                                                           |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクのカレント
ディレクトリを変更するために使用します。CDはCHDIRの短縮形です。プレフィック
ス"@L"または"@R"を使用して、地域環境（ローカルまたはリモート）を指定できます。

例：
        cd ＼tmp

カレントドライブの"TMP"ディレクトリをカレントディレクトリにします。

例：
        cd d:＼etc

現在の地域環境（ローカルまたはリモート）の"D"ディスクの"ETC"ディレクトリを同
じドライブのカレントディレクトリにします。

例：
        cd @rc:＼demo

リモートマシンの"C"ディスクの"DEMO"ディレクトリを同じドライブのカレントディ
レクトリにします。地域環境とディスクの両方を指定しています。

例：
        cd @le:test

ローカルマシンの"E"ディスクのカレントディレクトリの中にある"TEST"サブディレ
クトリを同じドライブのカレントディレクトリにします。地域環境とディスクの両方
を指定しています。

ファイルの複写　−　ＣＯＰＹ
----------------------------
+------------------------------------------------------------------------+
|  copy[/s]src_spec[dst_spec][/s]                                        |
+------------------------------------------------------------------------+

COPYコマンドは、DOSの"COPY"コマンドおよび"XCOPY"コマンドと非常によく似た働き
をします。ファイルを、ローカルマシンからローカルマシンまたはリモートマシンへ
複写できます。同様に、ファイルを、リモートマシンからローカルマシンまたはリモ
ートマシンへ複写できます。/sを指定すると、サブディレクトリも一緒に複写されま
す。複写先ファイルでディレクトリが必要な場合には、ディレクトリが作成されま
す。dst_specを指定しないと、もう一方の地域環境（ファイルの地域環境がローカル
の場合にはリモート、またはファイルの地域環境がリモートの場合にはローカル）の
カレントディレクトリがデフォルトの複写先になります。

例：
        copy *.for @rd:＼tmp

カレントディレクトリに入っている"FOR"型のすべてのファイルが、リモートマシン
の"D"ディスクの"TMP"ディレクトリに複写されます。現在の地域環境がローカルマシ
ンの場合には、ファイルはローカルマシンからリモートマシンへ複写されます。現在
の地域環境がリモートマシンの場合には、ファイルはリモートマシンからリモートマ
シンへ複写されます。

+------------------------------------------------------------------------+
|  注：　ユーザのデフォルトドライブをローカルマシンのどれかのディスクに  |
|　設定した場合には、地域環境はローカル（たとえば、@LC:、@LD:、@LE:など  |
|　）です。リモートマシンのどれかのディスクに設定した場合には、地域環境  |
|　はリモート（たとえば、@RC:、@RD:、@RE:など）です。ユーザのDOSまたは   |
|　OS/2のプロンプトにカレントドライブとカレントディレクトリが入っている  |
|　場合には、現在の地域環境は簡単に識別できます。                        |
+------------------------------------------------------------------------+

例：
        copy @rd:＼tmp＼*.for

リモートマシンの"D"ディスクの"TMP"ディレクトリに入っている"FOR"型のすべての
ファイルが、ローカルマシンのカレントディレクトリに複写されます。複写先を指定
していない場合には、必ずもう一方の地域環境のカレントディレクトリに複写されま
す。複写元の地域環境がリモートマシンの場合には、ファイルはリモートマシンから
ローカルマシンへ複写されます。複写元の地域環境が現在のマシンの場合には、ファ
イルはローカルマシンからリモートマシンへ複写されます。

例：
        copy @rc:＼watcom＼*.* /s

リモートマシンの"C"ディスクの"WATCOM"ディレクトリに入っているすべてのファイ
ルとサブディレクトリが、ローカルマシンのカレントディレクトリに複写されます。
複写先を指定していない場合には、必ずもう一方の地域環境のカレントディレクトリ
に複写されます。複写元の地域環境がリモートマシンの場合には、ファイルはリモー
トマシンからローカルマシンへ複写されます。複写元の地域環境が現在のマシンの場
合には、ファイルはローカルマシンからリモートマシンへ複写されます。サブディレ
クトリが必要な場合には、サブディレクトリが作成されます。

+------------------------------------------------------------------------+
|  注：　"COPY"コマンドは、あるマシンから別のマシンへファイルを複写する  |
|　ときに最も有効に使用されます。リモートマシンのある場所から同じマシン  |
|　の別の場所へ大量のファイルを複写する場合には、そのリモートマシンのDO  |
|　SまたはOS/2を使用した方が効果的です。そのほうが、データをリモートマ   |
|　シンからローカルマシンへ転送し、またリモートマシンへ戻すという手間が  |
|　省けます。                                                            |
+------------------------------------------------------------------------+


ディレクトリの表示　−　ＤＩＲ
------------------------------
+------------------------------------------------------------------------+
|  dir[/w]dir_spec[/w]                                                   |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクのディレク
トリを表示するために使用します。DOSまたはOS/2の「ワイルドカード」文字（"?"と
"*"）が使用できます。/wを指定すると、ファイル名は画面全体に表示（「ワイド」
表示）され、ファイルの作成日と時刻は省略されます。

例：
        dir ＼tmp

カレントドライブの"TMP"ディレクトリに入っているファイルの名前を表示します。

例：
        dir d:＼etc

現在の地域環境（ローカルまたはリモート）の"D"ディスクの"ETC"ディレクトリに
入っているファイルの名前を表示します。

例：
        dir @rc:＼demo

リモートマシンの"C"ディスクの"DEMO"ディレクトリに入っているファイルの名前を
表示します。地域環境とディスクの両方を指定しています。

例：
        dir @le:test

ローカルマシンの"E"ディスクのカレントディレクトリの中にある"TEST"サブディレ
クトリに入っているファイルの名前を表示します。"TEST"サブディレクトリが存在し
ない場合には、"TEST"という名前のファイルがすべて表示されます。地域環境とディ
スクの両方を指定しています。

例：
        dir @le:test.*

ローカルマシンの"E"ディスクのカレントディレクトリに入っている"TEST"という名
前のファイルをすべて表示します。地域環境とディスクの両方を指定しています。


ファイルの削除　−　ＥＲＡＳＥ、ＤＥＬ
--------------------------------------
+------------------------------------------------------------------------+
|  erase[/s]file_spec[/s]                                                |
|  del[/s]file_spec[/s]                                                  |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクのディレク
トリからファイルを削除するために使用します。DELはERASEの短縮形です。DOSまた
はOS/2の「ワイルドカード」文字（"?"と"*"）が使用できます。/sを指定すると、サ
ブディレクトリも一緒に削除されます。

例：
        erase ＼tmp＼*.*

カレントドライブの"TMP"ディレクトリに入っているファイルをすべて削除します。

例：
        erase d:＼etc＼*.lst

現在の地域環境（ローカルまたはリモート）の"D"ディスクの"ETC"ディレクトリに
入っている"LST"型のファイルをすべて削除します。

例：
        erase @rc:＼demo＼*.obj

リモートマシンの"C"ディスクの"DEMO"ディレクトリに入っている"OBJ"型のファイル
をすべて削除します。地域環境とディスクの両方を指定しています。

例：
        erase @le:trial.*

ローカルマシンの"E"ディスクのカレントディレクトリに入っている"TRIAL"という名
前のファイルをすべて削除します。地域環境とディスクの両方を指定しています。


ＲＦＸの終了　−　ＥＸＩＴ
--------------------------
+------------------------------------------------------------------------+
|  exit                                                                  |
+------------------------------------------------------------------------+

このコマンドは、RFXを終了させて、呼出し側プロセスに戻るために使用します。


ディレクトリの作成　−　ＭＫＤＩＲ、ＭＤ
----------------------------------------
+------------------------------------------------------------------------+
|  mkdir dir_spec                                                        |
|  md dir_spec                                                           |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクにディレク
トリを作成するために使用します。MDはMKDIRの短縮形です。プレフィックス"@L"ま
たは"@R"を使用して、地域環境（ローカルまたはリモート）を指定できます。

例：
        md ＼tmp

カレントドライブのルートに"TMP"ディレクトリを作成します。

例：
        md d:＼etc

現在の地域環境（ローカルまたはリモート）の"D"ディスクのルートに"ETC"ディレク
トリを作成します。

例：
        md @rc:＼demo

リモートマシンの"C"ディスクのルートに"DEMO"ディレクトリを作成します。地域環
境とディスクの両方を指定しています。

例：
        md @le:test

ローカルマシンの"E"ディスクのカレントディレクトリの中に"TEST"というサブディ
レクトリを作成します。地域環境とディスクの両方を指定しています。


ファイル名の変更　−　ＲＥＮＡＭＥ、ＲＥＮ
------------------------------------------
+------------------------------------------------------------------------+
|  rename file_spec new_name                                             |
|  ren file_spec new_name                                                |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクの任意の
ディレクトリに入っているファイルの名前を変更するために使用します。RENはRENAM
Eの短縮形です。プレフィックス"@L"または"@R"を使用して、地域環境（ローカルま
たはリモート）を指定できます。DOSの"RENAME"コマンドと違って、ディレクトリを
new_nameで指定すればファイルを別のディレクトリに移動することができます。

例：
        ren test.tmp test1.tmp

カレントドライブのカレントディレクトリに入っている"TEST.TMP"というファイルの
名前を"TEST1.TMP"に変更します。

例：
        ren d:＼etc＼test.tmp test1.tmp

現在の地域環境（ローカルまたはリモート）の"D"ディスクの"ETC"ディレクトリに
入っている"TEST.TMP"というファイルの名前を"TEST1.TMP"に変更します。

例：
        ren @rc:＼demo＼test.tmp test1.tmp

リモートマシンの"C"ディスクの"DEMO"ディレクトリに入っている"TEST.TMP"という
ファイルの名前を"TEST1.TMP"に変更します。地域環境とディスクの両方を指定して
います。

例：
        ren @le:trial.dat trial1.dat

ローカルマシンの"E"ディスクのカレントディレクトリに入っている"TRIAL.DAT"とい
うファイルの名前を"TRIAL1.DAT"に変更します。地域環境とディスクの両方を指定し
ています。

例：
        ren @le:trial.dat ..＼trial1.dat

ローカルマシンの"E"ディスクのカレントディレクトリに入っている"TRIAL.DAT"とい
うファイルの名前を"TRIAL1.DAT"に変更し、それを親ディレクトリに移動します。地
域環境とディスクの両方を指定しています。


ディレクトリの削除　−　ＲＭＤＩＲ、ＲＤ
----------------------------------------
+------------------------------------------------------------------------+
|  rmdir[/s]dir_spec[/s]                                                 |
|  rd[/s]dir_spec[/s]                                                    |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクにある１つ
または複数のディレクトリを削除するために使用します。RDはRMDIRの短縮形です。
プレフィックス"@L"または"@R"を使用して、地域環境（ローカルまたはリモート）を
指定できます。/sを指定すると、サブディレクトリも一緒に削除されます。ディレク
トリを削除するには、そのディレクトリに何もファイルが入っていないことが必要
です。

例：
        rd ＼tmp

カレントドライブのルートから"TMP"ディレクトリを削除します。

例：
        rd d:＼etc

現在の地域環境（ローカルまたはリモート）の"D"ディスクのルートから"ETC"ディレ
クトリを削除します。

例：
        rd @rc:＼demo

リモートマシンの"C"ディスクのルートから"DEMO"ディレクトリを削除します。地域
環境とディスクの両方を指定しています。

例：
        rd @le:test

ローカルマシンの"E"ディスクのカレントディレクトリから"TEST"サブディレクトリ
を削除します。地域環境とディスクの両方を指定しています。


ファイル内容の表示　−　ＴＹＰＥ
--------------------------------
+------------------------------------------------------------------------+
|  type dir_spec                                                         |
+------------------------------------------------------------------------+

このコマンドは、ローカルマシンまたはリモートマシンの任意のディスクのファイル
の内容を表示するために使用します。プレフィックス"@L"または"@R"を使用して、地
域環境（ローカルまたはリモート）を指定できます。DOSの"TYPE"コマンドと違って、
DOSまたはOS/2の「ワイルドカード」文字（"?"または"*"）を使用できます。

例：
        type ＼tmp＼test.dat

カレントドライブの"TMP"ディレクトリに入っている"TEST.DAT"ファイルの内容を表
示します。

例：
        type d:＼etc＼*.lst

現在の地域環境（ローカルまたはリモート）の"D"ディスクの"ETC"ディレクトリに
入っている、すべての"LST"型のファイルの内容を表示します。

例：
        type @rc:＼demo＼test.c

リモートマシンの"C"ディスクの"DEMO"ディレクトリに入っている"TEST.C"ファイル
の内容を表示します。地域環境とディスクの両方を指定しています。

例：
        type @le:trial.*

ローカルマシンの"E"ディスクのカレントディレクトリに入っている"TRIAL"という名
前のファイルの内容を、その型に関係なく表示します。地域環境とディスクの両方を
指定しています。
::::SET
+------------------------------------------------------------------------+
|　Set                                                                   |
|　　Assembly{Lower|Upper|Inside|Outside}                                |
|　　Bell  ON|OFf                                                        |
|　　Call  [dflt_call][dflt_parms][dflt_return]                          |
|　　Dclick expr                                                         |
|　　Fpu   Binary|Decimal                                                |
|　　Implicit ON|OFf                                                     |
|　　INput  window_name                                                  |
|    LAnguage lang_name                                                  |
|    Level  Assembly|Mix|Source                                          |
|    MAcro  window_name key_expr[cmd_list]                               |
|    Menu   ON|OFf|Add cmd_list|ACtivate                                 |
|    Pfkey  expr(string|"{"string"}")                                    |
|    Radix  expr|("/"radix_spec [expr])                                  |
|    SOurce [/Add]{"{"{char}"*"{char}"}"}                                |
|    SYmbol [/Add]{[/(Respect|Ignore)]"{"{char}"*"{char}"}"}             |
|    Tab  expr                                                           |
|    Visible Assembly|Source[top][,[bot][,bias]]                         |
+------------------------------------------------------------------------+

Setコマンドは、その他のVIDEOコマンドに対する動作上のデフォルトを設定するため
に使用します。


逆アセンブラオプション
----------------------
+------------------------------------------------------------------------+
|　Set Assembly{Lower|Upper|Inside|Outside}                              |
+------------------------------------------------------------------------+

これらのオプションはアセンブラ命令とオペランドの表示方法を制御します。"lower
"オプションは、命令コードとレジスタを小文字で表示します。"upper"オプション
は、命令コードとレジスタを大文字で表示します。"inside"オプションは、レジスタ
のインデックス変位を括弧の中に示します（例：　[BP-2]、[EBP-2]）。"outside"オ
プションは、レジスタのインデックス変位を括弧の外に示します（例：　-2[BP]、-2
[EBP]）。

警告ベル
--------
+------------------------------------------------------------------------+
|　Set Bell ON|OFf  　                                                   |
+------------------------------------------------------------------------+

VIDEOが出す警告のビープ音を「オン」または「オフ」にすることができます。この
ビープ音は、デバッガがエラーメッセージを表示するときに常に鳴ります。


デフォルトの呼出し
------------------
+------------------------------------------------------------------------+
|　Set Call [dflt_call][dflt_parms][dflt_return]                         |
+------------------------------------------------------------------------+

VIDEOのCallコマンドによって使用されるデフォルトの呼出し型（Far、Interrupt、
またはNear）とデフォルトの引数受渡しメカニズムを設定できます。

        dflt_call ::= /(Far|Interrupt|Near)
        dflt_parms ::= "("[dflt_loc{","dflt_loc}]")"
        dflt_return ::= "/"|print_list
        dflt_loc ::= reg_name|reg_aggregate

次の例では、Callコマンドに対してWATCOMのデフォルト呼出し規則を定義していま
す。

例：
        DBG>set call /far (ax, dx, bx, cx) ax

次のコマンドを発行すると、デフォルトの呼出し規則を、"near"呼出しを使用し、全
パラメータをスタック上に渡す呼出し規則に変更することができます。

例：
        DBG>set call /near () ax

引数の受渡し方法の詳細については、Callコマンドの説明を参照してください。

ダブルクリック速度の設定
------------------------
+------------------------------------------------------------------------+
|　Set Dclick expr                                                       |
+------------------------------------------------------------------------+

このコマンドは、マウスボタンを２回押したときにそれが、２回のクリックとしてで
はなく、１回のダブルクリックとして認識できる、クリック間の最大間隔をミリ秒単
位で設定します。デフォルト値は250ミリ秒（４分の１秒）です。

例：
        DBG>set dclick 750

この例では、750ミリ秒（４分の３秒）より長い間隔でマウスを２回押すと、ダブル
クリックではなく、クリック２回と見なされます。

コマンドshow set dclickは現在の設定値を表示します。


数値データプロセッサ表示のフォーマット
--------------------------------------
+------------------------------------------------------------------------+
|　Set Fpu Binary|Decimal                                                |
+------------------------------------------------------------------------+

80x87数値データプロセッサ（NDP、数値演算コプロセッサ）のレジスタST(0)、レジ
スタST(1)などの内容を、16進（バイナリ）フォーマットまたは科学計算用表記法（
10進）で表示できます。数値演算コプロセッサのレジスタおよびフラグはFPUウィン
ドウに表示されます。

コマンドshow set fpuは現在の設定値を表示します。


コマンドファイルの自動呼出し
----------------------------
+------------------------------------------------------------------------+
|　Set Implicit ON|OFf                                                   |
+------------------------------------------------------------------------+

"implicit"が"on"の場合には、VIDEOは間違ったコマンドをコマンドファイル名と見
なして、自動的にそれを呼び出そうとします。"implicit"が"off"の場合には、
INVokeコマンドを使用しなければなりません。

例：
        DBG>set implicit on
        DBG>* invoke "mix" command file
        DBG>mix

QNXの下では、"implicit"が「オン」になっていると矛盾が生じることがあります。
コマンドファイル名にパスが指定してあると、それがDOコマンドの省略形"/"と間違
えられてしまいまうからです。

例：
        DBG>/etc=1
        DBG>/etc/wvideo/mix

最初の例では、変数etcに値１を割り当てています。２番目の例では、"mix"コマンド
ファイルを/etc/wvideoディレクトリから起動しようとしますが、構文エラーが起き
ます。
INvokeコマンドまたはローカルファイル指定子プレフィックス"@1"を使うと、このよ
うな問題を解決することができます。

例：
        DBG>invoke /etc/wvideo/mix
        DBG>@1/etc/wvideo/mix

ファイル名にドライブ指定子が入っている場合には、DOS、MS Windows、またはOS/2
でも同じような問題が起こります。

例：
        DBG>d:＼watcom＼binb＼mix
        DBG>invoke d:＼watcom＼binb＼mix
        DBG>@1d:＼watcom＼binb＼mix

最初の例では構文エラーが起きます（"d"がDisplayコマンドの省略形と解釈されるた
めです）。２、３番目の例ではこの問題が解決されています。

ローカルファイルとリモートファイルの指定子プレフィックスについては、「リモー
トデバッグ」の章で説明してあります。


現在のウィンドウ
----------------
+------------------------------------------------------------------------+
|　Set INput window_name                                                 |
+------------------------------------------------------------------------+

Set INputコマンドは、テキストカーソルを指定ウィンドウに直接移動するために使
用します。有効なウィンドウ名は次のとおりです。

        Assembly
        Command
        Dialogue
        Fpu
        Memory
        Prompt
        Register
        SOurce
        STack
        Thread

TabキーおよびShift Tabキーを使用して、次のウィンドウまたは前のウィンドウにテ
キストカーソルを移動することもできます。選択したウィンドウがアクティブウィン
ドウになります。キーとマウスの動作については、「VIDEOウィンドウ」の章の「キー
を用いたウィンドウ操作」の節および「マウスを用いたウィンドウ操作」の項で説明
してあります。


式の構文
--------
+------------------------------------------------------------------------+
|　Set LAnguage lang_name                                                |
+------------------------------------------------------------------------+

デバッガの式プロセッサは、特定のプログラミング言語の構文を理解するように設定
することができます。オペランドlang_nameは式構文名または"parse"ファイル名を表
します。

Ｃ      ファイル"c.prs"は、VIDEOがサポートしているANSI Cプログラミング言語式
        構文を記述しています。

FORTRAN ファイル"fortran.prs"は、VIDEOがサポートしているANSI FORTRAN 77プロ
        グラミング言語式構文を記述しています。

DOS、MS Windows、またはOS/2では、"prs"ファイルは通常、VIDEOがインストールさ
れているディレクトリの"BINB"サブディレクトリに入っています。"BINB"ディレクト
リがPATH環境変数に入っているか確認してください。

例：
        DBG>set language fortran

デバッガは、"fortran.prs"からFORTRAN 77用の式構文をロードします。

コマンドshow set languageは現在の設定値を表示します。


デバッグレベル
--------------
+------------------------------------------------------------------------+
|　Set Level Assembly|Mix|Source                                         |
+------------------------------------------------------------------------+

Set Levelコマンドはデフォルトのデバッグレベルを設定するのに使用します。

Assembly    VIDEOはデバッグ情報をアセンブラ言語レベルで表示します。

            例：
                DBG>set level assembly

Mix         VIDEOは、ソース行情報が使用可能な場合には必ずデバッグ情報をソー
            ス言語レベルで表示します。ソース行情報が使用不可の場合には、アセ
            ンブラ言語レベルで表示します。

            例：
                DBG>set level mix

            これはVIDEOのデフォルトモードです。

Source      source言語レベルはmix言語レベルと似ていますが、ソース行情報が使
            用できないモジュールは、明示的に要求されていない限りトレースしな
            い点が異なります。

            例：
                DBG>set level source


マクロホットキー
----------------
+------------------------------------------------------------------------+
|　Set MAcro window_name key_expr[cmd_list]                              |
+------------------------------------------------------------------------+

Set MAcroコマンドを使用して、いろいろなウィンドウに対して「ホット」キーを定
義することができます。有効なウィンドウ名は次のとおりです。

        Assembly
        Command
        Dialogue
        Fpu
        Memory
        Register
        SOurce
        STack
        Thread

key_exprの値は32（空白）から126（波形記号）の範囲内でなければなりません。こ
れらは印刷可能なASCII文字です。１つまたは複数のデバッガコマンドをcmd_listに
指定することができます。

例：
        DBG>set macro source 'v' {view}

この例では、Sourceウィンドウがアクティブのとき（すなわち、テキストカーソルが
ソーSourceウィンドウにあるとき）に小文字の"v"を押すと、コマンドviewが起動さ
れます。

例：
        DBG>set macro assembly 'b' {break dbg$code}

この例では、Assemblyウィンドウがアクティブのとき（すなわち、テキストカーソル
がAssemblyウィンドウにあるとき）に小文字の"b"を押すと、コマンドbreak dbg$co
deが起動されます。現在ハイライト表示されている行にブレークポイントが設定され
ます。

例：
        DBG>set macro source ' ' {trace/source/over}

この例では、Sourceウィンドウがアクティブのとき（すなわち、テキストカーソルが
Sourceウィンドウにあるとき）にスペースバーを押すと、コマンドtrace/source/ov
erが起動されます。シングルショットトレース・コマンドが実行されます。

+------------------------------------------------------------------------+
|　注：　Promptウィンドウにはテキストを入力しなければならないので、この  |
|　ウィンドウだけはホットキーを定義できません。                          |
+------------------------------------------------------------------------+


メニューバー
------------
+------------------------------------------------------------------------+
|　Set Menu ON|OFf|Add cmd_list|ACtivate                                 |
+------------------------------------------------------------------------+

Set Menu ONコマンドとSet menu OFf コマンドは、メニューバーの表示を「オン」ま
たは「オフ」にします。

Set Menu Addコマンドを使用して、"User"ポップダウンメニューにコマンドエントリ
を作成することができます。１つのエントリは、１つまたは複数のVIDEOコマンドの
リストになっています。新しい各エントリにはアルファベット１字のラベルが付けら
れます。Alt/Uキーを押して"User"ポップダウンメニューを開き、Alt/<文字>（<文字
>は選択したいエントリの横にある文字です）を押して、エントリを選択することが
できます。マウスを使用してエントリを選択することもできます。エントリを選択す
ると、エントリにリストされているコマンドが実行されます。"User"メニューには最
大20項目まで追加できます。

Set Menu ACtivateコマンドは、Altキーを押して離す操作をエミュレートします。

例：
        DBG>set pfkey 10 {set menu activate}

この例では、Set Menu ACtivateコマンドをプログラム可能ファンクションキー10に
バインドしています。

VIDEOメニューについては「VIDEOメニュー」の章を参照してください。


プログラム可能ファンクションキー
--------------------------------
+------------------------------------------------------------------------+
|　Set Pfkey expr(string|"{"string"}")                                   |
+------------------------------------------------------------------------+

１つまたは複数のVIDEOコマンドを１つのプログラム可能ファンクション（PF）キー
に割り当てることができます。割り当てた後、そのPFキーを押すたびに割り当てられ
たコマンドが実行されます。VIDEOはセミコロンをコマンド分離記号として使うので、
stringに";"を入れる場合には、"{"および"}"を使用しなければなりません。string
を省略すると、指定したPFキーに現在割り当てられているコマンドは削除されます。
PFキーには１から40まで番号が付けられています。

F1-F10  PFキー１から10を得るにはF1からF10のキーの１つを押します（キーボード
        によっては、PF1からPF10のラベルが付けられています）。

F11-F20 PFキーの11から20を得るにはShiftキーとF1からF10のキーの１つを押します。

F21-F30 PFキーの21から30を得るにはCtrlキーとF1からF10のキーの１つを押します。

F31-F40 PFキーの31から40を得るにはAltキーとF1からF10のキーの１つを押します。

式exprは、数字に対する現在のデフォルト基数に関係なく、常に基数10で評価されます。

例：
        DBG>set pfkey 1 go/keep

この例では、ファンクションキーF1にgo/keepコマンドが定義されます。F1キーを押
すたびに、VIDEOはこのコマンドを実行します。この形式の"go"コマンドは、以前の
"go"コマンドで指定された一時的ブレークポイントを保持します。

例：
        DBG>set pf 1 {go/keep;?ax}

この例は、２番目のコマンドが追加されている以外は前の例と同じです。この場合に
は、F1キーを押すたびに２つのコマンドが実行されます。ブレークポイントが発生す
ると、AXレジスタの内容がDialogueウィンドウに表示されます。この例を見ると、括
弧の重要性がわかります。

例：
        DBG>set pf 1 go/keep;?ax

この例のように大括弧を省略すると、VIDEOは最初にSetコマンドを実行し、次に
Print（?）コマンドを実行します。これは以下のように、２つのコマンドを２つのコ
マンド行に分けて発行するのと同じです。

例：
        DBG>set pf 1 go/keep
        DBG>?ax

例：
        DBG>/k1=-1
        DBG>set pf 1 if ++k1%3==0{<src}{if k1%3==1{<asm}{<mix}}

ユーザ定義シンボルk1に-1を設定し、コマンドファイル"src.dbg"、"asm.dbg"、およ
び"mix.dbg"の間を循環するのに使用できるコマンドをプログラム可能ファンクショ
ンキー１には割り当てています。

例：
        DBG>set pf 1

ファンクションキー１に現在割り当てられているコマンドは削除されます。


デフォルトの数字基数と指定子
----------------------------
+------------------------------------------------------------------------+
|　Set Radix expr|("/"radix_spec[expr])                                  |
+------------------------------------------------------------------------+

このコマンドを使用して、ユーザが入力する数字に対するデフォルト基数と、基数指
定子として解釈される文字列の両方を定義することができます。式exprは、数字に対
する現在のデフォルト基数に関係なく、常に基数10で評価されます。


デフォルト基数の設定
--------------------
+------------------------------------------------------------------------+
|　Set Radix expr                                                        |
+------------------------------------------------------------------------+

例：
        DBG>set radix 10
        DBG>set radix 16
        DBG>set radix 8

これらの例は、ユーザが入力する数字に対するデフォルト基数の設定方法を示してい
ます。最初の例では、デフォルトの基数を10進（すなわち、基数10）に、２番目の例
では16進（基数16）に、そして３番目の例では８進（基数８）に設定しています。指
定できる最小基数は２で、最大基数は36です。数値に使用できるのは数字０から９お
よび英字アルファベット（ＡからＺまたはａからｚ）です。

ここで、デフォルトの基数が36に設定されていると仮定します。すると、10進値の10
は'A'で表され、11は'B'で表されます。このように35に対応する'Z'まで表現できます。

基数指定子がない場合には、デフォルトの基数に有効な文字だけが数値中に現れま
す。たとえば、デフォルト基数が16ならば、'G'から'Z'の文字を使用できません。

数値定数をシンボル名として正しく解釈できる場合には、VIDEOは最初にその名前で
シンボルを探しますが、見つからなかったときにはその文字列を定数として扱います。

例：
        DBG>/abc=1
        DBG>?abc

１番目の例では、"abc"という変数を定義して、それに１を割り当てます。２番目の
例では、デバッガに"abc"の値を表示するよう要求されています。デフォルトの基数
が16としたなら、これは数値を表すことができます（10*16**2+11*16+12）。しかし、
VIDEOは最初にシンボル"abc"を見つけようとします。これは見つかるはずですから、
Dialogueウィンドウに表示される値は１になります。文字の前に数字'0'を付けるだけ、
簡単に数値定数を作れることに注意してください。

例：
        DBG>?0abc

定数が'0'から'9'の数字のどれかで始まっている場合には、VIDEOはそれを数値とし
て解釈します。このため、シンボル名の先頭に'0'から'9'の数字を付けることはでき
ません。

基数指定子の設定
----------------
+------------------------------------------------------------------------+
|　Set Radix "/"radix_spec[expr]                                         |
+------------------------------------------------------------------------+

Set Radixコマンドのもう１つの機能は、１つまたは複数の基数指定子を定義できる
ことです。

例：
        DBG>set radix /0x 16

この例では、16進（基数16）数を導入するために文字列"0x"を定義しています。した
がって、0x12は16進定数を表します。

式を省略すると、この文字列は現在定義されている基数指定子のセットから削除され
ます。

例：
        DBG>set radix /0x

この例では、文字列"0x"は基数指定子のセットから削除されます。すると、0x12は不
正な定数となります。

例：
        DBG>set radix /# 10

この例では、10進（基数10）数を導入するために文字列"#"を定義しています。した
がって、#12は10進定数を表します。

基数指定子の選択を定義することによって、現在のデフォルト基数に依存せずに、数
値を希望する基数で入力することができます。


ソースファイル探索パターン
--------------------------
+------------------------------------------------------------------------+
|　Set SOurce[/Add]{{char}"*"{char}}                                     |
+------------------------------------------------------------------------+

このコマンドは、VIDEOがモジュール名に対応するソースファイルを探索するときに
モジュール名に適用するパターンを定義するために使用します。VIDEOはまず、ソー
スファイルをコンパイルするのに使用したファイル指定を使って、ソースファイルを
オープンしようとします。次のような場合には、正しくソースファイルを指定するメ
カニズムが必要になります。

    1.　コンパイル時に相対パス指定が与えられ、プログラムを実行しているディレ
        クトリがファイルをコンパイルしたディレクトリと異なっている。
    2.　ソースファイルをコンパイルした後、別のディレクトリへ移した。

以下ではDOS、MS Windows、またはOS/2のファイル名指定を使っています。

カレントディレクトリが"＼TEST＼O"で、ソースファイル（"HELLO.C"）がディレクト
リ"＼TEST＼C"に入っていると仮定します。また、以下のコマンドを使用して"HELLO.
C"をコンパイルすると仮定します。

例：
        C>wcc ..＼c＼hello -d2

コンパイラは文字列"..＼C＼HELLO.C"をオブジェクトファイルに入れます。１つ上の
ディレクトリに移動して、プログラムをリンクするとします。その後、"＼TEST"ディ
レクトリから移動せずに、VIDEOを使用してプログラムをロードして実行します。
デバッガはソースファイル指定"..＼C＼HELLO.C"を使うので、ソースファイルを見つ
けることができません。

例：
        DBG>set source *.c

この例では、見つからない場合には、モジュール名に".c"を付加してソースファイル
を探索してみるようにVIDEOに指示しています。アスタリスクはモジュールの場所ホ
ルダーとして使用されます。前の例のモジュール名は"HELLO"でした。このため、"..
＼C＼HELLO.C"が見つからなかった場合には、ファイル"HELLO.C"を見つけようとしま
す。しかし、これも失敗します。

例：
        DBG>set source ＼test＼c＼*.c

この例では、パターンを修正してソースファイルのパス指定を入れています。今度は
ファイル"＼TEST＼C＼HELLO.C"を見つけようとするので、探索は成功します。

例：
        DBG>set source *.c ＼test＼c＼*.c

この例では、ソースファイルの可能性のある名前のリストに２番目のパターンを追加
しています。VIDEOは"HELLO.C"としてカレントディレクトリでソースファイルを見つ
けることができない場合には、"＼TEST＼C＼HELLO.C"で見つけられるか試してみます。

/Add修飾子を指定して、現在定義されているパターンセットにさらにパターンを追加
したいことを示すことができます。この修飾子がない場合には、VIDEOは現在のパター
ンセットを新しく指定するパターンで置き換えます。次の例は前の例と等価です。

例：
        DBG>set source *.c
        DBG>set source /add ＼progs＼src＼*.c


シンボル名パターンマッチ
------------------------
+------------------------------------------------------------------------+
|　Set SYmbol[/Add]{[/(Respect|Ignore)]{char}"*"{char}}                  |
+------------------------------------------------------------------------+

このコマンドは、VIDEOがシンボルを探索する方法を制御するために使用します。
デフォルトでは、大文字と小文字の区別およびスペルが同じときにシンボル名は一致
します。このコマンドを使用して、これらの制限を緩めることができます。

言語コンパイラはよく、アンダースコア"_"や通貨記号"$"などの、１つまたは複数の
プレフィックスまたは接尾語をユーザ定義のグローバルシンボルに付けます。ときに
は名前のすべての文字を大文字または小文字に変換します。シンボル名の指定を簡略
化するために、VIDEOがシンボルを探索するときに使用する一連のパターンを定義す
ることができます。

例：
DBG>set symbol *_

このパターンは、ユーザが指定する名前の後にアンダースコアを付けてもよいことを
示しています。たとえば、mainは実際にはmain_というスペルになっているかもしれ
ません。アスタリスクはユーザ指定名の場所ホルダーとして使用されます。

複数のパターンを指定できます。

例：
DBG>set symbol *_ _*

この例では、mainのスペルとしてmain_でも_mainでもよいことを指定しています。
VIDEOは、指定されたパターンを使ってシンボルを探索します。パターンは指定され
た順に処理されます。パターンを指定しない場合には、VIDEOはスペルと大文字と小
文字の区別が完全に一致する名前だけを探索します。

大括弧を使ってパターンを区切ることができます。

例：
DBG>set symbol {*_} {_*}

大括弧の中では、空白文字は意味を持ちます。したがって、シンボル名に空白文字が
入る特別な場合を除いて、通常は空白文字は入れないでください。

/Add修飾子を指定して、現在定義されているパターンセットにさらにパターンを追加
したいことを示すことができます。この修飾子がない場合には、VIDEOは現在のパター
ンセットを新しく指定するパターンで置き換えます。

パターンリストの前に/Respectまたは/Ignoreを指定して、名前の探索プロセスにお
いて大文字と小文字の区別をするかどうか指示することができます。

例：
DBG>set symbol /ignore *_ _*

この例では、各パターン置換に対して、名前の大文字と小文字を区別しないことを指
示しています。この場合には、ユーザ指定の名前mainは、main_、Main、MAIN_、_MAi
Nなどの多くのスペルと一致します。

この例では、MAINはユーザ指定のmainと一致するようにはなっていませんでした。一
致するようにするには、次のコマンドを発行します。

例：
        DBG>set symbol  /add /ignore *

これでVIDEOは、大文字と小文字の区別に関係なく、スペルが全く同じ名前も検索し
ます。

大文字と小文字に区別に基づいて、パターンマッチに対してもっと複雑な規則を作成
することができます。

例：
        DBG>set symbol /ignore * *_ _* /RESPECT _*_

この例では、最初の３パターンについては名前の大文字と小文字を区別せず、最後の
パターンについては区別するよう指示しています。ユーザ指定の名前がcmainで、実
際のスペルが_CMAIN_の場合には、デバッガは一致とは見なしません。しかし、ユー
ザがCMAINを指定した場合には、デバッガは、CMAINと_CMAIN_は一致すると見なします。


タブ間隔の設定
--------------
+------------------------------------------------------------------------+
|　Set Tab expr                                                          |
+------------------------------------------------------------------------+

このコマンドは、デバッガが、TAB文字を埋め込んで、テキストファイルどのように
表示するかを制御します。TAB文字を入力すると、後続のテキストは次のタブストッ
プから始まります。デフォルトでは、タブストップは８カラムごとに設定されます。
Set Tabコマンドを使ってこのデフォルトを変更できます。

例：
        DBG>set tab 4

この例では、タブストップを４カラムごとに設定します。

コマンドshow set tabは現在のタブ設定値を表示します。


ＳｏｕｒｃｅおよびＡｓｓｅｍｂｌｙウィンドウの行コンテキスト
------------------------------------------------------------
+------------------------------------------------------------------------+
|　Set Visible Source|Assembly[top][,[bot],[bias]]                       |
+------------------------------------------------------------------------+

このコマンドは、デバッガがソーステキストをSourceウィンドウに、またはアセンブ
ラコードをAssemblyウィンドウに表示する方法を制御します。これら２つのウィンド
ウでは、テキスト行またはアセンブラ行をスクロールするときに現在行の上（top）
および下（bot）に残しておく行数をデバッガに指示することができます。また、カ
ラム１以外のカラム（bias）から行を表示するようにデバッガに指示することもでき
ます。

例：
        DBG>set visible source 1,2,9

この例では、現在の行より少なくとも１行上と、少なくとも２行下を表示し、そして
ソーステキストの最初の８カラムを表示しないようデバッガに指示しています。ウィ
ンドウが小さすぎてデバッガがこれらの制約に従えない場合には、デバッガはできる
だけ制約に従うようにします。

コマンドshow set visibleは、SourceウィンドウおよびAssemblyウィンドウに対する
現在の設定値を表示します。
::::SHOW
+------------------------------------------------------------------------+
|　SHow                                                                  |
|  　Calls [expr]                                                        |
|    Display{window_name}                                                |
|    Flip                                                                |
|    Modules[name]                                                       |
|    Paint {window_name}                                                 |
|    Set   {Assembly|Bell|Call|Dclick|Fpu|Implicit|                      |
|        INput|LAnguage|Level|MAcro|Menu|pfkey                           |
|        Radix|SOurce|SYmbol|Tab|Visible}                                |
+------------------------------------------------------------------------+

SHowコマンドを使用して、現在実行しているアプリケーションの情報といろいろな
VIDEO設定値を表示することができます。


呼出し側シーケンスの表示
------------------------
+------------------------------------------------------------------------+
|　SHow Calls[expr]                                                      |
+------------------------------------------------------------------------+

このコマンドは、呼出し側シーケンスの実行トレースバックを表示するために使用し
ます。実行トレースバックを表示するには、トレースバックにある全関数に対する
ローカルシンボル情報が必要です。VIDEOは、ローカルシンボル情報が使用できなく
なるまでの全関数をリストします。ローカルシンボル情報の生成の詳細については、
"WATCOM Linker User's Guide"（「DEBUGコマンド」）を参照してください。

式を指定すると、式が評価され、呼出し側シーケンスのレベル数だけが表示されます。

次の例では、Ｃ "Calendar"プログラムの呼出し側シーケンスを示します。

例：
        DBG>show calls
        at          PosCursor+32(calendar@160)
        called from Line+68(calendar@147)
        called from Box+39(calendar@121)
        called from Calendar+43(calendar@79)
        called from main+70(calendar@40)

次の例では、FORTRAN 77 "Calendar"プログラムの呼出し側シーケンスを示します。

例：
        DBG>show calls
        at          POSCURSOR+22(calendar@149)
        called from LINE+234(calendar@124)
        called from BOX+65(calendar@101)
        called from CALENDAR+107(calendar@63)
        called from FMAIN+120(calendar@22)
        DBG>long


ウィンドウ設定値の表示
----------------------
+------------------------------------------------------------------------+
|　SHow Display{window_name}                                             |
+------------------------------------------------------------------------+

このコマンドは、全ウィンドウまたは一部のウィンドウの設定値を表示するために使
用します。有効なウィンドウ名は次のとおりです。

        Assembly
        Command
        Dialogue
        Fpu
        Memory
        Prompt
        Register
        SOurce
        STack
        Thread

例：
        DBG>show display assembly register
        display assembly /open {Assembly: *} 20,24,1,80
        display register /close {CPU} 3,22,72,80

ウィンドウ名を指定しない場合には、全ウィンドウの設定値が表示されます。


Ｆｌｉｐ設定値の表示
--------------------
+------------------------------------------------------------------------+
|　SHow Flip                                                             |
+------------------------------------------------------------------------+

このコマンドは、画面切替えの現在の設定値を表示するために使用します。詳細は
Flipコマンドの説明を参照してください。


モジュール名の表示
------------------
+------------------------------------------------------------------------+
|　SHow Modules [name]                                                   |
+------------------------------------------------------------------------+

このコマンドは、現在のアプリケーションの中のモジュール名を表示するために使用
します。名前を指定すると、"name"で始まるモジュール名だけが表示されます。

例：
        DBG>show module fp
        FPRTF FPUTC

この例では、文字"fp"で始まる全モジュール名がDialogueに表示されます。


ウィンドウ属性値の表示
----------------------
+------------------------------------------------------------------------+
|　SHow Paint{window_name}                                               |
+------------------------------------------------------------------------+

このコマンドは、全ウィンドウまたは一部のウィンドウの属性の設定値を表示するた
めに使用します。有効なウィンドウ名は次のとおりです。

        Assembly
        Command
        Dialogue
        Fpu
        Memory
        Prompt
        Register
        SOurce
        STack
        Thread

ウィンドウ名を指定しない場合には、全ウィンドウに対する属性の設定値が表示され
ます。サブセットを表示するには、関心のあるウィンドウ名だけを指定してください。

例：
        DBG>show paint source dialogue
        paint source plain cyan,black
        paint source active black,cyan
        paint source standout brown,black
        paint source title bright brown,black
        paint source gadget black,white
        paint dialogue plain white,black
        paint dialogue active bright brown,black
        paint dialogue standout bright magenta,black
        paint dialogue title bright brown,black
        paint dialogue gadget black,white
        paint dialogue plain white,black


デバッガ設定値の表示
--------------------
+------------------------------------------------------------------------+
|　SHow Set{item_names}                                                  |
+------------------------------------------------------------------------+

このコマンドは、いろいろなVIDEOパラメータの現在の設定値を表示するために使用
します。有効な項目名は次のとおりです。

        Assembly
        Bell
        Call
        Dclick
        Fpu
        Implicit
        INput
        LAnguage
        Level
        MAcro
        Menu
        Pfkey
        Radix
        SOurce
        SYmbol
        Tab
        Visible

引数を指定しない場合には、全設定値が表示されます。サブセットを表示するには、
関心のある項目だけを指定してください。

例：
        DBG>show set pfkey radix
        set pfkey 1 {help}
        set pfkey 4 {if !?_dbg@pf_4 {/_dbg@pf_4=0};
            if (++_dbg@pf_4)&1 {disp fpu /o} {disp fpu /c}}
        set pfkey 5 {reg -1}
        set pfkey 6 {reg +1}
        set pfkey 7 {/++ _dbg@dbg$wind_split;<wind}
        set pfkey 8 {if !?_dbg@pf_8 {/_dbg@pf_8=0};
            if (++_dbg@pf_8)&1 {set menu off;<wind}
            {set menu on;<wind}}
        set pfkey 9 {set input source}
        set pfkey 10 {setinput assembly}
        set radix /0n 10
        set radix /0x 16
        set radix /0 8
        set radix 10

この例では、プログラム可能ファンクションキー、デフォルトの基数および基数指定
子の現在の設定値が表示されています。
::::SUMMARY
BREAK       -ブレークポイントの設定
CALL        -ルーチンの呼出し
DISPLAY     -VIDEOウィンドウの作成および削除
DO          -変数、レジスタなどに値を割当て
ERROR       -画面にエラーを表示
EXAMINE     -メモリ内容の検査
FLIP        -アプリケーションの出力画面への切替え
GO          -実行の再開
HELP        -対話型ヘルプ機能を要求
IF          -１つまたは複数のVIDEOコマンドの条件付き実行
INVOKE      -VIDEOコマンドファイルの実行
LOG         -VIDEO出力をファイルへログ採取
MODIFY      -メモリ位置の変更
NEW         -タスクの再ロード、コマンド行の再指定、または標準入力ファイルお
            よび標準出力ファイルのリダイレクト
PAINT       -VIDEOウィンドウのカラー属性を設定
PRINT       -変数内容の表示
QUIT        -アプリケーションのデバッグを終了してVIDEOから抜け出す
REGISTER    -特定のレジスタセットのリストア
REMARK      -VIDEOコマンドファイルの説明
SET         -いろいろなVIDEOオペレーティングパラメータの設定（逆アセンブラ
            フォーマット、警告ベル、"Call"コマンド規則、マウスダブルクリック
            速度、数値演算コプロセッサ表示、コマンドファイル呼出し、現在の
            ウィンドウ、式の文法、言語レベル、マクロホットキー、メニュー表示、
            プログラム可能ファンクションキー、数字基数、ソースファイル位置お
            よび命名パターン、シンボル名の大文字／小文字区別および命名規則、
            ソースファイルタブ設定、SourceウィンドウおよびAssemblyウィンドウ
            のテキスト表示境界）
SHOW        -いろいろなVIDEOオペレーティングパラメータの表示
SYSTEM      -VIDEO内からのサブプロセスの呼出し
THREAD      -OS/2またはNetWare386の下でのマルチスレッド・アプリケーションの
            実行スレッドの操作
TRACE       -１度に１行ずつプログラム実行をトレース
VIEW        -ファイル内容の検査
WATCH       -変数または位置に対する変更を監視するようVIDEOに要求
WHILE       -式が真なら１つまたは複数のVIDEOコマンドを実行
::::SYMBOLS
VIDEOは、特別な意味を持つシンボルを数多く定義しています。各レジスタは特殊な
名前で指定します。

eax     32ビットEAXレジスタ（32ビットモードのみ）
ax      16ビットAXレジスタ
al      ８ビットALレジスタ
ah      ８ビットAHレジスタ
ebx     32ビットEBXレジスタ（32ビットモードのみ）
bx      16ビットBXレジスタ
bl      ８ビットBLレジスタ
bh      ８ビットBHレジスタ
ecx     32ビットECXレジスタ（32ビットモードのみ）
cx      16ビットCXレジスタ
cl      ８ビットCLレジスタ
ch      ８ビットCHレジスタ
edx     32ビットEDXレジスタ（32ビットモードのみ）
dx      16ビットDXレジスタ
dl      ８ビットDLレジスタ
dh      ８ビットDHレジスタ
eip     命令ポインタレジスタ（32ビットモードのみ）
ip      命令ポインタレジスタ
esi     ソースインデックスレジスタ（32ビットモードのみ）
si      ソースインデックスレジスタ
edi     宛先インデックスレジスタ（32ビットモードのみ）
di      宛先インデックスレジスタ
esp     スタックポインタレジスタ（32ビットモードのみ）
sp      スタックポインタレジスタ
ebp     ベースポインタレジスタ（32ビットモードのみ）
bp      ベースポインタレジスタ
cs      コードセグメントレジスタ
ds      データセグメントレジスタ
es      エクストラセグメントレジスタ
fs      セグメントレジスタ（32ビットモードのみ）
gs      セグメントレジスタ（32ビットモードのみ）
ss      スタックセグメントレジスタ
fl      フラグレジスタ
efl     フラグレジスタ（32ビットモードのみ）

fl.flg_bit_name　フラグレジスタ内の個々のビット

                    flg_bit_name ::="c"|"p"|"a"|"z"|"s"|"i"|"d"|"o"

efl.flg_bit_name　フラグレジスタ内の個々のビット

                    flg_bit_name ::="c"|"p"|"a"|"z"|"s"|"i"|"d"|"o"

            以下の表は、フラグレジスタの各ビットの完全な名前を表しています。

            fl.o、efl.o     オーバフローフラグ
            fl.d、efl.d     方向フラグ
            fl.i、efl.i     割込みフラグ
            fl.s、efl.s     符号フラグ
            fl.z、efl.z     ゼロフラグ
            fl.a、efl.a     補助キャリーフラグ
            fl.p、efl.p     パリティフラグ
            fl.c、efl.c     キャリーフラグ

st0 - st7   数値データプロセッサレジスタ（数値演算コプロセッサレジスタ）
cw          NDP制御ワード（数値演算コプロセッサ制御ワード）
cw.cw_bit_name　制御ワード内の個々のビット

                    cw_bit_name ::="ic"|"rc"|"pc"|"iem"|"pm"|
                                   "um"|"om"|"zm"|"dm"|"im"

            以下の表は、制御ワードの各ビットの完全な名前を表しています。

            cw.ic           無限大制御

                                0 = 射影
                                1 = アフィン

            cw.rc       丸め制御（２ビット）

                                00 = 近似値または偶数への丸め
                                01 = （負の無限大に近似する）切捨て
                                10 = （正の無限大に近似する）切上げ
                                11 = 切捨て（ゼロに近似する切捨て）

            cw.pc       精度制御（２ビット）

                                00 = 24ビット
                                01 = 予約済み
                                10 = 53ビット
                                11 = 64ビット

            cw.iem      割込みイネーブルマスク（8087のみ）

                                0 = 割込みのイネーブル
                                1 = 割込みのディスエーブル（マスク）

            cw.pm               精度（不正確な結果）マスク
            cw.um               アンダーフローマスク
            cw.om               オーバフローマスク
            cw.zm               ゼロ除算マスク
            cw.dm               非正規化オペランドマスク
            cw.im               無効なオペランドマスク

sw          NDP状態ワード（数値演算コプロセッサ状態ワード）
sw.sw_bit_name  状態ワード内の個々のビット

                    sw_bit_name ::= "b"|"c3"|"st"|"c2"|"c1"|
                                  "c0"|"es"|"sf"|"pe"|"ue"|
                                  "oe"|"ze"|"de"|"ie"

            以下の表は、状態ワードの各ビットの完全な名前を表しています。

            sw.b                使用中
            sw.c3               条件コードビット３
            sw.st               スタック停止ポインタ（３ビット）

                                000 = レジスタ０がスタックの一番上
                                001 = レジスタ１がスタックの一番上
                                002 = レジスタ２がスタックの一番上
                                　.
                                　.
                                　.
                                111 = レジスタ７がスタックの一番上

            sw.c2               条件コードビット２
            sw.c1               条件コードビット１
            sw.c0               条件コードビット０
            sw.es               エラー要約（287、387のみ）
            sw.sf               スタック異常（387のみ）
            sw.pe               精度（不正確な結果）例外
            sw.ue               アンダーフロー例外
            sw.oe               オーバフロー例外
            sw.ze               ゼロ除算例外
            sw.de               非正規化オペランド例外
            sw.ie               無効なオペランド例外

VIDEOでは、次章で説明するオペランドを使用してレジスタの内容を操作することが
できます。デフォルトでは、これらの既定義名は、ユーザまたはアプリケーションが
定義する他の変数と全く同じようにアクセスされます。アプリケーションが、これら
のデバッガ変数の名前と矛盾する名前を持つ変数を定義するような状況が生じる場合
には、モジュール指定子_dbgを使用して曖昧さをなくすことができます。たとえば、
アプリケーションがcsという名前の変数を定義する場合には、_dbg@csと指定するこ
とによって曖昧さをなくすことができます。"_dbg@"プレフィックスは、アプリケー
ション定義のシンボルではなく、VIDEO定義のシンボルを参照していることを示します。

フラグレジスタ、NDP制御ワード、およびNDP状態ワードは、一括して、またはその構
成要素の状態ビットごとにアクセスすることができます。

例：
        /fl.c=0
        /cw.um=0
        ?sw.oe

この例では、「キャリー」フラグはクリアされ、制御ワードのNDPアンダーフローマ
スクもクリアされ、状態ワードのNDPオーバフロー例外ビットが表示されます。

式の結果の下位ビットを使用して、指定したフラグを設定またはクリアします。

例：
        fl.c=0x03a6

この例では、結果の下位ビットが０なので「キャリー」フラグはクリアされます。

VIDEOは他の特殊な名前も定義しています。

dbg$32      このデバッガシンボルはプロセッサが動作しているモードを表します。

            0               16ビットモード
            1               32ビットモード

dbg$bottom  このデバッガシンボルは、ウィンドウに使用できる画面の最後の行番号
            を表します（dbg$top、dbg$left、dbg$rightも参照してください）。
dbg$bp      このデバッガシンボルはSS:BP（16ビットモード）またはSS:EBP（32
            ビットモード）のレジスタ対を表します。

            例：
                ? dbg$bp

dbg$code    このデバッガシンボルは検査中の現在のコード位置を表します。最後に
            コードとデータのどちらを見たかによって、ドットアドレス"."はそれ
            ぞれdbg$codeまたはdbg$dataに設定されます。

dbg$cpu     このデバッガシンボルは、ユーザのパーソナルコンピュータシステムに
            入っている中央処理装置のタイプを表します。

            0           Intel 8088と8086またはそれと互換性のあるプロセッサ
            1           Intel 80188と80186またはそれと互換性のあるプロセッサ
            2           Intel 80286またはそれと互換性のあるプロセッサ
            3           Intel 80386またはそれと互換性のあるプロセッサ
            4           Intel 80486またはそれと互換性のあるプロセッサ
            5           Intel Pentiumプロセッサ

dbg$ctid    このデバッガシンボルは現在の実行スレッドの識別番号を表します。
            DOSの下では、現在のスレッドIDは常に１です。Threadウィンドウまたは
            Threadコマンドを使用して現在の実行スレッドを選択できます。

dbg$data    このデバッガシンボルは検査中の現在のデータ位置を表します。最後に
            コードとデータのどちらを見たかによって、ドットアドレス"."はそれ
            ぞれdbg$codeまたはdbg$dataに設定されます。

dbg$etid    このデバッガシンボルは、デバッガに入ったときに実行中だったスレッ
            ドの識別番号を表します。DOSの下では、現在のスレッドIDは常に１です。

dbg$fpu     このデバッガシンボルは、ユーザのパーソナルコンピュータシステムに
            インストールされている数値データプロセッサ（数値演算コプロセッサ
            ）のタイプを表します。

            -1          80x87エミュレータをインストール
            0           コプロセッサはインストールされていない
            1           Intel 8087をインストール
            2           Intel 80287をインストール
            3           Intel 80387をインストール
            4           コプロセッサ命令をサポートするIntel 80486プロセッサ
                        をインストール
            5           コプロセッサ命令をサポートするIntel Pentiumプロセッサ
                        をインストール

dbg$ip      このデバッガシンボルはCS:IP（16ビットモード）またはCS:EIP（32
            ビットモード）のレジスタ対を表します。

            例：
                ? dbg$ip

dbg$left    このデバッガシンボルは、ウィンドウに使用できる画面の最初のカラム
            番号を表します（dbg$right、dbg$top、dbg$bottomも参照してください）。

dbg$monitor このデバッガシンボルは、使用されているモニタアダプタのタイプを表
            します。

            0           IBMモノクロアダプタ
            1           IBMカラーグラフィックスアダプタ（CGA）
            2           IBM拡張グラフィックスアダプタ（EGA）
            3           IBMビデオグラフィックスアレイ（VGA）

dbg$os      このデバッガシンボルは、現在アプリケーションを動作しているオペ
            レーティングシステムを表します。

            1           DOS
            2           OS/2
            3           Phar Lap Software,Inc.の386/DOS-Extender
            5           Novell,Inc.のNetWare 386
            7           Rational Systems,Inc.のDOS/4G
            8           Microsoft CorporationのMicrosoft Windows
            9           GO CorporationのPenPoint

dbg$pid     （OS/2、Netware 386のみ）このデバッガシンボルには、デバッグされ
            るプログラムのプロセス識別値が入っています。

dbg$psp     （DOSのみ）このデバッガシンボルには、デバッグされるプログラムの
            DOSの「プログラムセグメントプレフィックス」のセグメント値が入っ
            ています。

dbg$radix   このデバッガシンボルは現在のデフォルト数字基数を表します。

dbg$remote  "REMotefiles"オプションを指定した場合には、このデバッガシンボル
            は１です。そうでない場合には０です。

dbg$right   このデバッガシンボルは、ウィンドウに使用できる画面の最後のカラム
            番号を表します（dbg$left、dbg$top、dbg$bottomも参照してください）。

dbg$sp      このデバッガシンボルはSS:SP（16ビットモード）またはSS:ESP（32
            ビットモード）のレジスタ対を表します。

            例：
                ? dbg$sp

dbg$top     このデバッガシンボルは、ウィンドウに使用できる画面の最初の行番号
            を表します（dbg$left、dbg$right、dbg$bottomも参照してください）。

dbg$view    このデバッガシンボルは、Viewコマンドを用いて設定します。現在のア
            プリケーションのモジュールを見たときに最後にカーソルがあった位置
            の行に対応するコードのセグメントとオフセットを表します。この変数
            にはいくつかの用途があります。たとえば、Breakコマンドで使用して、
            ブレークポイントを設定することができます。

            例：
                break dbg$view
::::SYSTEM
+------------------------------------------------------------------------+
|　SYstem[/(Remote|Local)][system_cmd|"{"system_cmd"}"]                  |
|  !                                                                     |
+------------------------------------------------------------------------+

SYstem または！コマンドを使用して、デバッグ環境を壊さずに別のコマンドまたは
プログラムを実行することができます。system_cmdを入力すると、そのコマンドはオ
ペレーティングシステムによって実行され、制御はVIDEOに戻ります。

system_cmdを省略すると、オペレーティングシステムのコマンドインタプリタまたは
シェルが呼び出されます。"exit"コマンドを入力するまでコマンドを入力できます。
シェルが終了すると、制御はデバッガに戻ります。

リモートデバッグ機能を使用している場合には、/Remote修飾子および/Local修飾子
を指定できます。/Remote修飾子を指定すると、コマンドはタスクマシン上で実行さ
れます。/Local修飾子を指定すると、コマンドはデバッガマシン上で実行されます。
どちらの修飾子も指定しない場合には、コマンド行にRemotefileオプションを指定し
ていなければ、"local"と見なされます。リモートデバッグの詳細については、
「リモートデバッグ」の章を参照してください。

+------------------------------------------------------------------------+
|　注：　指定したプログラムやシェルを実行するにはコンピュータ上に十分な  |
|　未使用メモリがなければなりません。DOSの下では、デバッグ中のプログラム |
|　がメモリの一部を解放してシステムに戻し、system_comandをロードするため |
|　のメモリが確保されていなければなりません。DOSの場合には、"RESIZE"コマ |
|　ンドファイルを使用して、デバッグ中のプログラムのプログラムセグメント  |
|　プレフィックス（PSP）が入っているメモリ制御ブロックのサイズを変更する |
|　ことができます。このコマンドファイルの詳細については、「VIDEOコマンド |
|　ファイル」の章を参照してください。                                    |
|                                                                        |
|　VIDEOの"Checksize"オプションを使用することもできます。このオプション  |
|　の詳細については、「DOSでのデバッグ」の章を参照してください。         |
+------------------------------------------------------------------------+

例：
        DBG>system c:＼cmds＼cset.com

このDOSの例では、プログラム"CSET.COM"が"C"ディスクのディレクトリ"＼CMDS"から
呼び出されます。

例：
        DBG>system

コマンドシェルが呼び出されます。シェルは、"exit"コマンドが実行されるまで
デバッガに制御を戻しません。

例：
        DBG>sys　chdir ＼asmsrc

DOSの場合だけ、シェルが呼び出され、カレントディレクトリを"＼ASMSRC"に変更し
ます。制御はすぐにVIDEOに戻されます。

例：
        DBG>! edit hello.c

エディタを呼び出して、ファイル"hello.c"を編集します。"HELLO"プログラムを
デバッグしている間に、Ｃソースコードへの修正を行えます。エディタが終了すると、
制御はVIDEOに戻されます。

例：
        DBG>! edit fftc.for

エディタを呼び出して、ファイル"fftc.for"を編集します。"FFTC"プログラムを
デバッグしている間に、FORTRANソースコードへの修正を行えます。エディタが終了
すると制御はVIDEOに戻されます。
::::THREAD
+------------------------------------------------------------------------+
|  THread                                                                |
|  ~                                                                     |
|      /Change [id_num]                                                  |
|      /Freeze [id_num]|["*"]                                            |
|      /Show   [id_num]|["*"]                                            |
|      /Thaw   [id_num]|["*"]                                            |
+------------------------------------------------------------------------+

THreadコマンドまたは〜コマンドは、OS/2またはNetWare 386の下でマルチスレッド
アプリケーションの実行スレッドを操作するために使用します。VIDEOの検査対象と
なる実行スレッドを選択したり（/Change）、実行スレッドを実行不可能にしたり
（/Freeze）、実行スレッドを実行可能にしたり（/Thaw）、または実行スレッドの状
態を表示する（/Show）ことができます。

複数の実行スレッドを持つアプリケーションでは、Changeオプションを用いてスレッ
ド識別番号またはスレッドIDを指定して、検査対象となる特定のスレッドを選択でき
ます。

例：
        00001>thread/change 2

この例では、Changeオプションを使用して実行スレッド"2"を選択します。IDが"2"で
ある実行スレッドが存在する場合には、デバッガのプロンプトは"00002"に変更され
ます。画面上の他のウィンドウは、別の実行スレッドが選択されたことを反映するよ
うに変化します。特に、画面上のAssemblyウィンドウ、Sourceウィンドウ、FPUウィ
ンドウ、およびRegisterウィンドウは変化します。

スレッドIDだけを指定する場合には、Changeオプションはデフォルトなので、指定す
る必要はありません。

例：
        00001>thread 2

この例では、実行スレッド"2"を選択します。

Freezeオプションを用いてスレッドIDを指定して、特定のスレッドを「凍結」（すな
わち、実行不可能）にすることができます。

例：
        00002>thread/freeze 3

この例では、実行スレッド"3"が実行不可能になります。

スレッドIDに"*"を指定すると、すべてのスレッドを凍結することができます。

例：
        00002>~/f *

スレッドIDを省略すると、現在のスレッドを凍結できます。

例：
        00002>thread/freeze

Thawオプションを用いてスレッドIDを指定して、特定のスレッドを「凍結解除」（す
なわち、実行可能）にすることができます。

例：
        00002>thread/thaw 3

この例では、実行スレッド"3"が実行可能になります。

スレッドIDに"*"を指定すると、すべてのスレッドを凍結解除することができます。

例：
        00002>thread/thaw *

スレッドIDを省略すると、現在のスレッドを凍結解除できます。

例：
        00002>~/th

Showオプションを用いてスレッドIDを指定すると、特定のスレッドの状態を表示でき
ます。

例：
        00002>thread/show 1

この例では、実行スレッド"1"の状態が表示されます。

スレッドIDに"*"を指定すると、すべてのスレッドの状態を表示できます。

例：
        00002>th/sh *

また、引数を何も付けずにThreadコマンドを指定しても、すべてのスレッドの状態を
表示することができます。

例：
        00002>thread

Showオプションを指定してスレッドIDを省略すると、現在のスレッドの状態を表示で
きます。

例：
        00002>~/s
::::TRACE
+------------------------------------------------------------------------+
|  Trace                                                                 |
|      [/Assembly][/Over|/Into|/Next][start_addr_expr]                   |
|      [/Mix]     [/Over|/Into|/Next][start_addr_expr]                   |
|      [/Source]  [/Over|/Into|/Next][start_addr_expr]                   |
+------------------------------------------------------------------------+

Traceコマンドは、プログラムをステップ実行するのに使用します。実行を１度に１
ソース行ずつ表示したり（/Source）、１アセンブリ命令ずつ表示したり（/Assembly
）、またはソース行とアセンブリ行の両方を組み合わせて表示する（/Mix）ことがで
きます。この最後のモードは、ソース行が使用可能な場合にはソース行を表示し、
ソース行情報が使用可能でない場合にはアセンブリ命令に切り替わります。

ソース行情報が実行可能イメージに含まれている場合には、ソース行番号がSource
ウィンドウに表示されます（詳細については、コンパイラの"d1"オプションとWATCOM
リンカの"DEBUG"コマンドの説明を参照してください）。ソースファイルにアクセス
できる場合には、それに対応するソーステキストも表示されます。アプリケーション
のモジュールに対応するソースファイルをVIDEOがどのように見つけるかについては、
Set Sourceコマンドの説明を参照してください。

アセンブリ命令は、Assemblyウィンドウに表示されます。

ソース行情報が使用可能なときは、SourceウィンドウとAssemblyウィンドウは同期し
ます。

/Assembly[/Over|/Into|/Next][start_addr_expr]
            VIDEOは、１度に１つのアセンブリ命令ずつアプリケーションの実行を
            トレースします。

            例：
                DBG>trace /assembly

/Mix[/Over|/Into|/Next][start_addr_expr]
            VIDEOは、１度に１つのソース文ずつアプリケーションの実行をトレー
            スするか、またはソーステキストが使用できない場合には一度に１つの
            命令ずつトレースします。

            例：
                DBG>trace /mix

/Source[/Over|/Into|/Next][start_addr_expr]
            VIDEOは、１度に１つのソース文ずつアプリケーションの実行をトレー
            スします。このコマンドを発行するときは、ソース行情報が使用可能で
            なければなりません。

            例：
                DBG>trace /source

/Assembly、/Mix、/Sourceのどの修飾子も指定していない場合には、VIDEOはデフォ
ルトのトレースモードを使用します。デフォルトは初め/Mixになっていますが、Set
Levelコマンドで変更できます。

デフォルトではVIDEOは、SPACEバー、"I"キーまたは"N"キーのどれかを押すたびに、
１つのソース文またはアセンブリ命令が実行されるトレースモードになります。

SPACEバーで実行を進める場合には、被呼出しルーチンのトレーシングはスキップさ
れます。ルーチン呼出しの後にある文または命令からトレーシングが続行されます。

例：
    C Programming Example
           8 int main ()
           9   {
          10      printf( "Hello world＼n" );
          11          return( 0 );
          12   }

    FORTRAN Programming Example
           8       PROGRAM DEMO
           9           EXTERNAL PRINTF
          10           CALL PRINTF( 'Hello world' )
          11           END

この例では、"printf"文が実行されようとしているときにSPACEバーを押して、
"printf"ルーチンの実行のトレースをスキップしています。

"I"キーか"into"キーで実行を進める場合には、被呼出しルーチンの実行はトレース
されます。

例：
    main_       mov     AX,0002
    main_+03    push    AX
    main_+04    call    printf
    main_+07    add     SP,2
    main_+0A    xor     AX,AX

この例では、"main_+04"の"call"命令が実行されようとしているときに"I"キーを押
すと、"printf"ルーチンの実行をトレースできます。

"N"キーまたは"next"キーを使用すると、現在の文または命令の直後にある次のシー
ケンシャル文または命令にトレースを進めることができます。ループの最後にいる場
合には、このキーを使用すると、何回も繰り返される文や命令のトレースをスキップ
することができます。

例：
    _CSTART_+66     sub     SI,SI
    _CSTART_+68     cmp     BYTE PTR [SI],00
    _CSTART_+6B     movsb
    _CSTART_+6C    *jne     _CSTART_+68
    _CSTART_+6E     cmp     BYTE PTR [SI],00

この例では、"_CSTART_+6C"の"jne"命令が実行されようとしているときに"N"キーを
押して、"_CSTART_+68"から"_CSTART_+6C"までのループのトレースをスキップでき
ます。"jne"の前に付いている"*"は、"_CSTART_+68"への分岐が行われることを示し
ます。次にトレースされる命令は、"_CSTART_+6E"の"cmp"です。

"N"キーを使用する場合には、実行パスが次の文または命令に最終的に到達するよう
に注意しなければなりません。実行がその点に到達できない場合には、プログラムは
完了するまで実行を続けることがあります。この状況は、決して実行されない文やア
センブリ命令にブレークポイントを設定してからGoコマンドを発行した場合と似てい
ます。その場合、アプリケーションは完了するまで実行されます。

他のどれかのキーを押すと、トレースを中止できます。

/Over、/Into、および/Next修飾子を使用して、VIDEOが他のコマンドの入力を促す前
にある「次の」文または命令まで実行を続行できます。これは、一般に「シングルス
テップ」モードと呼ばれます。

/Over       この修飾子を使用すると、「次の」文またはアセンブリ命令まで実行を
            続行することができます。現在の文または命令がルーチンを呼び出す場
            合には、そのルーチンの呼出しの後にあるのが「次の」文または命令に
            なります。

/Into       この修飾子を使用すると、「次の」文またはアセンブリ命令まで実行を
            続行することができます。現在の文または命令がルーチンを呼び出す場
            合には、被呼出しルーチンの最初の文または命令が「次の」文または命
            令になります。

/Next       この修飾子を使用すると、メモリ内の現在の文または命令の直後にある
            「次の」文またはアセンブリ命令まで実行を続行することができます。
            現在の文または命令が分岐する場合には、実行パスがその後にある文ま
            たは命令に最終的に到達するように注意しなければなりません。実行が
            その点に到達できない場合は、プログラムは完了するまで実行を続ける
            ことがあります。
::::VIEW
+------------------------------------------------------------------------+
|  View[/Binary][module_or_file_spec]                                    |
+------------------------------------------------------------------------+

Viewコマンドは、単純なファイルブラウザーを呼び出します（すなわち、ファイルを
見るだけで、修正することはできません）。module_or_file_specを指定しない場合
には、現在のモジュール名と見なされます。

引数module_or_file_specは最初、モジュール名として扱われ、次にファイル名とし
て扱われます。デバッガは、ソース行をSourceウィンドウに表示するときと同じ方
法で、モジュールに対応するソースファイルを見つけようとします。VIDEOは、Set
Sourceコマンドで指定したデバイスとパスでファイルを探索します。

モジュール名とファイル名が一致していない場合には、ドライブ（DOS、MS Windows、
OS/2）、パス、またはファイル拡張子を指定して曖昧さをなくすことができます。た
とえば、"printf"という名前のデータファイルがあったと仮定します。view printf
コマンドを入力すると、VIDEOは"printf.c"というファイルを見つけ出そうとします。
一方、view printf.コマンドを入力すると、VIDEOはDOS、MS WindowsまたはOS/2の下
で"printf"というファイルを見つけ出そうとします。

/Binaryを指定した場合には、ファイル内容は16進表記法で表示されます。この修飾
子を使用する場合には、ファイル名を指定しなければなりません。

キーとマウスを用いたViewウィンドウの操作方法については、「VIDEOウィンドウ」
の章で説明してあります。
::::WATCH
+------------------------------------------------------------------------+
|  Watch                                                                 |
|      [/Set]  addr_expr[ cmd_list ]                                     |
|      /Byte   addr_expr[ cmd_list ]                                     |
|      /Word   addr_expr[ cmd_list ]                                     |
|      /DWord  addr_expr[ cmd_list ]                                     |
|      /Activate   "*"|index_expr|"/"addr_expr                           |
|      /Deactivate "*"|index_expr|"/"addr_expr                           |
|      /Clear      "*"|index_expr|"/"addr_expr                           |
+------------------------------------------------------------------------+

「ウォッチポイント」は、変更されるとアプリケーションの実行が中断されるメモリ
位置を定義します。以下のものに対してウォッチポイントを定義することができます。

/Byte   バイト（８ビット）

/Word   ワード（16ビット）

/DWord  ダブルワード（32ビット）

他の修飾子を指定していない場合には、/Setと見なされます。/Setを指定するか、ま
たは他の修飾子を何も指定しない場合には、16ビットアプリケーションまたは32ビッ
トアプリケーションのどちらをデバッグしているかによって、それぞれワードまたは
ダブルワードにウォッチポイントが設定されます。ウォッチポイントは、/Clear修飾
子を用いて削除することができます。ウォッチポイントは/Activate修飾子によって
イネーブルし、/Deactivate修飾子によってディスエーブルすることができます。最
大の７個のウォッチポイントを定義できます。命令が、アクティブな監視点で保護さ
れている位置を変更すると、アプリケーションの実行は中断され、デバッガに入ります。

例：
        DBG>watch/set _listhead
        DBG>watch _listhead

上の例では、２つの等価なコマンドが示されています。グローバルシンボル_listhead
で定義された16ビットメモリ位置にウォッチポイントが定義され、自動的にイネーブ
ルになります。メモリ内の特定の位置にはウォッチポイントを１つしか指定できません。

ウォッチポイントはモジュール名とシンボル名で指定することができます。

例：
        DBG>watch sort@_listhead

実行中のアプリケーションがアクティブなウォッチポイントによって保護されたメモ
リ位置を変更すると、アプリケーションの実行が中断され、デバッガに入ります。
ウォッチポイントをを定義したときに１つまたは複数のデバッガコマンドを指定した
場合には、最初にそのデバッガコマンドが実行されます。/Set、/Byte、/Word、また
は/DWord修飾子でアドレス式の後にあるコマンド並びは、次のように定義されます。

        cmd_list ::="{"[cmd]{";"[cmd]}"}"

これは、単にVIDEOコマンド行を中括弧の中に入れただけです。

注：

    1.  有効なアドレス式の詳細については、「VIDEO式の処理」の章を参照してく
        ださい。

    2.  コマンドの中にGoコマンドがある場合には、アプリケーションの実行を再開
        することができます。そうでない場合には、デバッガはユーザに新しいコマ
        ンドの入力を促します。

        例：
            DBG>watch _listhead {if _listhead != 0 {go/keep}}

        "listhead"変数が変更されるたびに、その値はゼロと比較され、それがゼロ
        でない場合だけ実行が再開されます。

    3.  "Watch"コマンドに対して引数を指定していない場合には、現在定義されて
        いるウォッチポイントが表示されます。最初に表示されるのはウォッチポイ
        ント番号１、２番目に表示されるのはウォッチポイント番号２というように
        表示されます。これらはウォッチポイント・インデックスと呼ばれます。ア
        クティブなウォッチポイントは"active"属性で、アクティブでないウォッチ
        ポイントは"plain"属性で表示されます。属性については、Paintコマンドの
        説明を参照してください。

    4.  ウォッチポイントを使用可能、使用不可、またはクリアする場合は、ウォッ
        チポイント・インデックスまたはウォッチポイント・アドレスを指定しなけ
        ればなりません。監視点インデックスとして"*"を指定した場合には、
        全ウォッチポイントが影響を受けます。

        例：
            DBG>watch/set _listhead; watch/deac 1
            DBG>watch/set _listhead; watch/deac /_listhead

        どちらの例とも、ウォッチポイントを設定してから、使用不可にします。最
        初のの例では、_listheadに設定されるウォッチポイント以外にウォッチポ
        イントが設定されていない場合だけ（これがウォッチポイント番号１になる
        ので）、このウォッチポイントが使用不可になります。２番目の例は、どの
        ような状況でも_listheadのウォッチポイントを使用不可にする方法を示して
        います。

        例：
            DBG>watch/activate 2; watch/deactivate 1

        ウォッチポイント番号２が使用可能となり、ウォッチポイント番号１が使用
        不可となります。

    5.  指定するアドレスはシンボル名にする必要はありません。

        例：
            DBG>watch/byte es:di

        ES:DIレジスタ対の内容で指定される８ビット位置にウォッチポイントが設
        定されます。

        例：
            DBG>watch/deactivate /bx

        アドレスがDS:BXレジスタ対の内容で指定されるウォッチポイントを使用不
        可にします。

    6.  １つのコマンドで全ウォッチポイントを削除できます。

        例：
            DBG>watch/clear *

        アスタリスクは全ウォッチポイントを参照します。
::::WHILE
+------------------------------------------------------------------------+
|  WHile <expr> cmd_list                                                 |
+------------------------------------------------------------------------+

WHileコマンドは、指定された式が真である（すなわち、評価するとゼロ以外の結果
になる）場合にコマンドリストの実行を許可します。このコマンドの後に続くコマン
ド並びは、次のように定義されます。

        cmd_list ::="{"[cmd]{";"[cmd]}"}"

例：
        DBG>/ax=0; while ax!=25 {/ax++;print ax}

この例では、１から25までの数字をDialogueウィンドウに表示します。まずAXレジス
タを0に設定します。AXレジスタの内容が25と等しくない間は、デバッガはAXレジス
タの値をインクリメントし、その新しい値を表示します。

もっと複雑なシナリオでも、WHileコマンドを利用することができます。たとえば、
このコマンドを使用して、NULLポインタで終了するリンクされたリストを追うことが
できます。
::::WIN3_STARTUP
Microsoft Windows 3.xの下で動作するアプリケーションをデバッグする方法は、い
くつかあります。

    1. Windows 3.xの下で動作するアプリケーションをデバッグするために、
        Windows 3.xの下でVIDEOを走らせることができます。
    2. ２台目のコンピュータを使って、VIDEOの「リモート・デバッグ」機能を使う
        ことができます。
    3. WIN-OS/2と仮想DOSマシン(VDM)リンクを使うOS/2の下で、16ビットWindowsア
        プリケーションをデバッグすることもできます。

この章では、最初のトピックス、つまり、１台のDOSベースのコンピュータを使って、
MS Windowsの下で、Windowsアプリケーションをデバッグすることを扱います。残り
の２つの方法については、21ページの「Windowsアプリケーションのリモートデバッ
グ」の章を参照してください。

Windows 3.x版のVIDEOのインストール
----------------------------------
VIDEOを使用するために、Microsoft Windows 3.xをエンハンストモードで起動しなけ
ればなりません。32ビットアプリケーションをデバッグするときは、Windows 3.xの
「SYSTEM.INI」ファイルの[386enh]セクションに、下の行の"device"指定に、入れな
ければなりません。

        DEVICE=[d:]\WATCOM\BINW\WDEBUG.386

このデバイスドライバは16ビットと32ビットアプリケーションの両方をサポートし
ます。

パスにWindows 3.x SDKのファイル「TOOLHELP.DLL」を指定しなければなりません。
このファイルは、WATCOMソフトウェアパッケージに、入っています。

以下の手順で、現在、選択されているプログラムグループにVIDEOをインストールで
きます。また、VIDEOのための新しいプログラムグループを作ることもできます。
Windows 3.xバージョンのVIDEOをインストールするには、Windowsの「プログラム
マネージャ」の「アイコン(File)」メニューの「登録とグループの作成(New)」項目
を選択します。次に、「アイコン登録(Program Item)」を選択します。「アイコンの
登録内容の変更(Properties)」ウィンドウの「タイトル(Description)」フィールドに、
名前「VIDEO」を入力します。「コマンドライン(Command Line)」フィールドに、
WINDEO.EXEの完全パス名を入力します。「アイコンの登録内容の変更(Properties)」
ウィンドウの「タイトル(Description)」フィールドと「コマンドライン(Command
Line)」フィールドのサンプル入力を下の図に示します。
+--ﾎ------------------------------------------------------------+
|−|                  Program Item Properties                   |
ｾ--ﾖ------------------------------------------------------------ﾆ
|                  +----------------------++--------------+  |
|Description:      |VIDEO                 ||      OK      |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Command Line:     |ATCOM\BINW\WVIDEO.EXE ||    Cancel    |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Working Directory:|                      ||    Browse... |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Shortcut Key:     |                      ||Change Icon...|  |
|                  +----------------------++--------------+  |
|                  ++                      +--------------+  |
|                  ++Run Minimized         |     Help     |  |
|                                            +--------------+  |
+----------------------------------------------------------------+
図1. VIDEOのグループへの追加

VIDEOの稲妻アイコンが現在選択されているプログラムグループに現れます。

Windows 3.xアプリケーションのデバッグ
-------------------------------------
VIDEOを起動するには、VIDEOをインストールしたプログラムグループを選択します。
そして、VIDEOのアイコンをダブルクリックします。

アプリケーションを起動するのに使われるコマンドラインを入力するために、
"Prompt"ウィンドウが現れます。

Windowsのプログラムマネージャの「アイコン(File)」メニューの「コピー(Copy)」
と「登録内容の変更(Properties)」項目を使用して、特別版のVIDEOアイコンを作る
こともできます。例えば、「アイコンの登録内容の変更(Properties)」ウィンドウの
「コマンドライン(Command Line)」フィールドに望みのオプションを指定しておくこ
とができます。「アイコンの登録内容の変更(Properties)」ウィンドウの「タイトル
(Description)」フィールドと「コマンドライン(Command Line)」フィールドの入力
例をしたに、示します。
+--ﾎ------------------------------------------------------------+
|−|                  Program Item Properties                   |
ｾ--ﾖ------------------------------------------------------------ﾆ
|                  +----------------------++--------------+  |
|Description:      |VIDEO/Custom          ||      OK      |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Command Line:     |BINW\WVIDEO.EXE /reg=4||    Cancel    |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Working Directory:|E:\WATCOM\BINW        ||    Browse... |  |
|                  +----------------------++--------------+  |
|                  +----------------------++--------------+  |
|Shortcut Key:     |None                  ||Change Icon...|  |
|                  +----------------------++--------------+  |
|                  ++                      +--------------+  |
|                  ++Run Minimized         |     Help     |  |
|                                            +--------------+  |
+----------------------------------------------------------------+
図2. VIDEOのオプションのカスタマイズ

新しく作られたアイコンをクリックすると、「コマンドライン(Command Line)」
フィールドで指定されたオプションがデフォルトとして、とられます。実行可能ファ
イル名が「コマンドライン(Command Line)」フィールドで指定されない限り、VIDEO
はプロンプトウィンドウを表示します。プロンプトウィンドウで、追加のオプション
と、実行可能ファイル名を指定できます。

繰り返し同じプログラムをデバッグする場合には、「コマンドライン(Command Line)
」フィールドにデバッグしたいファイル名を入れたアイコンを作ることができます。
アイコンをダブルクリックする度に、VIDEOは自動的にデバッグしたいプログラムを
ロードします。
::::WIN3_WVIDEOW_ENVIRONMENT_VARIABLE
環境変数WVIDEOWに、いつも使用するオプションを指定しておくことができます。
環境変数はDOS版とは異なる名前ですので、VIDEOに対して、DOS版とは異なるオプ
ションを指定しておくことができます。オプションの指定で、"="文字を含む場合に
は、代わりに"#"文字を使用します。(これは、SETコマンドの文法の仕様上の制限の
ために、必要な処置です。)これらのオプションは、コマンドラインで指定されたオ
プションより前に、処理されます。

例：
        C>set wvideow=/fastswap/vga50/reg#4

上は、デバッガのデフォルトオプションを定義する方法を説明する例です。

一度、環境変数WVIDEOWが定義されると、これらのオプションはVIDEOが起動される度
に、デフォルトとして、扱われます。
::::WINDOWS
ウィンドウの種類
----------------
ウィンドウは、ソース行、機械言語命令、およびレジスタ内容などの、特定のデバッ
グ情報を表示するために使用される、画面上の矩形の領域です。画面上にすべての
ウィンドウを置く必要はありません。ウィンドウを画面上に置くには、VIDEOのDispl
ayコマンドを使用します。このコマンドを使用して、画面からウィンドウを削除する
ことができます。ウィンドウに表示される行の属性は、VIDEOのPaintコマンドを用い
て定義します。

上の画面には、Sourceウィンドウ、Dialogueウィンドウ、およびPromptウィンドウだ
けが示されています。一番上の行はメニュー行です。いろいろな種類のウィンドウに
ついて本章の後半で説明します。

キーを用いたウィンドウ操作
--------------------------
テキストカーソルがあるウィンドウを「アクティブ」ウィンドウと呼びます。これは
キー入力に応答するウィンドウです。一般に、Cursor UpキーやCursor Downキーのよ
うなキーはすべてのウィンドウで同じような機能を実行します。以下のキーはどの
ウィンドウでもまったく同じ機能を実行します。

Ctrl/Enter  テキスト選択プロセスを開始するために使用します。テキスト選択プロ
            セスはActionウィンドウが現れて終了します。テキスト選択が開始され
            ると、画面上にブロックカーソルが現れます。カーソルキーを使用して、
            ブロックカーソルを上下左右に伸ばし、画面上の見えているテキスト部
            分をハイライト表示させることができます。Ctrl/Cursor Leftキーおよ
            びCtrl/Cursor Rightキーは、ブロックカーソルを１度に１トークンだ
            け広げます。Ctrl/Enterキーをもう１度押すと、Actionウィンドウが画
            面からポップアップされます。

以下のキーは、ViewウィンドウとErrorウィンドウを除き、すべてのウィンドウで同
じ機能を実行します。

Tab         テキストカーソルを画面上の隣のウィンドウへ移動するのに使用します。

Shift/Tab   （Backtab）テキストカーソルを画面上の前のウィンドウへ移動するの
            に使用します。

Escape      Promptウィンドウへ直接移動するのに使用します。

Ctrl/D      アクティブウィンドウ全体を画面の下方向へ移動するのに使用します。

Ctrl/U      アクティブウィンドウ全体を画面の上方向へ移動するのに使用します。

Ctrl/P      アクティブウィンドウに対してPaintメニューを起動するのに使用します。

Ctrl/Q      アクティブウィンドウの内容を更新するのに使用します。

以下のキーは、Prompt、View、およびErrorウィンドウを除き、すべてのウィンドウ
で同じ機能を実行します。

Ctrl/L      アクティブウィンドウを左へ移動するのに使用します。

Ctrl/R      アクティブウィンドウを右へ移動するのに使用します。

Ctrl/G      アクティブウィンドウのサイズを拡大するのに使用します。

Ctrl/S      アクティブウィンドウのサイズを縮小するのに使用します。

Ctrl/N      アクティブウィンドウの幅を狭くするのに使用します。

Ctrl/W      アクティブウィンドウの幅を広くするのに使用します。

Ctrl/E      アクティブウィンドウをディスプレイから消去するのに使用します。

Ctrl/Z      通常のサイズから画面全体のサイズまで、アクティブウィンドウを拡大
            ／縮小するのに使用します。

以下の項では、特定のウィンドウがアクティブなときの、いろいろなキーに対する応
答について詳しく説明します。


マウスを用いたウィンドウ操作
----------------------------
VIDEOでマウスを使用するには、マウスドライバプログラムをインストールしなけれ
ばなりません。

DOSの下では、IBM Mouseに添付されたIBM Mouse Driverプログラムをインストールし
なければなりません。または、IBM MouseおよびIBM Mouse Driverと互換性のあるマ
ウスとマウスドライバも使用できます。IBM Mouse Driverは、"MOUSE.COM"プログラ
ムを実行してインストールします。

例：
        C>＼dos＼mouse

VIDEOは様々な方法でマウスの使用をサポートしています。大部分の処理は、希望す
る位置でマウスをクリックして選択されます。これを行うには、マウスカーソル（画
面上の実線の矩形）を画面上のある場所へ移動して、マウスの左ボタンを押します。

マウスカーソルはどのウィンドウにでも置くことができます。"Source"ウインドウや
"Assembly"ウィンドウのようなウィンドウでは、マウスをドラッグして、テキストを
上下左右にスクロールすることができます。これを行うには、マウスカーソルをウィ
ンドウのある行に移動し、マウスの左ボタンを押し下げたまま、マウスカーソルを
ウィンドウの別の場所に置きます。

マウスをドラッグしてテキストを上下にスクロールするには、垂直スクロールをイ
ネーブルしなければなりません。これを行うには、ウィンドウ右側のスクロールバー
上でマウスをクリックします。すると、スクロールバーに"Locked"という語が現れま
す。この語が現れない場合には、垂直スクロールはすでにイネーブルされています。
スクロールバー上でもう１度クリックすると、垂直スクロールをイネーブル／ディス
エーブルすることができます。

マウスをドラッグしてテキストを左右にスクロールするには、水平スクロールを
イネーブルしなければなりません。これを行うには、ウィンドウの最下部のスクロー
ルバー上でマウスをクリックします。"Locked"という語が現れます。現れない場合に
は、水平スクロールはすでにイネーブルされています。スクロールバー上でもう１度
クリックすると、水平スクロールをイネーブル／ディスエーブルすることができます。

ウィンドウのタイトル行を画面上の新しい場所にドラッグして、ウィンドウ全体を画
面上で移動することができます。

処理の中には、左マウスボタンを「ダブルクリック」して実行するものがあります。
「ダブルクリック」は、マウスカーソルを移動せずに左マウスボタンを素早く２度ク
リックして行います。「ダブルクリック」によって実行される処理については後の項
で説明します。

テキスト選択は、右マウスボタンを押して開始することができます。そのボタンを押
したままにして、マウスカーソルを画面上で移動すると、一連のテキスト（文字、
ワード、式など）をハイライト表示することができます。右マウスボタンを離すと、
画面上にActionウィンドウが現れます。右マウスボタンを押したまま、マウスを動か
さなければ、マウスカーソルの下の「項目」がそのまま選択され、画面上にAction
ウィンドウが現れます。

マウスを使う場合、多くのウィンドウには「仕掛け」が用意されています。

    1.　「スクロールアップ」（↑）および「スクロールダウン」（↓）の仕掛けを
        使用して、テキストを垂直方向にスクロールすることができます。

    2.　「スクロールレフト」（←）および「スクロールライト」（→）の仕掛けを
        使用して、テキストを水平方向にスクロールすることができます。

    3.　「ページアップ」および「ページダウン」の仕掛け（ウィンドウ右側の小さ
        な三角形）は、ウィンドウごとに異なる処理を行います。

    4.　「ページレフト」および「ページライト」の仕掛け（ウィンドウ最下部の小
        さな三角形）は、ウィンドウごとに異なる処理を行います。

    5.　「ウィンドウズーム」の仕掛け（ウィンドウの最上部の右隅にある花火状の
        記号）を使用して、アクティブウィンドウを通常のサイズから画面全体の大
        きさまでに拡大／縮小することができます。

        マウスカーソルを「ズーム」の仕掛けの上に置いて、右マウスボタンを押す
        と、ウィンドウは一時的にフルサイズに拡大されます。ボタンを離すと、
        ウィンドウは元のサイズに戻ります。

    6.　「ウィンドウサイズ変更」の仕掛け（最下部右隅の２重矢印）を使用して、
        ウィンドウを拡大または縮小することができます。

    7.　「ウインドウクローズ」の仕掛け（最上部左隅の３本のバー）を使用して、
        ウィンドウを画面から削除することができます。

「スクロール」の仕掛けまたは「ページ」の仕掛けをクリックすると、それに対応す
る処理が１回実行されます。マウスカーソルをこれらの仕掛けの上に置き、左マウス
ボタン押し下げたままにすると、対応する処理が繰返し実行されます。「ウィンドウ
サイズ変更」の仕掛けをドラッグすると、その仕掛けのあるウィンドウが拡大／縮小
されます。

タイトルバーをダブルクリックすると、ウィンドウの内容が更新されます。

Ａｃｔｉｏｎウィンドウ
----------------------
テキスト選択シーケンスが完了すると、デバッガはこのウィンドウを画面上に表示し
ます。キーボードを使用する場合には、Ctrl/Enterキーを使ってテキスト選択を開始
します。もう１度Ctrl/Enterキーを押すと、Actionウィンドウが画面に現れます。

マウスを使用する場合には、右マウスボタンを押すとテキスト選択が開始されます。
右マウスボタンを離すと、Actionウィンドウが画面に現れます。

Actionウィンドウのエントリによって、以下のことを実行することができます。

    1.　選択したテキストに属するソースコードを表示する。
    2.  選択したテキストが表す変数の内容を表示する。
    3.  選択したテキストを式として評価する。
    4.  選択したテキストが表すメモリ位置を調べる。
    5.  選択したテキストが表すメモリ位置にブレークポイントを設定する。
    6.  選択したテキストが表すメモリ位置にウォッチポイントを設定する。
    7.  選択したテキストをPromptウィンドウにコピーして、コマンドの一部として
        処理できるようにする。

"Show source"エントリを選択すると、選択したテキストに対応するソース／アセン
ブラコードがSourceウィンドウおよびAssemblyウィンドウ（これらが画面上にあれば
）に表示されます。

検査中の前のソース／アセンブラコードと新しいソース／アセンブラコードのアドレ
スを示す行が、Dialogueウィンドウに表示されます。

例：
        0x65CB:0x0012 => ClearScreen

このエントリを使用して前の位置に戻ることができます。それには、Tabキーを使っ
てテキストカーソルをDialogueウィンドウに移動し、Ctrl/Enterキーとカーソルキー
を使って"=>"の左側に表示されているアドレスをハイライト表示します。右マウスボ
タンを押して、"=>"の左側に表示されているアドレスをハイライト表示してから右マ
ウスボタンを離しても、同じことができます。上の例の場合、これは0x65CB:0x0012
（検査中の前の位置のセグメントおよびオフセット）です。


Ａｓｓｅｍｂｌｙウィンドウ
--------------------------

デバッガは、現在のコード位置に対するアセンブラ命令をこのウィンドウに表示しま
す。コードセグメントレジスタおよび命令ポインタレジスタ（CS:IP、CS:EIP）が
Assemblyウィンドウに表示されている命令を指している場合には、その命令が入って
いる行は"active"属性で表示されます。アセンブラ命令を検査している場合には、１
つの行が現在行として指定され、"standout"属性で表示されます。ソース情報が使用
可能な場合には、Sourceウィンドウが画面上にあれば、Assemblyウィンドウと同期し
ます。

キーを使用したＡｓｓｅｍｂｌｙウィンドウの操作
----------------------------------------------
テキストカーソルがAssemblyウィンドウにある場合には、Cursor Left/Rightキー、
Cursor Up/Downキー、Homeキー、Endキー、およびEnterキーを使って移動することが
できます。

Cursor Left/Right
            カーソルがウィンドウの右端または左端へ移動したときにウィンドウ内
            のテキストを左右にスクロールさせるのに使用します。

Ctrl/Cursor Left/Right
            カーソルを動かさずにウィンドウ内のテキストを左右にスクロールさせ
            るのに使用します。

Cursor Up/Down
            アセンブラ命令を上下にスクロールするのに使用します。

Page Up/Down
            ウィンドウの行数より２行少ない行数だけ、アセンブラ命令を上下にス
            クロールするのに使用します。

Home　
            現在のコンパイル単位の先頭へ移動するのに使用します。

End
            現在のモジュール（コンパイル単位）の終わりへ移動するのに使用
            します。

Enter
            CS:IP（16ビットモード）またはCS:EIP（32ビットモード）レジスタ対
            によって参照されるアセンブラ命令に直接移動するのに使用します。


マウスを使用したＡｓｓｅｍｂｌｙウィンドウの操作
------------------------------------------------
1.　Assebmlyウィンドウをクリックすると、テキストカーソルはこのウィンドウに移
    動し、このウィンドウは「アクティブ」ウィンドウになります。

2.  アセンブラ命令は、マウスをドラッグして上下にスクロールすることができます。
    これを行うには、右側のスクロールバーのロックを解除しておかなければなりま
    せん。

3.  アセンブラ命令は、マウスをドラッグして左右にスクロールすることができます。
    これを行うには、最下部のスクロールバーのロックを解除しておかなければなり
    ません。

4.　Assemblyウィンドウのスクロール、サイズ変更、ズーム、およびクローズのため
    の仕掛けが用意されています。

5.　「スクロールアップ」および「スクロールダウン」の仕掛けを使用して、テキス
    ト行を上下に移動することができます。テキストカーソルがウィンドウの最上部
    または最下部に移動すると、テキストはそれぞれ下または上にスクロールされます。
6.　「スクロールレフト」および「スクロールライト」の仕掛けはカーソルを１字左
    右に移動します。テキストカーソルがウィンドウの左端または右端に移動すると、
    テキストはそれぞれ右または左にスクロールされます。

7.　「ページアップ」および「ページダウン」の仕掛けを使用して、ウィンドウ行数
    より２行少ない行数だけ、アセンブラ命令を上下にスクロールすることができます。
8.　Assemblyウィンドウのアセンブラ命令をクリックすると、その命令が現在のアセ
    ンブラ命令になります。この行は"standout"属性で表示されます。VIDEO変数dbg
    $codeの値は現在のアセンブラ命令の変更を反映するように変化します。この変
    数は検査される最も近い時点のコード位置のセグメント：オフセットを表します。
    さらに、"."アドレスは、このアセンブラ命令を指すように変更されます。"."ア
    ドレスは多くのVIDEOコマンドで使用されています。

    例：
        do [CS IP] = .
            または
        do [CS EIP] = .

    この例では、CS:IPレジスタ対またはCS:EIPレジスタ対の内容は、現在のアセン
    ブラ命令を指すように変更されます。

9.　行をダブルクリックすると、そのアセンブリ命令にブレークポイントが設定され
    るか、または設定済みのブレークポイントがクリアされます。

Ｃｏｍｍａｎｄウィンドウ
------------------------
１つまたは複数のコマンドからの出力をこのウィンドウに表示できます。上の図では、
Commandウィンドウには"date/time structure"というタイトルが付けられています。


キーを使用したＣｏｍｍａｎｄウィンドウの操作
--------------------------------------------
テキストカーソルがCommandウィンドウにある場合には、Enterキーを使用してウィン
ドウをリフレッシュすることができます。


マウスを使用したＣｏｍｍａｎｄウィンドウの操作
----------------------------------------------
Commandウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動し、
ウィンドウはリフレッシュされます。ウィンドウは「アクティブ」ウィンドウになり
ます。


Ｄｉａｌｏｇｕｅウィンドウ
--------------------------
デフォルトでは、デバッガはコマンドへの応答をこのウィンドウに表示します。他の
ウィンドウの１つが画面にない場合には、通常そのウィンドウに送られる出力は
Dialogueウィンドウに表示されます。


キーを使用したＤｉａｌｏｇｕｅウィンドウの操作
----------------------------------------------
テキストカーソルがDialogueウィンドウにある場合には、Cursor Up/Downキー、Page
UP/Downキー、Homeキー、Endキー、およびEnterキーを使って移動することができます。

Cursor Left/Right
            カーソルがウィンドウの右端または左端へ移動したときにウィンドウ内
            のテキストを左右にスクロールさせるのに使用します。

Ctrl/Cursor Left/Right
            カーソルを動かさずにウィンドウ内のテキストを左右にスクロールさせ
            るのに使用します。

Cursor Up/Down
            Dialogueウィンドウ出力を１度に１行ずつ上下にスクロールするのに使
            用します。

Page Up/Down
            ウィンドウの行数より２行少ない行数だけ、Dialogueウィンドウ出力を
            上下にスクロールするのに使用します。

Home　      Dialogueウィンドウ出力の先頭へ移動するのに使用します。

End         Dialogueウィンドウ出力の終わりへ移動するのに使用します。

Enter       Dialogueウィンドウ出力の終わりへ移動するのに使用します。

テキストカーソルがPromptウィンドウにある場合には、Page UPキー、Page Downキー、
Ctrl/Page Upキー、およびCtrl/Page Downキーを使ってDialogueウィンドウをスク
ロールすることができます。

Page Up/Down
            Dialogueウィンドウ出力を１度に１行ずつ上下にスクロールするのに使
            用します。

Ctrl/Page UpおよびCtrl/Page Down
            ウィンドウの行数より２行少ない行数だけ、Dialogueウィンドウ出力を
            上下にスクロールするのに使用します。


マウスを使用したＤｉａｌｏｇｕｅウィンドウの操作
------------------------------------------------
1.　Dialogueウィンドウをクリックすると、テキストカーソルはこのウィンドウに移
    動し、このウィンドウは「アクティブ」ウィンドウになります。

2.  テキストは、マウスをドラッグして上下にスクロールすることができます。これ
    を行うには、右側のスクロールバーのロックを解除しておかなければなりません。

3.  テキストは、マウスをドラッグして左右にスクロールすることができます。これ
    を行うには、最下部のスクロールバーのロックを解除しておかなければなりま
    せん。

4.　Dialogueウィンドウのスクロール、サイズ変更、およびズームのための仕掛けが
    用意されています。

5.　「スクロールアップ」および「スクロールダウン」の仕掛けを使用して、テキス
    ト行を上下に移動することができます。テキストカーソルがウィンドウの最上部
    または最    下部に移動すると、テキストはそれぞれ下または上にスクロールさ
    れます。

6.　「スクロールレフト」および「スクロールライト」の仕掛けはカーソルを１字左
    右に移動します。テキストカーソルがウィンドウの左端または右端に移動すると、
    テキストはそれぞれ右または左にスクロールされます。

7.　「ページアップ」および「ページダウン」の仕掛けを使用して、ウィンドウ行数
    より２行少ない行数だけ、Dialogueウィンドウ出力を上下にスクロールすること
    ができます。


ＦＰＵウィンドウ
----------------
80x87数値データプロセッサ（数値演算コプロセッサ）レジスタと状態フラグの内容
が、このウィンドウに表示されます。FPUウィンドウがアクティブな場合には、現在
選択されている項目は"active"属性で表示されます。デバッガに最後に入ったときか
らレジスタの内容が変更された場合には、"standout"属性で表示されます。


キーを使用したＦＰＵウィンドウの操作
------------------------------------
テキストカーソルがFPUウィンドウにある場合には、カーソルキーとEnterキーを使用
して、レジスタ（ST(0)、ST(1)など）またはフラグ表示に移動して、レジスタやフラ
グの内容を変更することができます。Homeキー、Endキー、Page Upキー、およびPage
Downキーを使用して、レジスタセットを表示することができます。レジスタセットの
詳細については、
Registerコマンドの説明を参照してください。

Cursor Up、Down、Left、およびRight
            テキストカーソルをレジスタ／フラグ内容表示に移動するのに使用し
            ます。

Enter       レジスタ内容を変更するのに使用します。テキストカーソルをレジスタ
            に置いてEnterキーを押した場合には、レジスタ変更ウィンドウが画面
            上に現れ、新しい値を入力できます。新しい値に対するプロンプトへの
            応答としてEnterキーを押しただけでは、レジスタは変更されません。

            テキストカーソルをフラグに置いてEnterキーを押した場合には、その
            値の補数がとられます。

Home　      最も古いレジスタセットに移動するのに使用します。

End         最も新しいレジスタセットに移動するのに使用します。

Page Up     レジスタセットを最も古いレジスタセットの方へ逆方向に移動するのに
            使用します。

Page Down   レジスタセットを最も新しいレジスタセットの方へ順方向に移動するの
            に使用します。

Insert      ２進表示フォーマットと10進表示フォーマットを切り替えるのに使用し
            ます。


マウスを使用したＦＰＵウィンドウの操作
--------------------------------------
1.　FPUウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動し
    て、このウィンドウは「アクティブ」ウィンドウになります。テキストカーソル
    は、レジスタ内容表示またはフラグビット表示に移動することができます。

2.　レジスタ表示（ST(0)、ST(1)など）をクリックすると、レジスタ変更ウィンドウ
    が画面上に現れます。新しい値を入力するか、またはプロンプトへの応答として
    Enterキーだけを押してレジスタをそのままにしておくことができます。

    フラグをダブルクリックすると、その値の補数がとられます。

3.　「スクロールアップ」の仕掛けを使用すると、レジスタセットを最も古いレジス
    タセットの方へ逆方向に移動することができます。

4.　「スクロールダウン」の仕掛けを使用すると、レジスタセットを最も新しいレジ
    スタセットの方へ順方向に移動することができます。

5.　「ページアップ」の仕掛けを使用すると、レジスタセットを最も古いレジスタ
    セットの方へ逆方向に移動することができます。

6.　「ページダウン」の仕掛けを使用すると、レジスタセットを最も新しいレジスタ
    セットの方へ順方向に移動することができます。


Ｍｅｍｏｒｙウィンドウ
----------------------
メモリの一部がこのウィンドウに表示されます。Memoryウィンドウがアクティブな場
合には、現在選択されたメモリ位置は"active"属性で表示されます。Memoryウィンド
ウの「ホットスポット」（たとえば、BYTE）は"standout"属性で表示されます。その
他の項目はすべて"plain"属性で表示されます。


キーを使用したＭｅｍｏｒｙウィンドウの操作
------------------------------------------
テキストカーソルがMemoryウィンドウにある場合には、カーソルキー、Homeキー、
Page Upキー、Page Downキー、およびEnterキーを使用して、メモリエントリに移動
して、エントリの内容を変更することができます。

Cursor Up、Down、Left、およびRight
            テキストカーソルをそれぞれのメモリ位置に移動するのに使用します。

Insert      メモリ位置の表示方法を変更するのに使用します。Insertキーを押す度
            に、表示は８ビットバイト、16ビットワード、32ビットダブルワードと
            順に変更されます。８ビットバイトが表示されている場合には、それの
            ASCIIコードもウィンドウの右側に表示されます。

Delete      表示する新しいメモリ位置を選択するのに使用します。新しいメモリ位
            置に対するPromptウィンドウが現れます。

Home　      表示するよう要求されたメモリの元の位置に直接移動するのに使用しま
            す。

Page Up/Down
            ウィンドウ行数より２行少ない行数だけ、Memoryウィンドウを上下にス
            クロールするのに使用します。

Enter       テキストカーソルが置かれたメモリ位置の内容を変更するのに使用しま
            す。Enterキーを押すと、メモリ変更ウィンドウが画面上に現れ、新し
            い値を入力できます。新しい値に対するプロンプトへの応答として
            Enterキーを押しただけでは、エントリは変更されません。メモリの表
            示方法によって、バイト、ワード、またはダブルワードを入力すること
            ができます。


マウスを使用したＭｅｍｏｒｙウィンドウの操作
--------------------------------------------
1.　Memoryウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動
    して、このウィンドウは「アクティブ」ウィンドウになります。テキストカーソ
    ルは、ウィンドウに表示された任意のメモリエントリに移動することができます。

2.  メモリエントリは、マウスをドラッグして上下にスクロールすることができます。
    これを行うには、右側のスクロールバーのロックを解除しておかなければなりま
    せん。

3.　「スクロールアップ」と「スクロールダウン」の仕掛けを使用すると、メモリを
    上下にスクロールすることができます。

4.　「ページアップ」と「ページダウン」の仕掛けを使用すると、ウィンドウ行数よ
    り２行少ない行数だけ、メモリを上下にスクロールすることができます。

5.　"(ins)"エントリをクリックすると、表示は８ビットバイト、16ビットワード、
    32ビットダブルワードと順に変更されます。８ビットバイトが表示されている場
    合には、それのASCIIコードもウィンドウの右側に表示されます。

6.　"(Del)"エントリをクリックすると、表示する新しいメモリ位置を選択すること
    ができます。新しいメモリ位置に対するPromptウィンドウが現れます。新しい値
    を入力するか、またはプロンプトへの応答としてEnterキーだけを押してメモリ
    アドレスをそのままにしておくことができます。

7.　"HOME"エントリをクリックすると、表示するよう要求されたメモリの元の位置に
    直接移動することができます。

8.　メモリ位置をダブルクリックすると、メモリ変更ウィンドウが画面上に現れます。
    新しい値を入力するか、またはプロンプトへの応答としてEnterキーだけを押し
    てメモリ位置をそのままにしておくことができます。


Ｐｒｏｍｐｔウィンドウ
----------------------
デバッガコマンド入力プロンプト"DBG>"が、高さ１行のウィンドウに表示されます。
Promptウィンドウを使用して、コマンド行を入力します。

複数実行スレッドアプリケーションでは、"DBG>"プロンプトの代わりに現在のスレッ
ドを示すプロンプトが表示されます。プロンプトの形式は"ddddd>"で、ここで
"ddddd"はスレッド識別番号です。

例：
        00002>


キーを使用したＰｒｏｍｐｔウィンドウの操作
------------------------------------------
"DBG>"入力プロンプトにVIDEOコマンドを入力します。

        DBG>

複数実行スレッドアプリケーションでは、"DBG>"プロンプトの代わりに現在のスレッ
ドを示すプロンプトが表示されます。プロンプトの形式は"ddddd>"で、ここで
"ddddd"はスレッド識別番号です。

例：
        00002>

テキストカーソルがPromptウィンドウにある場合には、カーソルキー、Homeキー、
Endキー、Instキー、Delキー、Backspaceキー、およびEnterキーを使用して、コマン
ドを再呼出し、編集、または入力することができます。

Cursor Up/Down
            前に入力したコマンドをスクロールするのに使用します。

Cursor Left/Right
            コマンド行を変更するために、カーソルをコマンド行の左右に移動する
            のに使用します。

Ctrl/Cursor LeftおよびRight
            カーソルを１度に１ワードずつ左右に移動するのに使用します。

Home　      カーソルをコマンド行の先頭に移動するのに使用します。

End         カーソルをコマンド行の終わりに移動するのに使用します。

Insert      文字挿入モードと上書きモードを切り替えるのに使用します。

Delete      カーソル上の文字を削除するのに使用します。

Backspace   （またはRubout）カーソルの左の文字を削除するのに使用します。

Enter       コマンドを入力するのに使用します。

Ctrl/F      部分的に入力したシンボル名を終了するのに使用します。Ctrl/Fキーを
            もう１度押すと、最初のシーケンスが同じ、次のシンボル名を見つけ
            ます。

Ctrl/B      Ctrl/Fキーで見つけられた前のシンボル名に戻るのに使用します。

画面の幅を超えるコマンド行を入力できます。カーソルの位置と方向によって、コマ
ンド行は左または右にスクロールします。

テキストカーソルがPromptウィンドウにある場合には、Page UPキー、Page Downキー、
Ctrl/Page Upキー、およびCtrl/Page Downキーを使ってDialogueウィンドウをスク
ロールすることができます（前述のDialogueウィンドウの操作に関する項を参照して
ください）。


マウスを使用したＰｒｏｍｐｔウィンドウの操作
--------------------------------------------
Promptウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動し
ます。このウィンドウは「アクティブ」ウィンドウになり、VIDEOコマンドを入力す
ることができます。


Ｒｅｇｉｓｔｅｒウィンドウ
--------------------------
16ビットモードでは、8086レジスタの現在の内容がRegisterウィンドウに表示され
ます。

32ビットモードでは、32ビットレジスタの現在の内容がRegisterウィンドウに表示さ
れます。

Registerウィンドウがアクティブな場合には、現在選択されている項目は"active"属
性で表示されます。デバッガに最後に入力してからレジスタの内容が変更された場合
には、"standout"属性で表示されます。ただし、命令ポインタ（IP、EIP）レジスタ
だけは、分岐命令や呼出し命令が実行された場合だけ"standout"属性で表示されます。

レジスタセット０以外のレジスタセットが表示される場合には、レジスタセット番号
は"active"属性を用いて大括弧に入れて（たとえば、[1]）表示されます（Register
コマンドの説明を参照してください）。


キーを使用したＲｅｇｉｓｔｅｒウィンドウの操作
----------------------------------------------
テキストカーソルがRegisterウィンドウにある場合には、カーソルキーとEnterキー
を使用して、レジスタ表示に移動して、レジスタの内容を変更することができます。
Homeキー、Endキー、Page Upキー、およびPage Downキーを使用して、レジスタセッ
トを表示することができます。レジスタセットの詳細については、Registerコマンド
の説明を参照してください。

Cursor Up、Down、Left、およびRight
            テキストカーソルをレジスタ／フラグ内容表示に移動するのに使用し
            ます。

Enter       レジスタ内容を変更するのに使用します。テキストカーソルをレジスタ
            に置いてEnterキーを押した場合には、レジスタ変更ウィンドウが画面
            上に現れ、新しい値を入力できます。新しい値に対するプロンプトへの
            応答としてEnterキーを押しただけでは、レジスタは変更されません。

            テキストカーソルをフラグに置いてEnterキーを押した場合には、その
            値の補数がとられます。

Home　      最も古いレジスタセットに移動するのに使用します。

End         最も新しいレジスタセットに移動するのに使用します。

Page Up     レジスタセットを最も古いレジスタセットの方へ逆方向に移動するのに
            使用します。

Page Down   レジスタセットを最も新しいレジスタセットの方へ順方向に移動するの
            に使用します。


マウスを使用したＲｅｇｉｓｔｅｒウィンドウの操作
------------------------------------------------
1.　Registerウィンドウをクリックすると、テキストカーソルはこのウィンドウに移
    動して、このウィンドウは「アクティブ」ウィンドウになります。テキストカー
    ソルは、レジスタ内容表示またはフラグビット表示に移動することができます。

2.　レジスタ表示をダブルクリックすると、レジスタ変更ウィンドウが画面上に現れ
    ます。新しい値を入力するか、またはプロンプトへの応答としてEnterキーだけ
    を押してレジスタをそのままにしておくことができます。

    フラグをダブルクリックすると、その値の補数がとられます。

3.　「スクロールアップ」の仕掛けを使用すると、レジスタセットを最も古いレジス
    タセットの方へ逆方向に移動することができます。

4.　「スクロールダウン」の仕掛けを使用すると、レジスタセットを最も新しいレジ
    スタセットの方へ順方向に移動することができます。

5.　「ページアップ」の仕掛けを使用すると、レジスタセットを最も古いレジスタ
    セットの方へ逆方向に移動することができます（「スクロールアップ」と同じ
    です）。

6.　「ページダウン」の仕掛けを使用すると、レジスタセットを最も新しいレジスタ
    セットの方へ順方向に移動することができます（「スクロールダウン」と同じ
    です）。


Ｓｏｕｒｃｅウィンドウ
----------------------
現在のコード位置に対するプログラムソースコード情報が利用できる場合には、その
情報はこのウィンドウに表示されます。コードセグメントレジスタおよび命令ポイン
タレジスタ（CS:IP、CS:EIP）がSourceウィンドウに表示されている命令を指してい
る場合には、その行は"active"属性で表示されます。ソースコードを検査している場
合には、１つの行が現在行として指定され、"standout"属性で表示されます。Assemb
lyウィンドウがある場合には、AssemblyウィンドウはSourceウィンドウと同期します。


キーを使用したＳｏｕｒｃｅウィンドウの操作
------------------------------------------
テキストカーソルがSourceウィンドウにある場合には、Cursor Up/Downキー、Page
Up/Downキー、Homeキー、Endキー、およびEnterキーを使って移動することができま
す。

Cursor Left/Right
            カーソルがウィンドウの右端または左端へ移動したときにウィンドウ内
            のテキストを左右にスクロールさせるのに使用します。

Ctrl/Cursor Left/Right
            カーソルを動かさずにウィンドウ内のテキストを左右にスクロールさせ
            るのに使用します。

Cursor Up/Down
            ソース行を上下にスクロールするのに使用します。

Page Up/Down
            ウィンドウの行数より２行少ない行数だけ、ソース行を上下にスクロー
            ルするのに使用します。

Home        現在のモジュール（コンパイル単位）の先頭へ移動するのに使用します。

End         現在のモジュール（コンパイル単位）の終わりへ移動するのに使用し
            ます。

Enter       CS:IP（16ビットモード）またはCS:EIP（32ビットモード）レジスタ対
            によって参照されるソース行に直接移動するのに使用します。


マウスを使用したＳｏｕｒｃｅウィンドウの操作
--------------------------------------------
1.　Sourceウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動
    し、このウィンドウは「アクティブ」ウィンドウになります。

2.  ソース行は、マウスをドラッグして上下にスクロールすることができます。これ
    を行うには、右側のスクロールバーのロックを解除しておかなければなりません。

3.  ソース行は、マウスをドラッグして左右にスクロールすることができます。これ
    を行うには、最下部のスクロールバーのロックを解除しておかなければなりま
    せん。

4.　Sourceウィンドウのスクロール、サイズ変更、ズーム、およびクローズのための
    仕掛けが用意されています。

5.　「スクロールアップ」および「スクロールダウン」の仕掛けを使用して、テキス
    ト行を上下に移動することができます。テキストカーソルがウィンドウの最上部
    または最下部に移動すると、テキストはそれぞれ下または上にスクロールされます。

6.　「スクロールレフト」および「スクロールライト」の仕掛けはカーソルを１字左
    右に移動します。テキストカーソルがウィンドウの左端または右端に移動すると、
    テキストはそれぞれ右または左にスクロールされます。

7.　「ページアップ」および「ページダウン」の仕掛けを使用して、ウィンドウ行数
    より２行少ない行数だけ、ソース行を上下にスクロールすることができます。

8.　Sourceウィンドウのソース行をクリックすると、その行が現在行になります。
    この行は"standout"属性で表示されます。VIDEO変数dbg$codeの値は現在行の変
    更を反映するように変化します。この変数は、検査される最も近い時点のコード
    位置のセグメント：オフセットを表します。さらに、"."アドレスは、このソー
    ス行に対する最初のアセンブラ命令を指すように変更されます。（行や宣言行の
    ように）ソース行に対するアセンブラ命令がない場合には、アセンブラ命令を持
    つモジュールの前にある行（または最初の行）に位置付けられます。"."アドレ
    スは多くのVIDEOコマンドで使用されています。

    例：
        do [CS IP] = .
            または
        do [CS EIP] = .

    この例では、CS:IPレジスタ対またはCS:EIPレジスタ対の内容は、現在のソース
    行を指すように変更されます。

9.　行をダブルクリックすると、そのソース行に対する最初のアセンブリ命令に
    ブレークポイントが設定されるか、または設定済みのブレークポイントがクリア
    されます。


Ｓｔａｃｋウィンドウ
--------------------
実行スタックの一部がこのウィンドウに表示されます。ベースポインタ（BP、EBP）
レジスタが、スタック上の表示されているバイト、ワード、またはダブルワードを指
している場合には、その項目は"standout"属性で表示されます。Stackウィンドウが
アクティブな場合には、現在選択されたスタック位置は"active"属性で表示されます。
その他の項目はすべて"plain"属性で表示されます。


キーを使用したＳｔａｃｋウィンドウの操作
----------------------------------------
テキストカーソルがStackウィンドウにある場合には、カーソルキー、Homeキー、End
キー、Page Upキー、Page Downキー、およびEnterキーを使用して、スタックエント
リに移動して、エントリの内容を変更することができます。

Cursor Up、Down、Left、およびRight
            テキストカーソルをそれぞれのスタックエントリに移動するのに使用し
            ます。

Insert      スタックエントリの表示方法を変更するのに使用します。Insertキーを
            押すたびに、表示は８ビットバイト、16ビットワード、32ビットダブル
            ワードと順に変更されます。８ビットバイトが表示されている場合には、
            それのASCIIコードもウィンドウの右側に表示されます。

Home　      SS:SP（16ビットバイト）またはSS:ESP（32ビットバイト）によって参
            照されるスタックエントリに直接移動するのに使用します。

End         SS:SP（16ビットバイト）またはSS:ESP（32ビットバイト）によって参
            照されるスタックエントリに直接移動するのに使用します。

Page Up/Down
            ウィンドウ行数より２行少ない行数だけ、スタックを上下にスクロール
            するのに使用します。

Enter       テキストカーソルが置かれたスタックエントリの内容を変更するのに使
            用します。Enterキーを押すと、スタック変更ウィンドウが画面上に現
            れ、新しい値を入力できます。新しい値に対するプロンプトへの応答と
            してEnterキーを押しただけでは、エントリは変更されません。


マウスを使用したＳｔａｃｋウィンドウの操作
------------------------------------------
1.　Stackウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動
    して、このウィンドウは「アクティブ」ウィンドウになります。テキストカーソ
    ルは任意のスタックエントリに移動することができます。

2.  スタックエントリは、マウスをドラッグして上下にスクロールすることができま
    す。これを行うには、右側のスクロールバーのロックを解除しておかなければな
    りません。

3.　「スクロールアップ」と「スクロールダウン」の仕掛けを使用すると、スタック
    を上下にスクロールすることができます。

4.　「ページアップ」と「ページダウン」の仕掛けを使用すると、ウィンドウ行数よ
    り２行少ない行数だけ、スタックを上下にスクロールすることができます。

5.　"(Ins)"エントリをクリックすると、表示は８ビットバイト、16ビットワード、
    32ビットダブルワードと順に変更されます。８ビットバイトが表示されている場
    合には、それのASCIIコードもウィンドウの右側に表示されます。

6.　"HOME"エントリをクリックすると、SS:SP（16ビットバイト）またはSS:ESP（32
    ビットバイト）によって参照されるスタックエントリに直接移動することができ
    ます。

8.　スタックエントリをダブルクリックすると、スタック変更ウィンドウが画面上に
    現れます。新しい値を入力するか、またはプロンプトへの応答としてEnterキー
    だけを押してスタックエントリをそのままにしておくことができます。


Ｔｈｒｅａｄウィンドウ
----------------------
Threadウィンドウを使用して、すべてのプログラム実行スレッドの識別番号、状態、
および関連する追加情報を表示します。デバッガに入ると、現在実行中のスレッドは
"active"属性で表示されます。新しいスレッドエントリを選択すると、それは"acti
ve"属性で表示されます。

Threadウィンドウの各エントリにはいくつかのフィールドがあります。最初のフィー
ルドはスレッド識別番号またはスレッドIDです。２番目のフィールドは、"runnable"
または"frozen"のスレッド状態です。NetWareの下では、３番目のフィールドにはNet
Ware 386サーバタスクだけに使用可能なスレッド名が入っています。現在選択されて
いるフィールドは"standout"属性で表示されます。他の項目はすべて"plain"属性で
表示されます。

DOSの下では、実行スレッドは１つしかないので、Threadウィンドウにはエントリは
１つしかありません。OS/2とNetWare 386の下では、実行スレッドが複数になること
があるので、Threadウィンドウに複数のエントリがある場合があります。


キーを使用したＴｈｒｅａｄウィンドウの操作
------------------------------------------
テキストカーソルがThreadウィンドウにある場合には、カーソルキー、Page Upキー、
Page Downキー、およびEnterキーを使用して、スレッドエントリに移動して、エント
リの内容を変更することができます。

Cursor Up、Down、Left、およびRight
            テキストカーソルをスレッドフィールドに移動するのに使用します。

Page Up/Down
            ウィンドウ行数より２行少ない行数だけ、Threadウィンドウを上下にス
            クロールするのに使用します。

Enter       テキストカーソルが置かれたスレッドフィールドの内容を変更するのに
            使用します。"id"フィールドでEnterキーを押すと、選択されたスレッ
            ドが現在のスレッドになります。画面上の他のウィンドウは、別の実行
            スレッドが選択されたことを反映するにように変化します。

            "state"フィールドでEnterキーを押すと、選択されたスレッドの状態は
            "frozen"または"runnable"に変更されます。


マウスを使用したＴｈｒｅａｄウィンドウの操作
--------------------------------------------
1.　Threadウィンドウをクリックすると、テキストカーソルはこのウィンドウに移動
    して、このウィンドウは「アクティブ」ウィンドウになります。テキストカーソ
    ルは任意のスレッドエントリに移動することができます。

2.　「スクロールアップ」と「スクロールダウン」の仕掛けを使用すると、スレッド
    エントリを上下にスクロールすることができます。

3.　「ページアップ」と「ページダウン」の仕掛けを使用すると、ウィンドウ行数よ
    り２行少ない行数だけ、スレッドエントリを上下にスクロールすることができ
    ます。

4.　スレッドの"id"エントリをダブルクリックすると、そのスレッドが現在のスレッ
    ドになります。画面上の他のウィンドウは、別の実行スレッドが選択されたこと
    を反映するにように変化します。

    "state"フィールドをダブルクリックすると、そのスレッドの状態は"frozen"ま
    たは"runnable"になります。


Ｖａｒｉａｂｌｅウィンドウ
--------------------------
このウィンドウはPrint/Windowコマンドによって作成されます。デバッガはPrintコ
マンドからの出力をこのウィンドウに表示します。デバッガに入るたび、またはVID
EOコマンドを実行するたびにウィンドウは更新されます。上の図では、Variableウィ
ンドウには"Variable Display"のタイトルが付けられています。


キーを使用したＶａｒｉａｂｌｅウィンドウの操作
----------------------------------------------
テキストカーソルがVariableウィンドウにある場合には、Cursor Up/Downキー、Ent
erキー、Backspaceキー、および"S"キーを使用することができます。

Cursor Up/Down
            構造体のフィールドの上下に移動するのに使用します。構造体を表すエ
            ントリは"{...}"を使用して表示されます。配列を表す構造体は"(...)"
            を使用して表示されます。

Page Up/Down
            ウィンドウ行数だけ、Variableウィンドウを上下にスクロールするのに
            使用します。

Enter       フィールドの内容を表示するのに使用できます。

Backspace   前のレベルに戻るのに使用できます。

"S"         エントリを文字列として表示するのに使用できます。Backspaceキーを
            使用すると、元の表示フォーマットに戻ることができます。


マウスを使用したＶａｒｉａｂｌｅウィンドウの操作
------------------------------------------------
1.　Variableウィンドウをクリックすると、テキストカーソルはこのウィンドウに移
    動して、このウィンドウは「アクティブ」ウィンドウになります。

2.　フィールドをクリックすることによって、フィールドを選択して見ることができ
    ます。

3.　ウィンドウの破線をクリックすると、前のレベルに上がります。

4.　「スクロールアップ」および「スクロールダウン」の仕掛けを使用して、構造体
    のフィールドを上下に移動することができます。構造体を表すエントリは"{...}"
    を使用して表示されます。配列を表す構造体は"(...)"を使用して表示されます。

5.　「ページアップ」および「ページダウン」の仕掛けを使用して、ウィンドウ行数
    だけ、Variableウィンドウを上下にスクロールすることができます。

6.　「ページアップ」と「ページダウン」の仕掛けを使用すると、ウィンドウ行数だ
    け、Variableウィンドウを上下にスクロールすることができます。


Ｖｉｅｗウィンドウ
------------------
このウィンドウはHelpコマンドとViewコマンドによって作成されます。Viewウィンド
ウは、アクティブの場合には表示領域全体を占めます。コマンドが完了すると、View
ウィンドウは削除され、他のウィンドウが再び表示されます。


キーを使用したＶｉｅｗウィンドウの操作
--------------------------------------
テキストカーソルがViewウィンドウにある場合には、カーソルキー、Page Up/Down
キー、Homeキー、Endキー、およびEnterキーを使用して移動することができます。/、
?、'、および"キーを使用して、テキストを探索することができます。

Cursor Up/Down
            テキスト行を上下に移動するのに使用します。テキストカーソルがウィ
            ンドウの最上部または最下部に移動すると、テキスト行はスクロールし
            ます。

Cursor Left/Right
            カーソルを１字左右に移動します。カーソルがウィンドウの左端または
            右端に移動すると、テキストカーソルは右または左にスクロールされ
            ます。

Ctrl/Cursor Left/Right
            カーソルを動かさずに、ウィンドウ内のテキストを左右にスクロールす
            るのに使用します。

Page Up/Down
            ウィンドウ行数より２行少ない行数だけ、ソース行を上下にスクロール
            するのに使用します。

Home        見ているテキストの最初の行に移動するのに使用します。

Ctrl/Home   （Helpウィンドウのみ）主ヘルプインデックスに戻るのに使用します。

End         見ているテキストの最終行に移動するのに使用します。

Enter       テキストの次の行の先頭にテキストカーソルを移動するのに使用します。

            （Helpウィンドウのみ）テキストカーソルをウィンドウのワードの上に
            置いてEnterキーを押すと、VIDEOはその名前のトピックを探します。

"/"         テキスト文字列を順方向に探索するのに使用します。探索する文字列に
            対するプロンプトが表示されます。Cursor Upキーを使用して、前の探
            索文字列を入力することができます。

"?"         テキスト文字列を逆方向に探索するのに使用します。探索する文字列に
            対するプロンプトが表示されます。Cursor Upキーを使用して、前の探
            索文字列を入力することができます。

"'"         （アポストロフィ）前に指定した探索文字列を順方向に探索するのに使
            用します。

"           （引用符）前に指定した探索文字列を逆方向に探索するのに使用します。

"."         （ピリオド）最後の処理を繰り返すのに使用します。

Escape      ビュー関数を終了するのに使用します。

"0"から"9"
            数字を入力するのに使用します。この数字は、次の処理を指定された回
            数繰り返すのに使用します。たとえば、数字20を入力した後にCursor
            Downキーを押すと、１行ではなく、カーソルを20行下に移動します。
            HomeキーとEndキーの場合には、それぞれファイルの先頭または最後か
            ら"number"行のところに移動します。コマンドを実行せずに数字を取り
            消すには、Deleteキーを押してください。

探索キーの１つを押すと、探索文字列に対するプロンプトが現れます。前に文字列を
入力した場合には、Cursor Upキーを使用してその文字列を再び呼び出すことができ
ます。呼び出された文字列はプロンプト領域に表示されます。ここでEscapeキーを押
すと、探索コマンドは取り消されます。Cursor Left/RightキーとHome、End、Delete、
およびBackspaceキーを使用して、探索文字列を編集することができます。探索文字
列を入力した後にEnterキーを押すと、探索が開始されます。探索は大文字と小文字
を区別せずに行われ、ファイルはテキストのリングと見なされます（たとえば、順方
向に探索して、ファイルの終わりに達してもテキストが見つからない場合には、ファ
イルの先頭から探索が続けられます）。文字列が見つかると、カーソルは最初に一致
した文字の下に置かれ、一致した文字列がハイライト表示されます。


マウスを使用したＶｉｅｗウィンドウの操作
----------------------------------------
1.　Viewウィンドウをクリックすると、テキストカーソルはマウスカーソルに移動し
    ます。

2.　（Helpウィンドウのみ）テキストカーソルをウィンドウのワードの上に置いて、
    マウスをダブルクリックすると、VIDEOはその名前のトピックを探します。タイ
    トル行をダブルクリックすると、VIDEOは主ヘルプインデックスに戻ります。

3.　テキスト行は、マウスをドラッグして上下にスクロールすることができます。
    これを行うには、右側のスクロールバーのロックを解除しておかなければなりま
    せん。

4.　テキスト行は、マウスをドラッグして左右にスクロールすることができます。
    これを行うには、最下部のスクロールバーのロックを解除しておかなければなり
    ません。

5.　Viewウィンドウをスクロールおよびクローズするための仕掛けが用意されてい
    ます。

6.　「スクロールアップ」および「スクロールダウン」の仕掛けを使用して、テキス
    ト行を上下に移動することができます。テキストカーソルがウィンドウの最上部
    または最下部に移動すると、テキストは下または上にスクロールされます。

7.　「スクロールレフト」および「スクロールライト」の仕掛けを使用して、１字左
    右にスクロールすることができます。テキストカーソルがウィンドウの左端また
    は右端に移動すると、テキストはそれぞれ右または左にスクロールされます。

8.　「ページアップ」および「ページダウン」の仕掛けを使用して、ウィンドウ行数
    より２行少ない行数だけ、ソース行を上下にスクロールすることができます。


Ｅｒｒｏｒウィンドウ
--------------------
前の節で説明したウィンドウの他に、VIDEOがエラーメッセージを表示したい場合に
は、「エラー」ウィンドウが画面の中央に現れます。どれかキーを押すと、このウィ
ンドウは消えます。
::::WINNT_INTERRUPTING_A_PROGRAM
プログラムがVIDEOによってロードされると、その実行は、Goコマンドによって始ま
ります。(このコマンドは、「VIDEOコマンド」の章で説明されています。)

例：
        C>wvideo myapp
        .
        .
        .
        DBG>go

開発フェーズ中には、ときどき、プログラムが止まらなくなるときがあるかもしれま
せん。

Windows NTの下では、アプリケーションの実行には、VIDEOセッションのCtrl/Break
キーの組み合わせで、割り込めます。

VIDEOは、「ダイアログ」ウィンドウに、プログラムの実行が割り込まれたことを示
すメッセージを表示します。実行は、Goコマンドで再開できます。

また、VIDEOコマンドの実行には、VIDEOセッションでのCtrl/Breakキーの組み合わせ
を押すことによって、割り込めます。
::::WINNT_STARTUP
+------------------------------------------------------------------------+
|WVIDEO[options] [:sym_file] file_spec [cmd_line]                        |
+------------------------------------------------------------------------+
角括弧は、任意指定の項目であることを表します。

WVIDEO      VIDEOのプログラム名です。
options     VIDEOのオプションです。それぞれ、前にダッシュ("-")またはスラッ
            シュ("/")をつけて指定します。オプションの順序は任意です。
sym_file    任意指定のシンボルデバッグ情報ファイルを指定します。ファイル名の
            前には、コロン(:)を付けます。OS/2では、sym_fileの形式は、以下の
            通りです。

        [d:][path]filename[.ext]

        シンボルファイルのデフォルトの拡張子は、".SYM"です。

        シンボリック情報ファイルは、WATCOMリンカーWLINKまたはWATCOMストリッ
        プユーティリティWSTRIPによって作られます。

file_spec   メモリにロードされるファイルの名前です。OS/2では、file_specの形
            式は以下の通りです。

        [d:][path]filename[.ext]

        d:      "A:"、"B:"などのような任意指定のドライブ指定です。指定されな
                ければ、デフォルトドライブが仮定されます。

        path    "\UTIL\BIN"のような任意指定のパス名です。

        filename
                メモリにロードされるファイルのファイル名です。

        ext     メモリにロードされるファイルの拡張子です。ピリオド"."が指定
                されると、拡張子はつきません。拡張しを指定しないと、(つまり、
                拡張子とピリオドの両方が省略されると、)デフォルトは、".EXE"
                です。

cmd_line    アプリケーションに渡される任意指定のコマンドラインです。

ドライブ名とパス名の両方が省略されると、VIDEOは、まず、デフォルトドライブの
カレントディレクトリのファイルを探します。そこになければ、VIDEOは環境変数
PATHに指定されているそれぞれのパスでファイルを探します。

コマンドラインオプション
------------------------
+------------------------------------------------------------------------+
|/Dynamic=space                                                          |
|/NOFpu                                                                  |
|/Invoke=file_spec                                                       |
|/NOAltsym                                                               |
|/NOInvoke                                                               |
|/NOMouse                                                                |
|/Registers=number                                                       |
|/NOSymbols                                                              |
|/TRap=trap_file[;trap_parm]                                             |
+------------------------------------------------------------------------+

オプションはどの順序で指定してもかまいません。オプションは短縮形でも指定でき、
上の表の中で、大文字で書かれている部分になります。"space"に後ろに"K"が付けば、
"space"は1Kバイト(1024バイト)単位になります。"space"の後ろに"K"が付かず、
"space"が1000より小さい数である場合には、"space"には1Kバイト(1024バイト)が掛
けられます。そのほかの場合には、バイト単位です。

/Dynamic=space  VIDEOが、ウィンドウやユーザー定義シンボルなどのために予約す
                る動的メモリの初期量を指定します。設定されるデフォルトの量は、
                40960バイト(40Kバイト)です。追加のメモリが必要になる度に、
                VIDEOはメモリを割り付けます。

/NOFpu          デバッガは数値演算コプロセッサの存在を無視します。デバッガは、
                数値データプロセッサの状態を保存するためのメモリを割り付けま
                せん。アプリケーションが数値演算コプロセッサを使用せず、デバッ
                ガが使用するメモリを減らしたいときには、このオプションを指定
                してください。

/Invoke=file_spec
                起動時に自動的に実行するデバッガコマンドファイルの別名を指定
                するのに使います。デフォルトのファイル名は、"PROFILE.DBG"で
                す。VIDEOコマンドファイルは、カレントディレクトリか、
                Windows NT環境文字列PATHで指定されているディレクトリで、探さ
                れます。

/NOAltsym       CV4(CodeView)のサブセットのサポートや、NE(OS/2 1.x、Windows
                3.x)実行可能モジュールとPE(Windows NT)実行可能モジュールから
                のイクスポートテーブルの処理のような別形式にシンボル情報フォ
                ーマットのデバッガサポートを禁止します。このオプションは、デ
                バッガの起動時の実行可能モジュールのロードと処理の時間を短縮
                します。

/NOInvoke       デフォルトのデバッガコマンドファイルを実行しません。

/NOMouse        デバッガは接続されているマウスを無視します。

/Registers=number
                レジスタの内容を記憶するレジスタセットを幾つにするかを指定し
                ます。デフォルトのレジスタセットの数は、2組です。詳しくはReg
                isterコマンドの説明を参照ください。(このコマンドは「VIDEOコ
                マンド」の章で説明されています。)

/NOSymbols      実行可能イメージをロードするとき、VIDEOはすべてのデバッグ情
                報を省略します。グローバルおよびローカルシンボル名、データ型、
                行番号に関する情報は、処理されません。

/TRap=trap_file[;trap_parm]
                ダイナミックリンクライブラリ(DLL)を使用するアプリケーション
                のためにダイナミックリンクライブラリのスタートアップコードを
                デバッグするときに、原則的に使用されます。trap_parmに"DLL"を
                指定すると、すべてのDLLがロードされた後で、かつ、実行される
                前にブレイクポイントが設定されます。これによって、DLLのスタ
                ートアップコードの中にブレイクポイントを設定することがきます。

                例：
                        C>wvideo /trp=std;dll calendar

                このオプションを指定しないと、デフォルトトラップファイルは
                "STD.DLL"がカレントディレクトリか、環境変数PATHに指定されて
                いるディレクトリからロードされます。BINNTディレクトリには、
                VIDEOとともに提供されているトラップファイルがあります。
                トラップファイルは、Windows NTを実行するローカルコンピュータ
                上でデバッグをサポートするインターフェースモジュールです。

                TRapオプションを使用するとき、トラップファイルのパス名を指定
                することもできます。(トラップファイルが検索パスのディレクト
                リにないときには、必ずパス名を指定しなければなりません。)
                ファイル拡張子のデフォルトは、".DLL"です。
::::WINNT_WVIDEO_ENVIRONMENT_VARIABLE
WVIDEO環境変数は、いつも使用するVIDEOオプションを指定するのに使用できます。
オプションの形式で、"="文字を使用する必要がある時には、代わりに"#"文字を使用
できます。(これは、"SET"コマンドの文法から必要とされます。)これらのオプショ
ンは、コマンドライン上のオプションの前に処理されます。

例：
        C>set wvideo=/reg#4

上の例は、デバッガのデフォルトオプションの定義の仕方を示しています。

WVIDEO環境変数が一度定義されると、これらのオプションは、VIDEOが起動される度
に、デフォルトとなって働きます。
::::WIRING
シリアルポート配線上の注意事項
------------------------------
シリアルポート・デバッグサーバ"SERSERV"の使用を予定している場合には、２つの
コンピュータシステムのシリアルポートをケーブルで接続しなければなりません。下
の図は、２つのシリアルポート間の配線を表しています。ユーザのコンピュータシス
テムに２つ以上のシリアルポートがある場合には、どのシリアルポートを使用しても
かまいません。

        タスクマシン          デバッガマシン
    　    シリアル              シリアル
    　    コネクタ              コネクタ

            Pin #                 Pin #
            1 (PG)  <----------> 1 (PG)

            2 (TxD) <----------> 3 (RxD)

            3 (RxD) <----------> 2 (TxD)

    ------- 4 (RTS)              4 (RTS) -------
    |                                           |
    ------> 5 (CTS)              5 (CTS) <------

    ------> 6 (DSR)              6 (DSR) <------
    |                                           |
    |       7 (SG)  <----------> 7 (SG)         |
    |                                           |
    |-----> 8 (DCD)              8 (DCD) <------
    |                                           |
    ------ 20 (DTR)             20 (DTR) -------

図73.　シリアルポート配線

ケーブル配線が左右対称であることに注意してください（すなわち、ケーブルのどち
らの端をどちらのパソコンに接続してもかまいません）。この配線は、（ピンの２と
３が互いに交差し、モデムが使用されていないので）「ヌルモデム」と呼ばれること
があります。

パラレルポート配線上の注意事項（NEC PC-9801シリーズでは使用できません）
-----------------------------------------------------------------------
パラレルポート・デバッグサーバ"PARSERV"または"PARSERVW"の使用を予定している
場合には、２つのコンピュータシステムのパラレルポートをケーブルで接続しなけれ
ばなりません。LapLinkケーブル、Flying Dutchmanケーブル、およびWATCOM固有の
ケーブルという３つのケーブル配線方式がサポートされています。LapLinkケーブル
またはFlying Dutchmanケーブルを使用する場合には、次の２つの長所があります。

    1.      市販されていること（ユーザがすでに持っている場合があります）

    2.      WATCOMのケーブルよりも多くのPC「互換機」と使用できます。WATCOMの
            ケーブル配線方式ではパラレルポートに８ビット双方向データ回線が必
            要ですが、PC「互換機」の中にはこれをサポートしていないものがあり
            ます。

LapLinkケーブルとFlying Dutchmanケーブルの短所は、WATCOMのケーブルよりもデー
タ転送速度が遅いことです。WATCOMでは８ビット転送できるのに対して、これらの
ケーブルでは並列に４ビットしか転送できません。つまり、WATCOMのケーブルの方が
転送速度は速いのですが、注文して作ってもらわなければなりません。

LapLinkケーブルを購入する場合の連絡先：

        Travelling Software, Inc.
        18702 North Creek Parkway
        Bothell, Washington,
        U.S.A. 98011
        電話:(206)483-8088

Flying Dutchmanケーブルを購入する場合の連絡先：

        Cyco,
        Adm. Banckertweg 2a,
        2315 SR Leiden,
        The Netherlands.

次の図は、２つのパラレルポート間のWATCOMケーブル配線を示しています。

      タスクマシン        デバッガマシン
    　  パラレル            パラレル
    　  コネクタ            コネクタ

          Pin #            Pin #
            1 <--------------> 2
            2 <--------------> 1
            3 <--------------> 14
            4 <--------------> 16
            5 <--------------> 15
            6 <--------------> 13
            7 <--------------> 12
            8 <--------------> 10
            9 <--------------> 11
           10 <--------------> 8
           11 <--------------> 9
           12 <--------------> 7
           13 <--------------> 6
           14 <--------------> 3
           15 <--------------> 5
           16 <--------------> 4
           17 <--------------> 17
           18 <--------------> 18

図74.　パラレルポート配線

IBMのPCとPS/2の場合には、コネクタは標準的な「雄」DB-25コネクタです。ケーブル
配線が左右対称であることに注意してください（すなわち、ケーブルのどちらの端を
どちらのパソコンに接続してもかまいません）。

+------------------------------------------------------------------------+
|  注：　３つのケーブルは配線がそれぞれ異なりますが、WATCOMのパラレル通  |
|　信ソフトウェアは、どのケーブルが使用されているか判別できます。        |
+------------------------------------------------------------------------+
::::~~~DEFAULT
      +----------------------------------------------------------+
      |                      W V I D E O                         |
      |  WATCOM Visual Interactive Debugging Execution Overseer  |
      +----------------------------------------------------------+

希望のトピック(<topic>)のヘルプを見るためには、カーソルキーを使って、カーソ
ルをトピックの上に移動し、Enterキーを押すか、マウスを使って、トピックをダブ
ルクリックします。トピックの続きを見るためには、カーソルキーか、PgUp/PgDn
キーか、マウスを使って、このウィンドウをスクロールしてください。Shift/Home
キー(PC-9800のDOS版)またはCtrl/Homeキー(Windows版とPC-9800以外のDOS版)を
使うか、タイトルラインをダブルクリックすると、このインデックスに戻ります。

以下のトピックスのヘルプがあります。

コマンドおよび一般情報:

<BREAK>             <CALL>              <COMMAND_FILES>     <C_OPERATORS>
<C++_OPERATORS>     <DISPLAY>           <DO>                <ERROR>
<EXAMINE>           <F77_OPERATORS>     <FLIP>              <GO>
<HELP>              <IF>                <INVOKE>            <LOG>
<MENUS>             <MODIFY>            <NEW>               <NOTATION>
<PAINT>             <PRINT>             <PRINT_WINDOW>      <QUIT>
<REGISTER>          <REMARK>            <REMOTE_DEBUGGING>  <REMOTE_WIN3>
<RFX>               <SET>               <SHOW>              <SUMMARY>
<SYMBOLS>           <SYSTEM>            <THREAD>            <TRACE>
<VIEW>              <WATCH>             <WHILE>             <WINDOWS>
<WIRING>

システム:

<AUTOCAD>

<DOS_STARTUP>                           <DOS_EXTENDER>
<DOS_GRAPHICS_APPLICATIONS>             <DOS_INTERRUPTING_A_PROGRAM>
<DOS_REMOTE_DEBUGGING>                  <DOS_WVIDEO_ENVIRONMENT_VARIABLE>

<OS2_STARTUP>                           <OS2_INTERRUPTING_A_PROGRAM>
<OS2_REMOTE_DEBUGGING>                  <OS2_WVIDEO_ENVIRONMENT_VARIABLE>

<WIN3_STARTUP>                          <WIN3_WVIDEOW_ENVIRONMENT_VARIABLE>

<WINNT_STARTUP>                         <WINNT_WVIDEO_ENVIRONMENT_VARIABLE>
<WINNT_INTERRUPTING_A_PROGRAM>

トピック名の短縮形を指定することもできます。
