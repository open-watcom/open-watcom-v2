///////////////////////////////////////////////////////////////////////////
// FILE: istream/istream.h (istream class)
//
// =========================================================================
//
//                          Open Watcom Project
//
//    Copyright (c) 2002-2010 Open Watcom Contributors. All Rights Reserved.
//    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
//
//    This file is automatically generated. Do not edit directly.
//
// =========================================================================
//
// Description: This header is part of the C++ standard library. It
//              defines the input stream class, associated parameter-
//              less manipulators, and the input/output stream class.
///////////////////////////////////////////////////////////////////////////
#ifndef _ISTREAM_INCLUDED
#define _ISTREAM_INCLUDED

#ifndef _ENABLE_AUTODEPEND
 #pragma read_only_file;
#endif

#ifndef __cplusplus
 #error This header file requires C++
#endif

#ifndef _COMDEF_H_INCLUDED
 #include <_comdef.h>
#endif

#ifndef _IOS_INCLUDED
 #include <ios>
#endif

#ifndef _OSTREAM_INCLUDED
 #include <ostream>
#endif

namespace std {

  // **************************** ISTREAM ************************************
#pragma pack( __push, 8 )
  class _WPRTLINK istream : virtual public ios {
  public:
    istream( streambuf *__sb );
    istream( istream const &__istrm );
    virtual ~istream();

    istream &operator = ( streambuf * __sb );
    istream &operator = ( istream const &__istrm );
    istream &operator >> (             char * __buf );
    istream &operator >> (      signed char * __buf );
    istream &operator >> (    unsigned char * __buf );
    istream &operator >> (             char & __c );
    istream &operator >> (      signed char & __c );
    istream &operator >> (    unsigned char & __c );
    istream &operator >> (     signed short & __i );
    istream &operator >> (   unsigned short & __i );
    istream &operator >> (       signed int & __i );
    istream &operator >> (     unsigned int & __i );
    istream &operator >> (      signed long & __i );
    istream &operator >> (    unsigned long & __i );
    istream &operator >> (   signed __int64 & __i );
    istream &operator >> ( unsigned __int64 & __i );
    istream &operator >> (            float & __f );
    istream &operator >> (           double & __f );
    istream &operator >> (      long double & __f );
    istream &operator >> (        streambuf * __sb );
    istream &operator >> ( _WPRTLINK ios &(*__f)( ios & ) );
    istream &operator >> ( _WPRTLINK istream &(*__f)( istream & ) );

    int        ipfx( int __noskipws = 0 );
    void       isfx();
    int        get();
    istream   &get(          char *__buf, int __len, char __delim = '\n' );
    istream   &get(   signed char *__buf, int __len, char __delim = '\n' );
    istream   &get( unsigned char *__buf, int __len, char __delim = '\n' );
    istream   &get(          char &__c );
    istream   &get(   signed char &__c );
    istream   &get( unsigned char &__c );
    istream   &get( streambuf &__sb, char __delim = '\n' );
    istream   &getline(          char *__buf, int __len, char __delim = '\n' );
    istream   &getline(   signed char *__buf, int __len, char __delim = '\n' );
    istream   &getline( unsigned char *__buf, int __len, char __delim = '\n' );
    istream   &ignore( int __num = 1, int __delim = EOF );
    istream   &read(          char *__buf, int __len );
    istream   &read(   signed char *__buf, int __len );
    istream   &read( unsigned char *__buf, int __len );
    istream   &seekg( streampos __position );
    istream   &seekg( streamoff __offset, ios::seekdir __direction );
    istream   &putback( char __c );
    streampos  tellg();
    int        gcount() const;
    int        peek();
    int        sync();

  protected:
    istream();
    void     eatwhite();
    istream &do_get( char &__c );
    istream &do_rshift( char &__c );
    istream &do_read( char *__buf, int __len );
    int      ipfx0( void );
    int      ipfx1( void );
    int      do_ipfx( int __noskipws );

  private:
    int __last_read_length;
  };
#pragma pack( __pop )

  inline istream &istream::operator >> ( signed char *__buf ) {
    return( *this >> (char *) __buf );
  }

  inline istream &istream::operator >> ( unsigned char *__buf ) {
    return( *this >> (char *) __buf );
  }

#ifdef __BIG_INLINE__
  inline istream &istream::operator >> ( char &__c ) {
    __lock_it( __i_lock );
    if( ipfx0() ) {
        if( rdbuf()->in_avail() ) {
            __c = (char)(rdbuf()->sgetchar());
        } else {
            do_rshift( __c );
        }
        isfx();
    }
    return( *this );
  }
#endif

  inline istream &istream::operator >> ( signed char &__c ) {
    return( *this >> (char &) __c );
  }

  inline istream &istream::operator >> ( unsigned char &__c ) {
    return( *this >> (char &) __c );
  }

  inline istream &istream::get( signed char *__buf, int __len, char __delim ) {
    return( get( (char *)__buf, __len, __delim ) );
  }

  inline istream &istream::get( unsigned char *__buf,
                                int __len,
                                char __delim ) {
    return( get( (char *)__buf, __len, __delim ) );
  }

#ifdef __BIG_INLINE__
  inline istream &istream::get( char &__c ) {
    __lock_it( __i_lock );
    if( ipfx1() ) {
        if( rdbuf()->in_avail() ) {
            __c = (char)(rdbuf()->sgetchar());
        } else {
            do_get( __c );
        }
        isfx();
    } else {
        __last_read_length = 0;
    }
    return( *this );
  }
#endif

  inline istream &istream::get( signed char &__c ) {
    return( get( (char &) __c ) );
  }

  inline istream &istream::get( unsigned char &__c ) {
    return( get( (char &) __c ) );
  }

  inline istream &istream::getline( signed char *__buf,
                                    int __len,
                                    char __delim ) {
    return( getline( (char *)__buf, __len, __delim ) );
  }

  inline istream &istream::getline( unsigned char *__buf,
                                    int __len,
                                    char __delim ) {
    return( getline( (char *)__buf, __len, __delim ) );
  }

#ifdef __BIG_INLINE__
  inline istream &istream::read( char *__buf, int __len ) {
    __lock_it( __i_lock );
    if( ipfx1() ) {
        if( rdbuf()->in_avail() > __len ) {
            __last_read_length = rdbuf()->sgetn( __buf, __len );
        } else {
            do_read( __buf , __len );
        }
        isfx();
    } else {
        __last_read_length = 0;
    }
    return( *this );
  }
#endif

  inline istream &istream::read( signed char *__buf, int __len ) {
    return( read( (char *) __buf, __len ) );
  }

  inline istream &istream::read( unsigned char *__buf, int __len ) {
    return( read( (char *) __buf, __len ) );
  }

  inline int istream::ipfx0( void ) {
    __lock_it( __i_lock );
    return( ((flags()&ios::skipws) || !good() || tie()) ? do_ipfx( 0 ) : 1);
  }

  inline int istream::ipfx1( void ) {
    __lock_it( __i_lock );
    return( (!good() || tie()) ? do_ipfx( 1 ) : 1);
  }

  inline void istream::isfx() {
  }

  inline int istream::gcount() const {
    return( __last_read_length );
  }


  // **************************** MANIPULATORS *******************************
  _WPRTLINK extern istream &   ws( istream & );


  // **************************** IOSTREAM ***********************************
#pragma pack( __push, 8 )
  class _WPRTLINK iostream : public istream, public ostream {
  public:
    iostream( streambuf *__sb );
    iostream( ios const &__strm );
    virtual ~iostream();

    iostream & operator = ( streambuf *__sb );
    iostream & operator = ( ios const &__strm );

  protected:
    iostream();
  };
#pragma pack( __pop )

} // namespace std

#endif
