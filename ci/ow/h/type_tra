///////////////////////////////////////////////////////////////////////////
// FILE: type_traits
//
// =========================================================================
//
//                          Open Watcom Project
//
// Copyright (c) 2004-2010 The Open Watcom Contributors. All Rights Reserved.
//
//    This file is automatically generated. Do not edit directly.
//
// =========================================================================
//
// Description: This header is part of the C++ standard library extentions
//              TR1 as currently defined in n1836
///////////////////////////////////////////////////////////////////////////
#ifndef _TYPE_TRAITS_INCLUDED
#define _TYPE_TRAITS_INCLUDED

#ifndef _ENABLE_AUTODEPEND
 #pragma read_only_file;
#endif

#ifndef __cplusplus
 #error This header file requires C++
#endif

namespace std {
namespace tr1 {

template< class T, T v >
struct integral_constant{
    static const T value = v;
    typedef T value_type;
    typedef integral_constant< T, v > type;
};
typedef integral_constant< bool, true >  true_type;
typedef integral_constant< bool, false > false_type;

#define __MAKE_TYPE_TRAIT_DEFAULT( name, base ) \
    template < class T > struct name : public base {};
#define __MAKE_TYPE_TRAIT( name, type, base ) \
    template <> struct name< type > : public base {};
#define __MAKE_TYPE_TRAIT_MOD( name, modifer, base ) \
    template < class T > struct name< T modifer > : public base {};
#define __MAKE_TYPE_TRAITS_CV( name, type, base ) \
    __MAKE_TYPE_TRAIT( name, type, base ) \
    __MAKE_TYPE_TRAIT( name, type const, base ) \
    __MAKE_TYPE_TRAIT( name, type volatile, base ) \
    __MAKE_TYPE_TRAIT( name, type const volatile, base )
#define __MAKE_TYPE_TRAITS_MOD_CV( name, mod, base ) \
    __MAKE_TYPE_TRAIT_MOD( name, mod, base ) \
    __MAKE_TYPE_TRAIT_MOD( name, mod const, base ) \
    __MAKE_TYPE_TRAIT_MOD( name, mod volatile, base ) \
    __MAKE_TYPE_TRAIT_MOD( name, mod const volatile, base )
#define __MAKE_TYPE_TRAITS_CV_SUS( name, type, base ) \
    __MAKE_TYPE_TRAITS_CV( name, unsigned type, base ) \
    __MAKE_TYPE_TRAITS_CV( name, signed type, base )

// ==================================================================
// 4.5.1 primary type categories
/* ------------------------------------------------------------------
 * is_void
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_void, false_type )
__MAKE_TYPE_TRAITS_CV( is_void, void, true_type )

/* ------------------------------------------------------------------
 * is_integral
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_integral, false_type )
__MAKE_TYPE_TRAITS_CV_SUS( is_integral, int, true_type )
__MAKE_TYPE_TRAITS_CV_SUS( is_integral, short, true_type )
__MAKE_TYPE_TRAITS_CV_SUS( is_integral, long, true_type )
__MAKE_TYPE_TRAITS_CV_SUS( is_integral, long long, true_type )
__MAKE_TYPE_TRAITS_CV( is_integral, bool, true_type )
__MAKE_TYPE_TRAITS_CV( is_integral, signed char, true_type )
__MAKE_TYPE_TRAITS_CV( is_integral, unsigned char, true_type )
__MAKE_TYPE_TRAITS_CV( is_integral, char, true_type )
__MAKE_TYPE_TRAITS_CV( is_integral, wchar_t, true_type )


/* ------------------------------------------------------------------
 * is_floating_point
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_floating_point, false_type )
__MAKE_TYPE_TRAITS_CV( is_floating_point, float, true_type )
__MAKE_TYPE_TRAITS_CV( is_floating_point, double, true_type )
__MAKE_TYPE_TRAITS_CV( is_floating_point, long double, true_type )

/* ------------------------------------------------------------------
 * is_pointer
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_pointer, false_type )
__MAKE_TYPE_TRAITS_MOD_CV( is_pointer, *, true_type )

/* ------------------------------------------------------------------
 * is_reference
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_reference, false_type )
__MAKE_TYPE_TRAITS_MOD_CV( is_reference, &, true_type )

/*
 * err will these need compiler support?
template <class T>
struct is_member_object_pointer;
template <class T>
struct is_member_function_pointer;
template <class T>
struct is_enum;
template <class T>
struct is_union;
template <class T>
struct is_class;
template <class T>
struct is_function;
*/

// ==================================================================
// 4.5.2 composite type traits
/* ------------------------------------------------------------------
 * is_arithmetic
 */
template < class T >
struct is_arithmetic : public integral_constant< bool, 
                                is_integral< T >::value ||
                                is_floating_point< T >::value >
{ };

/* ------------------------------------------------------------------
 * is_fundamental
 */
template < class T >
struct is_fundamental : public integral_constant< bool, 
                                is_integral< T >::value ||
                                is_floating_point< T >::value ||
                                is_void< T >::value >
{ };
/*
template <class T>
struct is_object;
template <class T>
struct is_scalar;
template <class T>
struct is_compound;
template <class T>
struct is_member_pointer;
*/

// ==================================================================
// 4.5.3 type properties
/* ------------------------------------------------------------------
 * is_const
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_const, false_type )
__MAKE_TYPE_TRAIT_MOD( is_const, const, true_type )

/* ------------------------------------------------------------------
 * is_volatile
 */
__MAKE_TYPE_TRAIT_DEFAULT( is_volatile, false_type )
__MAKE_TYPE_TRAIT_MOD( is_volatile, volatile, true_type )

/*
template <class T> struct is_pod;
template <class T> struct is_empty;
template <class T> struct is_polymorphic;
template <class T> struct is_abstract;
template <class T> struct has_trivial_constructor;
template <class T> struct has_trivial_copy;
template <class T> struct has_trivial_assign;
template <class T> struct has_trivial_destructor;
template <class T> struct has_nothrow_constructor;
template <class T> struct has_nothrow_copy;
template <class T> struct has_nothrow_assign;
template <class T> struct has_virtual_destructor;
template <class T> struct is_signed;
template <class T> struct is_unsigned;
template <class T> struct alignment_of;
template <class T> struct rank;
template <class T, unsigned I = 0> struct extent;
*/

// ==================================================================
// 4.6 type relations
/* ------------------------------------------------------------------
 * is_same
 */
template < class T, class U > struct is_same : public false_type {};
template < class T > struct is_same< T, T > : public true_type {};
/*
template <class Base, class Derived> struct is_base_of;
template <class From, class To> struct is_convertible;
*/

// ==================================================================
// 4.7.1 const-volatile modifications
/* ------------------------------------------------------------------
 * remove_const
 */
template< typename T >
struct remove_const{ typedef T type; };

template< typename T >
struct remove_const< T const >{ typedef T type; };

/* ------------------------------------------------------------------
 * remove_volatile
 */
template< typename T >
struct remove_volatile{ typedef T type; };

template< typename T >
struct remove_volatile< T volatile >{ typedef T type; };

/* ------------------------------------------------------------------
 * remove_cv
 */
template< typename T >
struct remove_cv{ 
    typedef remove_volatile< remove_const< T >::type >::type type; 
};

/* ------------------------------------------------------------------
 * add_const
 */
template< typename T >
struct add_const{ typedef T const type; };

/* ------------------------------------------------------------------
 * add_volatile
 */
template< typename T >
struct add_volatile{ typedef T volatile type; };

/* ------------------------------------------------------------------
 * add_cv
 */
template< typename T >
struct add_cv{ typedef T const volatile type; };

// ==================================================================
// 4.7.2 reference modifications
/* ------------------------------------------------------------------
 * remove_reference
 */
template< typename T >
struct remove_reference{ typedef T type; };
template< typename T >
struct remove_reference< T& > { typedef T type; };
template< typename T >
struct remove_reference< T& const > { typedef T type; };
template< typename T >
struct remove_reference< T& volatile > { typedef T type; };
template< typename T >
struct remove_reference< T& const volatile > { typedef T type; };

/* ------------------------------------------------------------------
 * add_reference
 */
template< typename T >
struct add_reference{ typedef T& type; };
template< typename T >
struct add_reference< T& > { typedef T& type; };
template< typename T >
struct add_reference< T& const > { typedef T& const type; };
template< typename T >
struct add_reference< T& volatile > { typedef T& volatile type; };
template< typename T >
struct add_reference< T& const volatile > { typedef T& const volatile type; };

// ==================================================================
// 4.7.3 array modifications
/*
template <class T> struct remove_extent;
template <class T> struct remove_all_extents;
*/

// ==================================================================
// 4.7.4 pointer modifications
/* ------------------------------------------------------------------
 * remove_pointer
 */
template< typename T >
struct remove_pointer{ typedef T type; };
template< typename T >
struct remove_pointer< T* > { typedef T type; };
template< typename T >
struct remove_pointer< T* const > { typedef T type; };
template< typename T >
struct remove_pointer< T* volatile > { typedef T type; };
template< typename T >
struct remove_pointer< T* const volatile > { typedef T type; };

/*
template <class T> struct add_pointer;
*/

// ==================================================================
// 4.8 other transformations
/*
template <std::size_t Len, std::size_t Align> struct aligned_storage;
*/

} // namespace tr1
} // namespace std

#endif
